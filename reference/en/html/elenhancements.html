<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;30.&nbsp;Expression language enhancements</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Seam - Contextual Components"><link rel="up" href="index.html" title="Seam - Contextual Components"><link rel="previous" href="controls.html" title="Chapter&nbsp;29.&nbsp;Seam JSF controls"><link rel="next" href="testing.html" title="Chapter&nbsp;31.&nbsp;Testing Seam applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;30.&nbsp;Expression language enhancements</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="controls.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="testing.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="elenhancements"></a>Chapter&nbsp;30.&nbsp;Expression language enhancements</h2></div></div><div></div></div><p> Seam provides an extension to the standard Unified Expression Language (EL) called JBoss EL. JBoss EL
        provides a number of enhancements that increase the expressiveness and power of EL expressions. </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19150"></a>30.1.&nbsp;Parameterized Method Bindings</h2></div></div><div></div></div><p> Standard EL assumes that any parameters to a method expression will be provided by Java code. This means
            that a method with parameters cannot be used as a JSF method binding. Seam provides an enhancement to the EL
            that allows parameters to be included in a method expression itself. This applies to
            <span class="emphasis"><em>any</em></span> Seam method expression, including any JSF method binding, for example: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel)}" value="Book Hotel"/&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19160"></a>30.1.1.&nbsp;Usage</h3></div></div><div></div></div><p> Parameters are surrounded by parentheses, and separated by commas: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel, user)}" value="Book Hotel"/&gt;</pre><p> The parameters <tt class="literal">hotel</tt> and <tt class="literal">user</tt> will be evaluated as value
                expressions and passed to the <tt class="literal">bookHotel()</tt> method of the component. This gives you an
                alternative to the use of <tt class="literal">@In</tt>. </p><p> Any value expression may be used as a parameter: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel.id, user.username)}" 
                 value="Book Hotel"/&gt;</pre><p>
                <span class="emphasis"><em>Note:</em></span> You can not pass objects as arguments! All that is passed is names, for
                example, <tt class="literal">hotel.id</tt> and <tt class="literal">user.username</tt>. If you check the rendered
                code of the previous example, you will see that the command button contains these names. These name
                arguments will be submitted to the server when you press the button, and Seam will look up and resolve
                these names (in any available context) before the action method is called. If the arguments can not be
                resolved at that time (because <tt class="literal">hotel</tt> and <tt class="literal">user</tt> variables can not be
                found in any available context) the action method will be called with <tt class="literal">null</tt> arguments! </p><p> You may however pass literal strings using single or double quotes: </p><pre class="programlisting">&lt;h:commandLink action="#{printer.println('Hello world!')}" value="Hello"/&gt;</pre><pre class="programlisting">&lt;h:commandLink action="#{printer.println('Hello again')} value="Hello"/&gt;</pre><p> You might even want to use this notation for all your action methods, even when you don't have
                parameters to pass. This improves readability by making it clear that the expression is a method
                expression and not a value expression: </p><pre class="programlisting">&lt;s:link value="Cancel" action="#{hotelBooking.cancel()}"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19215"></a>30.1.2.&nbsp;Limitations</h3></div></div><div></div></div><p> Please be aware of the following limitations: </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e19220"></a>30.1.2.1.&nbsp;Incompatibility with JSP 2.1</h4></div></div><div></div></div><p> This extension is not currently compatible with JSP 2.1. So if you want to use this extension
                    with JSF 1.2, you will need to use Facelets. The extension works correctly with JSP 2.0. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e19225"></a>30.1.2.2.&nbsp;Calling a <tt class="literal">MethodExpression</tt> from Java code</h4></div></div><div></div></div><p> Normally, when a <tt class="literal">MethodExpression</tt> or <tt class="literal">MethodBinding</tt> is
                    created, the parameter types are passed in by JSF. In the case of a method binding, JSF assumes that
                    there are no parameters to pass. With this extension, we can't know the parameter types until
                    after the expression has been evaluated. This has two minor consequences: </p><div class="itemizedlist"><ul type="disc"><li><p> When you invoke a <tt class="literal">MethodExpression</tt> in Java code, parameters you pass
                            may be ignored. Parameters defined in the expression will take precedence. </p></li><li><p> Ordinarily, it is safe to call
                            <tt class="literal">methodExpression.getMethodInfo().getParamTypes()</tt> at any time. For an
                            expression with parameters, you must first invoke the <tt class="literal">MethodExpression</tt>
                            before calling <tt class="literal">getParamTypes()</tt>. </p></li></ul></div><p> Both of these cases are exceedingly rare and only apply when you want to invoke the
                        <tt class="literal">MethodExpression</tt> by hand in Java code. </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19263"></a>30.2.&nbsp;Parameterized Value Bindings</h2></div></div><div></div></div><p> Standard EL only allows access to properties that follow the JavaBean naming conventions. For example,
            the expression <tt class="literal">#{person.name}</tt> requires a <tt class="literal">getName()</tt> be present. Many
            objects, however, don't have appropriately named property accessors or require parameters. These values can
            be retrieved using the method syntax, which work similarly to parameterized method bindings. For example,
            the following expression returns the size of a string using the <tt class="literal">length()</tt> method. </p><pre class="programlisting">#{person.name.length()}</pre><p>You can access the size of a collection in a similar manner.</p><pre class="programlisting">#{searchResults.size()}</pre><p>In general any expression of the form #{obj.property} would be identical to the expression
            #{obj.getProperty()}.</p><p>Parameters are also allowed, and they follow the same restrictions as with method bindings. The following
            example calls the <tt class="literal">productsByColorMethod</tt> with a literal string argument.</p><pre class="programlisting">#{controller.productsByColor('blue')}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19292"></a>30.3.&nbsp;Projection</h2></div></div><div></div></div><p>JBoss EL supports a limited projection syntax. It is important to note that this syntax cannot be parsed
            by Facelets or by JavaServer Pages and thus cannot be used in xhtml or JSP files. We anticipate that the
            projection syntax will change in future versions of JBoss EL. </p><p> A projection expression maps a sub-expression across a multi-valued (list, set, etc...) expression. For
            instance, the expression </p><pre class="programlisting">#{company.departments}</pre><p>might return a list of departments. If you only need a list of department names, your only option is to
            iterate over the list to retrieve the values. JBoss EL allows this with a projection expression.</p><pre class="programlisting">#{company.departments.{d|d.name}}</pre><p>The subexpression is enclosed in braces. In this example, the expression <tt class="literal">d.name</tt> is
            evaluated for each department, using <tt class="literal">d</tt> as an alias to the department object. The result
            of this expression will be a list of String values.</p><p>Any valid expression can be used in an expression, so it would be perfectly valid to write the following,
            assuming you had a use for the lengths of all the department names in a company.</p><pre class="programlisting">#{company.departments.{d|d.size()}}</pre><p>Projections can be nested. The following expression returns the last names of every employee in every
            department.</p><pre class="programlisting">#{company.departments.{d|d.employees.{emp|emp.lastName}}}</pre><p>Nested projections can be slightly tricky, however. The following expression looks like it returns a list
            of all the employees in all the departments. </p><pre class="programlisting">#{company.departments.{d|d.employees}}</pre><p>However, it actually returns a list containing a list of the employees for each individual department. To
            combine the values, it is necessary to use a slightly longer expression.</p><pre class="programlisting">#{company.departments.{d|d.employees.{e|e}}}</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="controls.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="testing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;29.&nbsp;Seam JSF controls&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;31.&nbsp;Testing Seam applications</td></tr></table></div></body></html>