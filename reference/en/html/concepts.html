<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;The contextual component model</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Seam - Contextual Components"><link rel="up" href="index.html" title="Seam - Contextual Components"><link rel="previous" href="gettingstarted.html" title="Chapter&nbsp;2.&nbsp;Getting started with Seam, using seam-gen"><link rel="next" href="xml.html" title="Chapter&nbsp;4.&nbsp;Configuring Seam components"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;The contextual component model</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="gettingstarted.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="xml.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="concepts"></a>Chapter&nbsp;3.&nbsp;The contextual component model</h2></div></div><div></div></div><p> 
        The two core concepts in Seam are the notion of a <span class="emphasis"><em>context</em></span> and the notion of a
        <span class="emphasis"><em>component</em></span>. Components are stateful objects, usually EJBs, and an instance of a
        component is associated with a context, and given a name in that context. <span class="emphasis"><em>Bijection</em></span>
        provides a mechanism for aliasing internal component names (instance variables) to contextual names, allowing
        component trees to be dynamically assembled, and reassembled by Seam.
    </p><p>
        Let's start by describing the contexts built in to Seam.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2517"></a>3.1.&nbsp;Seam contexts</h2></div></div><div></div></div><p> Seam contexts are created and destroyed by the framework. The application does not control context
            demarcation via explicit Java API calls. Context are usually implicit. In some cases, however, contexts are
            demarcated via annotations. </p><p> The basic Seam contexts are: </p><div class="itemizedlist"><ul type="disc"><li><p> Stateless context </p></li><li><p> Event (or request) context </p></li><li><p> Page context </p></li><li><p> Conversation context </p></li><li><p> Session context </p></li><li><p> Business process context </p></li><li><p> Application context </p></li></ul></div><p> 
            You will recognize some of these contexts from servlet and related specifications. However, two of them
            might be new to you: <span class="emphasis"><em>conversation context</em></span>, and <span class="emphasis"><em>business process
            context</em></span>. One reason state management in web applications is so fragile and error-prone is that
            the three built-in contexts (request, session and application) are not especially meaningful from the point
            of view of the business logic. A user login session, for example, is a fairly arbitrary construct in terms
            of the actual application work flow. Therefore, most Seam components are scoped to the conversation or
            business process contexts, since they are the contexts which are most meaningful in terms of the
            application.
        </p><p>
            Let's look at each context in turn.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2556"></a>3.1.1.&nbsp;Stateless context</h3></div></div><div></div></div><p>
                Components which are truly stateless (stateless session beans, primarily) always live in the
                stateless context (this is really a non-context). Stateless components are not very interesting, and are
                arguably not very object-oriented. Nevertheless, they are important and often useful.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2561"></a>3.1.2.&nbsp;Event context</h3></div></div><div></div></div><p>
                The event context is the "narrowest" stateful context, and is a generalization of the notion of the
                web request context to cover other kinds of events. Nevertheless, the event context associated with the
                lifecycle of a JSF request is the most important example of an event context, and the one you will work
                with most often. Components associated with the event context are destroyed at the end of the request,
                but their state is available and well-defined for at least the lifecycle of the request.
            </p><p> 
                When you invoke a Seam component via RMI, or Seam Remoting, the event context is created and
                destroyed just for the invocation.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2568"></a>3.1.3.&nbsp;Page context</h3></div></div><div></div></div><p>
                The page context allows you to associate state with a particular instance of a rendered page. You can
                initialize state in your event listener, or while actually rendering the page, and then have access to
                it from any event that originates from that page. This is especially useful for functionality like
                clickable lists, where the list is backed by changing data on the server side. The state is actually
                serialized to the client, so this construct is extremely robust with respect to multi-window operation
                and the back button.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2573"></a>3.1.4.&nbsp;Conversation context</h3></div></div><div></div></div><p>
                The conversation context is a truly central concept in Seam. A <span class="emphasis"><em>conversation</em></span> is a
                unit of work from the point of view of the user. It might span several interactions with the user,
                several requests, and several database transactions. But to the user, a conversation solves a single
                problem. For example, "book hotel", "approve contract", "create order" are all conversations. You might
                like to think of a conversation implementing a single "use case" or "user story", but the relationship 
                is not necessarily quite exact.
            </p><p>
                A conversation holds state associated with "what the user is doing now, in this window". A single
                user may have multiple conversations in progress at any point in time, usually in multiple windows. The
                conversation context allows us to ensure that state from the different conversations does not collide
                and cause bugs.
            </p><p>
                It might take you some time to get used to thinking of applications in terms of conversations. But
                once you get used to it, we think you'll love the notion, and never be able to not think in terms of
                conversations again!
            </p><p>
                Some conversations last for just a single request. Conversations that span multiple requests must be
                demarcated using annotations provided by Seam.
            </p><p>
                Some conversations are also <span class="emphasis"><em>tasks</em></span>. A task is a conversation that is significant
                in terms of a long-running business process, and has the potential to trigger a business process state
                transition when it is successfully completed. Seam provides a special set of annotations for task
                demarcation.
            </p><p>
                Conversations may be <span class="emphasis"><em>nested</em></span>, with one conversation taking place "inside" a wider
                conversation. This is an advanced feature.
            </p><p>
                Usually, conversation state is actually held by Seam in the servlet session between requests. Seam
                implements configurable <span class="emphasis"><em>conversation timeout</em></span>, automatically destroying inactive
                conversations, and thus ensuring that the state held by a single user login session does not grow
                without bound if the user abandons conversations.
            </p><p>
                Seam serializes processing of concurrent requests that take place in the same long-running
                conversation context, in the same process.
            </p><p>
                Alternatively, Seam may be configured to keep conversational state in the client browser.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2606"></a>3.1.5.&nbsp;Session context</h3></div></div><div></div></div><p>
                A session context holds state associated with the user login session. While there are some cases
                where it is useful to share state between several conversations, we generally frown on the use of
                session context for holding components other than global information about the logged in user.
            </p><p> 
                In a JSR-168 portal environment, the session context represents the portlet session. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2613"></a>3.1.6.&nbsp;Business process context</h3></div></div><div></div></div><p> 
                The business process context holds state associated with the long running business process. This
                state is managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple
                interactions with multiple users, so this state is shared between multiple users, but in a well-defined
                manner. The current task determines the current business process instance, and the lifecycle of the
                business process is defined externally using a <span class="emphasis"><em>process definition language</em></span>, so
                there are no special annotations for business process demarcation. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2621"></a>3.1.7.&nbsp;Application context</h3></div></div><div></div></div><p> 
                The application context is the familiar servlet context from the servlet spec. Application context is
                mainly useful for holding static information such as configuration data, reference data or metamodels.
                For example, Seam stores its own configuration and metamodel in the application context. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2626"></a>3.1.8.&nbsp;Context variables</h3></div></div><div></div></div><p> 
                A context defines a namespace, a set of <span class="emphasis"><em>context variables</em></span>. These work much the
                same as session or request attributes in the servlet spec. You may bind any value you like to a context
                variable, but usually we bind Seam component instances to context variables. 
            </p><p> 
                So, within a context, a component instance is identified by the context variable name (this is
                usually, but not always, the same as the component name). You may programatically access a named
                component instance in a particular scope via the <tt class="literal">Contexts</tt> class, which provides
                access to several thread-bound instances of the <tt class="literal">Context</tt> interface: 
            </p><pre class="programlisting">User user = (User) Contexts.getSessionContext().get("user");</pre><p>
                You may also set or change the value associated with a name: 
            </p><pre class="programlisting">Contexts.getSessionContext().set("user", user);</pre><p> 
                Usually, however, we obtain components from a context via injection, and put component instances into
                a context via outjection. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2650"></a>3.1.9.&nbsp;Context search priority</h3></div></div><div></div></div><p> 
                Sometimes, as above, component instances are obtained from a particular known scope. Other times, all
                stateful scopes are searched, in <span class="emphasis"><em>priority order</em></span>. The order is as follows: 
            </p><div class="itemizedlist"><ul type="disc"><li><p> Event context </p></li><li><p> Page context </p></li><li><p> Conversation context </p></li><li><p> Session context </p></li><li><p> Business process context </p></li><li><p> Application context </p></li></ul></div><p> 
                You can perform a priority search by calling <tt class="literal">Contexts.lookupInStatefulContexts()</tt>.
                Whenever you access a component by name from a JSF page, a priority search occurs. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="concurrency"></a>3.1.10.&nbsp;Concurrency model</h3></div></div><div></div></div><p> 
                Neither the servlet nor EJB specifications define any facilities for managing concurrent requests
                originating from the same client. The servlet container simply lets all threads run concurrently and
                leaves enforcing threadsafeness to application code. The EJB container allows stateless components to be
                accessed concurrently, and throws an exception if multiple threads access a stateful session bean. 
            </p><p> 
                This behavior might have been okay in old-style web applications which were based around
                fine-grained, synchronous requests. But for modern applications which make heavy use of many
                fine-grained, asynchronous (AJAX) requests, concurrency is a fact of life, and must be supported by the
                programming model. Seam weaves a concurrency management layer into its context model. 
            </p><p> 
                The Seam session and application contexts are multithreaded. Seam will allow concurrent requests in a
                context to be processed concurrently. The event and page contexts are by nature single threaded. The
                business process context is strictly speaking multi-threaded, but in practice concurrency is
                sufficiently rare that this fact may be disregarded most of the time. Finally, Seam enforces a
                <span class="emphasis"><em>single thread per conversation per process</em></span> model for the conversation context
                by serializing concurrent requests in the same long-running conversation context. 
            </p><p> 
                Since the session context is multithreaded, and often contains volatile state, session scope
                components are always protected by Seam from concurrent access. Seam serializes requests to session
                scope session beans and JavaBeans by default (and detects and breaks any deadlocks that occur). This is
                not the default behaviour for application scoped components however, since application scoped components
                do not usually hold volatile state and because synchronization at the global level is
                <span class="emphasis"><em>extremely</em></span> expensive. However, you can force a serialized threading model on any
                session bean or JavaBean component by adding the <tt class="literal">@Synchronized</tt> annotation. 
            </p><p> 
                This concurrency model means that AJAX clients can safely use volatile session and conversational
                state, without the need for any special work on the part of the developer.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2704"></a>3.2.&nbsp;Seam components</h2></div></div><div></div></div><p> 
            Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0
            enterprise beans. While Seam does not require that components be EJBs and can even be used without an EJB
            3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration with EJB 3.0.
            Seam supports the following <span class="emphasis"><em>component types</em></span>. 
        </p><div class="itemizedlist"><ul type="disc"><li><p> EJB 3.0 stateless session beans </p></li><li><p> EJB 3.0 stateful session beans </p></li><li><p> EJB 3.0 entity beans </p></li><li><p> JavaBeans </p></li><li><p> EJB 3.0 message-driven beans </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2728"></a>3.2.1.&nbsp;Stateless session beans</h3></div></div><div></div></div><p> 
                Stateless session bean components are not able to hold state across multiple invocations. Therefore,
                they usually work by operating upon the state of other components in the various Seam contexts. They may
                be used as JSF action listeners, but cannot provide properties to JSF components for display. 
            </p><p> 
                Stateless session beans always live in the stateless context. 
            </p><p> 
                Stateless session beans can be accessed concurrently as a new instance is used for each request. 
                Assigning the instance to the request is the responsibility of the EJB3 container (normally instances
                will be allocated from a reusable pool meaning that you may find any instance variables contain data
                from previous uses of the bean). 
            </p><p> 
                Stateless session beans are the least interesting kind of Seam component. 
            </p><p>
                Seam stateless session bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated via JNDI lookup
                or the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2750"></a>3.2.2.&nbsp;Stateful session beans</h3></div></div><div></div></div><p> 
                Stateful session bean components are able to hold state not only across multiple invocations of the
                bean, but also across multiple requests. Application state that does not belong in the database should
                usually be held by stateful session beans. This is a major difference between Seam and many other web
                application frameworks. Instead of sticking information about the current conversation directly in the
                <tt class="literal">HttpSession</tt>, you should keep it in instance variables of a stateful session bean
                that is bound to the conversation context. This allows Seam to manage the lifecycle of this state for
                you, and ensure that there are no collisions between state relating to different concurrent
                conversations. 
            </p><p> 
                Stateful session beans are often used as JSF action listener, and as backing beans that provide
                properties to JSF components for display or form submission. 
            </p><p> 
                By default, stateful session beans are bound to the conversation context. They may never be bound to
                the page or stateless contexts. 
            </p><p> 
                Concurrent requests to session-scoped stateful session beans are always serialized by Seam. 
            </p><p>
                Seam stateful session bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated via JNDI lookup
                or the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2775"></a>3.2.3.&nbsp;Entity beans</h3></div></div><div></div></div><p> 
                Entity beans may be bound to a context variable and function as a seam component. Because entities
                have a persistent identity in addition to their contextual identity, entity instances are usually bound
                explicitly in Java code, rather than being instantiated implicitly by Seam. 
            </p><p> 
                Entity bean components do not support bijection or context demarcation. Nor does invocation of an
                entity bean trigger validation. 
            </p><p> 
                Entity beans are not usually used as JSF action listeners, but do often function as backing beans
                that provide properties to JSF components for display or form submission. In particular, it is common to
                use an entity as a backing bean, together with a stateless session bean action listener to implement
                create/update/delete type functionality. 
            </p><p>
                By default, entity beans are bound to the conversation context. They may never be bound to the
                stateless context. 
            </p><p> 
                Note that it in a clustered environment is somewhat less efficient to bind an entity bean directly to
                a conversation or session scoped Seam context variable than it would be to hold a reference to the
                entity bean in a stateful session bean. For this reason, not all Seam applications define entity beans
                to be Seam components. 
            </p><p>
                Seam entity bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>,
                <tt class="literal">@In(create=true)</tt> or directly using the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2799"></a>3.2.4.&nbsp;JavaBeans</h3></div></div><div></div></div><p> 
                Javabeans may be used just like a stateless or stateful session bean. However, they do not provide
                the functionality of a session bean (declarative transaction demarcation, declarative security,
                efficient clustered state replication, EJB 3.0 persistence, timeout methods, etc). 
            </p><p> 
                In a later chapter, we show you how to use Seam and Hibernate without an EJB container. In this use
                case, components are JavaBeans instead of session beans. Note, however, that in many application servers
                it is somewhat less efficient to cluster conversation or session scoped Seam JavaBean components than it
                is to cluster stateful session bean components. 
            </p><p> 
                By default, JavaBeans are bound to the event context. 
            </p><p> 
                Concurrent requests to session-scoped JavaBeans are always serialized by Seam. 
            </p><p>
                Seam JavaBean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated using the 
                <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2821"></a>3.2.5.&nbsp;Message-driven beans</h3></div></div><div></div></div><p> 
                Message-driven beans may function as a seam component. However, message-driven beans are called quite
                differently to other Seam components - instead of invoking them via the context variable, they listen
                for messages sent to a JMS queue or topic. 
            </p><p> 
                Message-driven beans may not be bound to a Seam context. Nor do they have access to the session or
                conversation state of their "caller". However, they do support bijection and some other Seam
                functionality. 
            </p><p>
                Message-driven beans are never instantiated by the application. They are instantiated by the EJB
                container when a message is received.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2830"></a>3.2.6.&nbsp;Interception</h3></div></div><div></div></div><p> 
                In order to perform its magic (bijection, context demarcation, validation, etc), Seam must intercept
                component invocations. For JavaBeans, Seam is in full control of instantiation of the component, and no
                special configuration is needed. For entity beans, interception is not required since bijection and
                context demarcation are not defined. For session beans, we must register an EJB interceptor for the
                session bean component. We could use an annotation, as follows: 
            </p><pre class="programlisting">@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                But a much better way is to define the interceptor in <tt class="literal">ejb-jar.xml</tt>. 
            </p><pre class="programlisting">&lt;interceptors&gt;
   &lt;interceptor&gt;
      &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
   &lt;/interceptor&gt;
&lt;/interceptors&gt;
   
&lt;assembly-descriptor&gt;
   &lt;interceptor-binding&gt;
      &lt;ejb-name&gt;*&lt;/ejb-name&gt;
      &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
   &lt;/interceptor-binding&gt;
&lt;/assembly-descriptor&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2844"></a>3.2.7.&nbsp;Component names</h3></div></div><div></div></div><p> 
                All seam components need a name. We can assign a name to a component using the
                <tt class="literal">@Name</tt> annotation: 
            </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                This name is the <span class="emphasis"><em>seam component name</em></span> and is not related to any other name
                defined by the EJB specification. However, seam component names work just like JSF managed bean names
                and you can think of the two concepts as identical. 
            </p><p>
                <tt class="literal">@Name</tt> is not the only way to define a component name, but we always need
                to specify the name <span class="emphasis"><em>somewhere</em></span>. If we don't, then none of the other
                Seam annotations will function.
            </p><p> 
                Just like in JSF, a seam component instance is usually bound to a context variable with the same name
                as the component name. So, for example, we would access the <tt class="literal">LoginAction</tt> using
                <tt class="literal">Contexts.getStatelessContext().get("loginAction")</tt>. In particular, whenever Seam
                itself instantiates a component, it binds the new instance to a variable with the component name.
                However, again like JSF, it is possible for the application to bind a component to some other context
                variable by programmatic API call. This is only useful if a particular component serves more than one
                role in the system. For example, the currently logged in <tt class="literal">User</tt> might be bound to the
                <tt class="literal">currentUser</tt> session context variable, while a <tt class="literal">User</tt> that is the
                subject of some administration functionality might be bound to the <tt class="literal">user</tt> conversation
                context variable. 
            </p><p> 
                For very large applications, and for built-in seam components, qualified names are often used. 
            </p><pre class="programlisting">@Name("com.jboss.myapp.loginAction")
@Stateless
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                We may use the qualified component name both in Java code and in JSF's expression language: 
            </p><pre class="programlisting">&lt;h:commandButton type="submit" value="Login"
                 action="#{com.jboss.myapp.loginAction.login}"/&gt;</pre><p> 
                Since this is noisy, Seam also provides a means of aliasing a qualified name to a simple name. Add a
                line like this to the <tt class="literal">components.xml</tt> file: 
            </p><pre class="programlisting">&lt;factory name="loginAction" scope="STATELESS" value="#{com.jboss.myapp.loginAction}"/&gt;</pre><p> 
                All of the built-in Seam components have qualified names, but most of them are aliased to a simple
                name by the <tt class="literal">components.xml</tt> file included in the Seam jar. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2907"></a>3.2.8.&nbsp;Defining the component scope</h3></div></div><div></div></div><p> 
                We can override the default scope (context) of a component using the <tt class="literal">@Scope</tt>
                annotation. This lets us define what context a component instance is bound to, when it is instantiated
                by Seam. 
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(SESSION)
public class User { 
    ... 
}</pre><p>
                <tt class="literal">org.jboss.seam.ScopeType</tt> defines an enumeration of possible scopes.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2922"></a>3.2.9.&nbsp;Components with multiple roles</h3></div></div><div></div></div><p> 
                Some Seam component classes can fulfill more than one role in the system. For example, we often have
                a <tt class="literal">User</tt> class which is usually used as a session-scoped component representing the
                current user but is used in user administration screens as a conversation-scoped component. The
                <tt class="literal">@Role</tt> annotation lets us define an additional named role for a component, with a
                different scope&#8212;it lets us bind the same component class to different context variables. (Any
                Seam component <span class="emphasis"><em>instance</em></span> may be bound to multiple context variables, but this lets
                us do it at the class level, and take advantage of auto-instantiation.) 
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(CONVERSATION)
@Role(name="currentUser", scope=SESSION)
public class User { 
    ... 
}</pre><p>
                The <tt class="literal">@Roles</tt> annotation lets us specify as many additional roles as we like.
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(CONVERSATION)
@Roles({@Role(name="currentUser", scope=SESSION),
        @Role(name="tempUser", scope=EVENT)})
public class User { 
    ... 
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2945"></a>3.2.10.&nbsp;Built-in components</h3></div></div><div></div></div><p>
                Like many good frameworks, Seam eats its own dogfood and is implemented mostly as a set of built-in
                Seam interceptors (see later) and Seam components. This makes it easy for applications to interact with
                built-in components at runtime or even customize the basic functionality of Seam by replacing the
                built-in components with custom implementations. The built-in components are defined in the Seam
                namespace <tt class="literal">org.jboss.seam.core</tt> and the Java package of the same name.
            </p><p> 
                The built-in components may be injected, just like any Seam components, but they also provide
                convenient static <tt class="literal">instance()</tt> methods: 
            </p><pre class="programlisting">FacesMessages.instance().add("Welcome back, #{user.name}!");</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2960"></a>3.3.&nbsp;Bijection</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Dependency injection</em></span> or <span class="emphasis"><em>inversion of control</em></span> is by now a familiar
            concept to most Java developers. Dependency injection allows a component to obtain a reference to another
            component by having the container "inject" the other component to a setter method or instance variable. In
            all dependency injection implementations that we have seen, injection occurs when the component is
            constructed, and the reference does not subsequently change for the lifetime of the component instance. For
            stateless components, this is reasonable. From the point of view of a client, all instances of a particular
            stateless component are interchangeable. On the other hand, Seam emphasizes the use of stateful components.
            So traditional dependency injection is no longer a very useful construct. Seam introduces the notion of
            <span class="emphasis"><em>bijection</em></span> as a generalization of injection. In contrast to injection, bijection is: 
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>contextual</em></span> - bijection is used to assemble stateful components from various
                    different contexts (a component from a "wider" context may even have a reference to a component from
                    a "narrower" context)
                </p></li><li><p>
                    <span class="emphasis"><em>bidirectional</em></span> - values are injected from context variables into attributes of
                    the component being invoked, and also <span class="emphasis"><em>outjected</em></span> from the component attributes
                    back out to the context, allowing the component being invoked to manipulate the values of contextual
                    variables simply by setting its own instance variables 
                </p></li><li><p>
                    <span class="emphasis"><em>dynamic</em></span> - since the value of contextual variables changes over time, and since
                    Seam components are stateful, bijection takes place every time a component is invoked 
                </p></li></ul></div><p> 
            In essence, bijection lets you alias a context variable to a component instance variable, by specifying
            that the value of the instance variable is injected, outjected, or both. Of course, we use annotations to
            enable bijection.
        </p><p> 
            The <tt class="literal">@In</tt> annotation specifies that a value should be injected, either into an instance
            variable: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In User user;
    ... 
}</pre><p> 
            or into a setter method: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    ... 
}</pre><p> 
            By default, Seam will do a priority search of all contexts, using the name of the property or instance
            variable that is being injected. You may wish to specify the context variable name explicitly, using, for
            example, <tt class="literal">@In("currentUser")</tt>. 
        </p><p> 
            If you want Seam to create an instance of the component when there is no existing component instance
            bound to the named context variable, you should specify <tt class="literal">@In(create=true)</tt>. If the value is
            optional (it can be null), specify <tt class="literal">@In(required=false)</tt>. 
        </p><p>
            For some components, it can be repetitive to have to specify <tt class="literal">@In(create=true)</tt> everywhere
            they are used. In such cases, you can annotate the component <tt class="literal">@AutoCreate</tt>, and then it
            will always be created, whenever needed, even without the explicit use of <tt class="literal">create=true</tt>.
        </p><p> 
            You can even inject the value of an expression: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In("#{user.username}") String username;
    ... 
}</pre><p>
            Injected values are disinjected (i.e, set to <tt class="literal">null</tt>) immediately after method 
            completion and outjection.
        </p><p> 
            (There is much more information about component lifecycle and injection in the next chapter.) 
        </p><p> 
            The <tt class="literal">@Out</tt> annotation specifies that an attribute should be outjected, either from an
            instance variable: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @Out User user;
    ... 
}</pre><p> 
            or from a getter method: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}</pre><p> 
            An attribute may be both injected and outjected: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In @Out User user;
    ... 
}</pre><p> 
            or: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3063"></a>3.4.&nbsp;Lifecycle methods</h2></div></div><div></div></div><p> 
            Session bean and entity bean Seam components support all the usual EJB 3.0 lifecycle callback
            (<tt class="literal">@PostConstruct</tt>, <tt class="literal">@PreDestroy</tt>, etc). But Seam also supports 
            the use of any of these callbacks with JavaBean components. However, since these annotations are
            not available in a J2EE environment, Seam defines two additional component lifecycle callbacks,
            equivalent to <tt class="literal">@PostConstruct</tt> and <tt class="literal">@PreDestroy</tt>.
        </p><p> 
            The <tt class="literal">@Create</tt> method is called after Seam instantiates a component. 
            Components may define only one <tt class="literal">@Create</tt> method. 
        </p><p> 
            The <tt class="literal">@Destroy</tt> method is called when the context that the Seam component is bound to
            ends. Components may define only one <tt class="literal">@Destroy</tt> method.
        </p><p>
            In addition, stateful session bean components <span class="emphasis"><em>must</em></span> define a method with no parameters 
            annotated <tt class="literal">@Remove</tt>. This method is called by Seam when the context ends.
        </p><p> 
            Finally, a related annotation is the <tt class="literal">@Startup</tt> annotation, which may be applied to any
            application or session scoped component. The <tt class="literal">@Startup</tt> annotation tells Seam to
            instantiate the component immediately, when the context begins, instead of waiting until it is first
            referenced by a client. It is possible to control the order of instantiation of startup components by
            specifying <tt class="literal">@Startup(depends={....})</tt>. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3115"></a>3.5.&nbsp;Conditional installation</h2></div></div><div></div></div><p>
            The <tt class="literal">@Install</tt> annotation lets you control conditional installation of components that
            are required in some deployment scenarios and not in others. This is useful if:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
        		    You want to mock out some infrastructural component in tests.
        		</p></li><li><p>
        		    You want change the implementation of a component in certain
        		    deployment scenarios.
        		</p></li><li><p>
        		    You want to install some components only if their dependencies are
        		    available (useful for framework authors).
        		</p></li></ul></div><p>
            <tt class="literal">@Install</tt> works by letting you specify <span class="emphasis"><em>precedence</em></span>
            and <span class="emphasis"><em>dependencies</em></span>. 
        </p><p>
            The precedence of a component is a number that Seam uses to decide which component to
            install when there are multiple classes with the same component name in the classpath.
            Seam will choose the component with the higher precendence. There are some predefined
            precedence values (in ascending order):
        </p><div class="orderedlist"><ol type="1"><li><p>
        		    <tt class="literal">BUILT_IN</tt> &#8212; the lowest precedece components are
        		    the components built in to Seam. 
        		</p></li><li><p>
        		    <tt class="literal">FRAMEWORK</tt> &#8212; components defined by third-party 
        		    frameworks may override built-in components, but are overridden by
        		    application components. 
        		</p></li><li><p>
        		    <tt class="literal">APPLICATION</tt> &#8212; the default precedence. This is 
                    appropriate for most application components.
        		</p></li><li><p>
        		    <tt class="literal">DEPLOYMENT</tt> &#8212; for application components which
        		    are deployment-specific. 
        		</p></li><li><p>
        		    <tt class="literal">MOCK</tt> &#8212; for mock objects used in testing. 
        		</p></li></ol></div><p>
            Suppose we have a component named <tt class="literal">messageSender</tt> that talks to
            a JMS queue. 
        </p><pre class="programlisting">@Name("messageSender") 
public class MessageSender {
    public void sendMessage() {
        //do something with JMS
    }
}</pre><p>
            In our unit tests, we don't have a JMS queue available, so we would like to stub
            out this method. We'll create a <span class="emphasis"><em>mock</em></span> component that exists
            in the classpath when unit tests are running, but is never deployed with the
            application:
        </p><pre class="programlisting">@Name("messageSender") 
@Install(precedence=MOCK)
public class MockMessageSender extends MessageSender {
    public void sendMessage() {
        //do nothing!
    }
}</pre><p>
            The <tt class="literal">precedence</tt> helps Seam decide which version to use when it finds
            both components in the classpath.
        </p><p>
            This is nice if we are able to control exactly which classes are in the classpath. But
            if I'm writing a reusable framework with many dependecies, I don't want to have to 
            break that framework across many jars. I want to be able to decide which components
            to install depending upon what other components are installed, and upon what classes
            are available in the classpath. The <tt class="literal">@Install</tt> annotation also 
            controls this functionality. Seam uses this mechanism internally to enable conditional 
            installation of many of the built-in components. However, you probably won't need to
            use it in your application.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3201"></a>3.6.&nbsp;Logging</h2></div></div><div></div></div><p> 
            Who is not totally fed up with seeing noisy code like this? 
         </p><pre class="programlisting">private static final Log log = LogFactory.getLog(CreateOrderAction.class);
        
public Order createOrder(User user, Product product, int quantity) {
    if ( log.isDebugEnabled() ) {
        log.debug("Creating new order for user: " + user.username() + 
            " product: " + product.name() 
            + " quantity: " + quantity);
    }
    return new Order(user, product, quantity);
}</pre><p> 
            It is difficult to imagine how the code for a simple log message could possibly be more verbose. There is
            more lines of code tied up in logging than in the actual business logic! I remain totally astonished that
            the Java community has not come up with anything better in 10 years. 
        </p><p> 
            Seam provides a logging API that simplifies this code significantly: 
        </p><pre class="programlisting">@Logger private Log log;
        
public Order createOrder(User user, Product product, int quantity) {
    log.debug("Creating new order for user: #0 product: #1 quantity: #2", user.username(), product.name(), quantity);
    return new Order(user, product, quantity);
}</pre><p>
            It doesn't matter if you declare the <tt class="literal">log</tt> variable static or not&#8212;it will work 
            either way, except for entity bean components which require the <tt class="literal">log</tt> variable to be
            static.
        </p><p> 
            Note that we don't need the noisy <tt class="literal">if ( log.isDebugEnabled() )</tt> guard, since string
            concatenation happens <span class="emphasis"><em>inside</em></span> the <tt class="literal">debug()</tt> method. Note also that we
            don't usually need to specify the log category explicitly, since Seam knows what component it is injecting
            the <tt class="literal">Log</tt> into. 
        </p><p> 
            If <tt class="literal">User</tt> and <tt class="literal">Product</tt> are Seam components available in the current
            contexts, it gets even better: 
        </p><pre class="programlisting">@Logger private Log log;
        
public Order createOrder(User user, Product product, int quantity) {
    log.debug("Creating new order for user: #{user.username} product: #{product.name} quantity: #0", quantity);
    return new Order(user, product, quantity);
}</pre><p>
            Seam logging automagically chooses whether to send output to log4j or JDK logging. If log4j is in the
            classpath, Seam with use it. If it is not, Seam will use JDK logging.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3249"></a>3.7.&nbsp;The <tt class="literal">Mutable</tt> interface and <tt class="literal">@ReadOnly</tt></h2></div></div><div></div></div><p> 
            Many application servers feature an amazingly broken implementation of <tt class="literal">HttpSession</tt>
            clustering, where changes to the state of mutable objects bound to the session are only replicated when the
            application calls <tt class="literal">setAttribute()</tt> explicitly. This is a source of bugs that can not
            effectively be tested for at development time, since they will only manifest when failover occurs.
            Furthermore, the actual replication message contains the entire serialized object graph bound to the session
            attribute, which is inefficient. 
        </p><p> 
            Of course, EJB stateful session beans must perform automatic dirty checking and replication of mutable
            state and a sophisticated EJB container can introduce optimizations such as attribute-level replication.
            Unfortunately, not all Seam users have the good fortune to be working in an environment that supports EJB
            3.0. So, for session and conversation scoped JavaBean and entity bean components, Seam provides an extra
            layer of cluster-safe state management over the top of the web container session clustering. 
        </p><p> 
            For session or conversation scoped JavaBean components, Seam automatically forces replication to occur by
            calling <tt class="literal">setAttribute()</tt> once in every request that the component was invoked by the
            application. Of course, this strategy is inefficient for read-mostly components. You can control this
            behavior by implementing the <tt class="literal">org.jboss.seam.core.Mutable</tt> interface, or by extending
            <tt class="literal">org.jboss.seam.core.AbstractMutable</tt>, and writing your own dirty-checking logic inside
            the component. For example, 
        </p><pre class="programlisting">@Name("account")
public class Account extends AbstractMutable
{
    private BigDecimal balance;
    
    public void setBalance(BigDecimal balance)
    {
        setDirty(this.balance, balance);
        this.balance = balance;
    }
    
    public BigDecimal getBalance()
    {
        return balance;
    }
    
    ...
    
}</pre><p> 
            Or, you can use the <tt class="literal">@ReadOnly</tt> annotation to achieve a similar effect: 
        </p><pre class="programlisting">@Name("account")
public class Account
{
    private BigDecimal balance;
    
    public void setBalance(BigDecimal balance)
    {
        this.balance = balance;
    }
    
    @ReadOnly
    public BigDecimal getBalance()
    {
        return balance;
    }
    
    ...
    
}</pre><p> 
            For session or conversation scoped entity bean components, Seam automatically forces replication to occur
            by calling <tt class="literal">setAttribute()</tt> once in every request, <span class="emphasis"><em>unless the (conversation-scoped) 
            entity is currently associated with a Seam-managed persistence context, in which case no replication is 
            needed</em></span>. This strategy is not necessarily efficient, so session or conversation scope entity beans 
            should be used with care. You can always write a stateful session bean or JavaBean component to "manage" the 
            entity bean instance. For example, 
        </p><pre class="programlisting">@Stateful
@Name("account")
public class AccountManager extends AbstractMutable
{
    private Account account; // an entity bean
    
    @Unwrap
    public void getAccount()
    {
        return account;
    }
    
    ...
    
}</pre><p> 
            Note that the <tt class="literal">EntityHome</tt> class in the Seam Application Framework provides a great example 
            of managing an entity bean instance using a Seam component. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3302"></a>3.8.&nbsp;Factory and manager components</h2></div></div><div></div></div><p> 
            We often need to work with objects that are not Seam components. But we still want to be able to inject
            them into our components using <tt class="literal">@In</tt> and use them in value and method binding expressions,
            etc. Sometimes, we even need to tie them into the Seam context lifecycle (<tt class="literal">@Destroy</tt>, for
            example). So the Seam contexts can contain objects which are not Seam components, and Seam provides a couple
            of nice features that make it easier to work with non-component objects bound to contexts. 
        </p><p> 
            The <span class="emphasis"><em>factory component pattern</em></span> lets a Seam component act as the instantiator for a
            non-component object. A <span class="emphasis"><em>factory method</em></span> will be called when a context variable is
            referenced but has no value bound to it. We define factory methods using the <tt class="literal">@Factory</tt>
            annotation. The factory method binds a value to the context variable, and determines the scope of the bound
            value. There are two styles of factory method. The first style returns a value, which is bound to the
            context by Seam:
        </p><pre class="programlisting">@Factory(scope=CONVERSATION)
public List&lt;Customer&gt; getCustomerList() { 
    return ... ;
} </pre><p> 
            The second style is a method of type <tt class="literal">void</tt> which binds the value to the context
            variable itself: 
        </p><pre class="programlisting">@DataModel List&lt;Customer&gt; customerList;

@Factory("customerList")
public void initCustomerList() { 
    customerList = ...  ;
} </pre><p> 
            In both cases, the factory method is called when we reference the <tt class="literal">customerList</tt> context
            variable and its value is null, and then has no further part to play in the lifecycle of the value. An even
            more powerful pattern is the <span class="emphasis"><em>manager component pattern</em></span>. In this case, we have a Seam
            component that is bound to a context variable, that manages the value of the context variable, while
            remaining invisible to clients. 
        </p><p> 
            A manager component is any component with an <tt class="literal">@Unwrap</tt> method. This method returns the
            value that will be visable to clients, and is called <span class="emphasis"><em>every time</em></span> a context variable is
            referenced. 
        </p><pre class="programlisting">@Name("customerList")
@Scope(CONVERSATION)
public class CustomerListManager
{
    ...
    
    @Unwrap
    public List&lt;Customer&gt; getCustomerList() { 
        return ... ;
    }
}</pre><p> 
            The manager component pattern is especially useful if we have an object where you need more control over the 
            lifecycle of the component.  For example, if you have a heavyweight object that needs a cleanup operation when 
            the context ends you could <tt class="literal">@Unwrap</tt> the object, and perform cleanup in the 
            <tt class="literal">@Destroy</tt> method of the manager component.
        </p><pre class="programlisting">@Name("hens")
@Scope(APPLICATION) 
public class HenHouse {
    
    Set&lt;Hen&gt; hens;
    
    @In(required=false) Hen hen;
    
    @Unwrap
    public List&lt;Hen&gt; getHens() {
        if (hens == null) {
            // Setup our hens
        }
        return hens;
    }
    
    @Observer({"chickBorn", "chickenBoughtAtMarket"})
    public addHen() {
        hens.add(hen);
    }
    
    @Observer("chickenSoldAtMarket")
    public removeHen() {
        hens.remove(hen);
    }
    
    @Observer("foxGetsIn")
    public removeAllHens() {
        hens.clear();
    }
    ...
} </pre><p>
		Here the managed component observes many events which change the underlying object. 
		The component manages these actions itself, and because the object is unwrapped
		on every access, a consistent view is provided.
	</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="gettingstarted.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="xml.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Getting started with Seam, using seam-gen&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Configuring Seam components</td></tr></table></div></body></html>