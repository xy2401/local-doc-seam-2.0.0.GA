<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Seam Tutorial</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Seam - Contextual Components"><link rel="up" href="index.html" title="Seam - Contextual Components"><link rel="previous" href="pr01.html" title="Introduction to JBoss Seam"><link rel="next" href="gettingstarted.html" title="Chapter&nbsp;2.&nbsp;Getting started with Seam, using seam-gen"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;1.&nbsp;Seam Tutorial</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pr01.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="gettingstarted.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial"></a>Chapter&nbsp;1.&nbsp;Seam Tutorial</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="try-examples"></a>1.1.&nbsp;Try the examples</h2></div></div><div></div></div><p> In this tutorial, we'll assume that you have downloaded JBoss AS 4.2.0. You should also have a copy of
            Seam downloaded and extracted to a work directory. </p><p> The directory structure of each example in Seam follows this pattern: </p><div class="itemizedlist"><ul type="disc"><li><p> Web pages, images and stylesheets may be found in
                        <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/view</tt>
                </p></li><li><p> Resources such as deployment descriptors and data import scripts may be found in
                            <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/resources</tt>
                </p></li><li><p> Java source code may be found in
                    <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/src</tt>
                </p></li><li><p> The Ant build script is
                    <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/build.xml</tt>
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e233"></a>1.1.1.&nbsp;Running the examples on JBoss AS</h3></div></div><div></div></div><p> First, make sure you have Ant correctly installed, with <tt class="literal">$ANT_HOME</tt> and
                    <tt class="literal">$JAVA_HOME</tt> set correctly. Next, make sure you set the location of your JBoss AS
                4.2.0 installation in the <tt class="literal">build.properties</tt> file in the root folder of your Seam
                installation. If you haven't already done so, start JBoss AS now by typing <tt class="literal">bin/run.sh</tt>
                or <tt class="literal">bin/run.bat</tt> in the root directory of your JBoss installation. </p><p> Now, build and deploy the example by typing <tt class="literal">ant deploy</tt> in the
                        <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory. </p><p> Try it out by accessing <a href="http://localhost:8080/seam-registration/" target="_top">
                    <tt class="literal">http://localhost:8080/seam-registration/</tt>
                </a> with your web browser. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e271"></a>1.1.2.&nbsp;Running the examples on Tomcat</h3></div></div><div></div></div><p> 
                First, make sure you have Ant correctly installed, with <tt class="literal">$ANT_HOME</tt> and
                <tt class="literal">$JAVA_HOME</tt> set correctly. Next, make sure you set the location of your Tomcat 
                6.0 installation in the <tt class="literal">build.properties</tt> file in the root folder of your Seam
                installation.  You will need to follow the instructions in <a href="configuration.html#config.install.embedded" title="25.5.1.&nbsp;Installing Embedded JBoss">Section&nbsp;25.5.1, &#8220;Installing Embedded JBoss&#8221;</a>
                for installing JBoss Embedded on Tomcat 6.0.  JBoss Embedded is required to run the Seam demo
                applications on Tomcat. (However, it is possible to use Seam on Tomcat without JBoss Embedded.)
            </p><p> 
                Now, build and deploy the example by typing <tt class="literal">ant tomcat.deploy</tt> in the
                <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory.
            </p><p>Finally, start Tomcat.</p><p>
                Try it out by accessing <a href="http://localhost:8080/jboss-seam-registration/" target="_top">
                <tt class="literal">http://localhost:8080/jboss-seam-registration/</tt>
                </a> with your web browser.
            </p><p>
                When you deploy the example to Tomcat, any EJB3 components will run inside the JBoss Embeddable EJB3
                container, a complete standalone EJB3 container environment.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e309"></a>1.1.3.&nbsp;Running the example tests</h3></div></div><div></div></div><p> 
                Most of the examples come with a suite of TestNG integration tests. The easiest way to run the tests
                is to run <tt class="literal">ant testexample</tt> inside the
                <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory. It is also possible
                to run the tests inside your IDE using the TestNG plugin.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="registration-example"></a>1.2.&nbsp;Your first Seam application: the registration example</h2></div></div><div></div></div><p> The registration example is a fairly trivial application that lets a new user store his username, real
            name and password in the database. The example isn't intended to show off all of the cool functionality of
            Seam. However, it demonstrates the use of an EJB3 session bean as a JSF action listener, and basic
            configuration of Seam. </p><p> We'll go slowly, since we realize you might not yet be familiar with EJB 3.0. </p><p> The start page displays a very basic form with three input fields. Try filling them in and then
            submitting the form. This will save a user object in the database. </p><div class="mediaobject" align="center"><img src="../shared/images/registration.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e336"></a>1.2.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The example is implemented with two JSP pages, one entity bean and one stateless session bean. </p><div class="mediaobject" align="center"><img src="../shared/images/register.png" align="middle"></div><p> Let's take a look at the code, starting from the "bottom". </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e348"></a>1.2.1.1.&nbsp;The entity bean: <tt class="literal">User.java</tt></h4></div></div><div></div></div><p> We need an EJB entity bean for user data. This class defines <span class="emphasis"><em>persistence</em></span> and
                        <span class="emphasis"><em>validation</em></span> declaratively, via annotations. It also needs some extra
                    annotations that define the class as a Seam component. </p><div class="example"><a name="d0e361"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Entity                                                                                  <span class="co">(1)</span>
@Name("user")                                                                            <span class="co">(2)</span>
@Scope(SESSION)                                                                          <span class="co">(3)</span>
@Table(name="users")                                                                     <span class="co">(4)</span>
public class User implements Serializable
{
   private static final long serialVersionUID = 1881413500711441951L;
   
   private String username;                                                              <span class="co">(5)</span>
   private String password;
   private String name;
   
   public User(String name, String password, String username)
   {
      this.name = name;
      this.password = password;
      this.username = username;
   }
   
   public User() {}                                                                      <span class="co">(6)</span>
   
   @NotNull @Length(min=5, max=15)                                                       <span class="co">(7)</span>
   public String getPassword()
   {
      return password;
   }

   public void setPassword(String password)
   {
      this.password = password;
   }
   
   @NotNull
   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
   
   @Id @NotNull @Length(min=5, max=15)                                                   <span class="co">(8)</span>
   public String getUsername()
   {
      return username;
   }

   public void setUsername(String username)
   {
      this.username = username;
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB3 standard <tt class="literal">@Entity</tt> annotation indicates that the
                                        <tt class="literal">User</tt> class is an entity bean. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> A Seam component needs a <span class="emphasis"><em>component name</em></span> specified by the
                                        <a href="annotations.html#name-annotation">
                                        <tt class="literal">@Name</tt>
                                    </a> annotation. This name must be unique within the Seam application. When JSF
                                    asks Seam to resolve a context variable with a name that is the same as a Seam
                                    component name, and the context variable is currently undefined (null), Seam will
                                    instantiate that component, and bind the new instance to the context variable. In
                                    this case, Seam will instantiate a <tt class="literal">User</tt> the first time JSF
                                    encounters a variable named <tt class="literal">user</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> Whenever Seam instantiates a component, it binds the new instance to a context
                                    variable in the component's <span class="emphasis"><em>default context</em></span>. The default
                                    context is specified using the <a href="annotations.html#scope-annotation">
                                        <tt class="literal">@Scope</tt>
                                    </a> annotation. The <tt class="literal">User</tt> bean is a session scoped component.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Table</tt> annotation indicates that the
                                        <tt class="literal">User</tt> class is mapped to the <tt class="literal">users</tt> table.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                                    <tt class="literal">name</tt>, <tt class="literal">password</tt> and <tt class="literal">username</tt>
                                    are the persistent attributes of the entity bean. All of our persistent attributes
                                    define accessor methods. These are needed when this component is used by JSF in the
                                    render response and update model values phases. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> An empty constructor is both required by both the EJB specification and by Seam.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">@NotNull</tt> and <tt class="literal">@Length</tt> annotations are
                                    part of the Hibernate Validator framework. Seam integrates Hibernate Validator and
                                    lets you use it for data validation (even if you are not using Hibernate for
                                    persistence). </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Id</tt> annotation indicates the primary key
                                    attribute of the entity bean. </p></td></tr></table></div></div><p> The most important things to notice in this example are the <tt class="literal">@Name</tt> and
                            <tt class="literal">@Scope</tt> annotations. These annotations establish that this class is a Seam
                        component. </p><p> We'll see below that the properties of our <tt class="literal">User</tt> class are bound to
                        directly to JSF components and are populated by JSF during the update model values phase. We
                        don't need any tedious glue code to copy data back and forth between the JSP pages and the
                        entity bean domain model. </p><p> However, entity beans shouldn't do transaction management or database access. So we can't use
                        this component as a JSF action listener. For that we need a session bean. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e474"></a>1.2.1.2.&nbsp;The stateless session bean class: <tt class="literal">RegisterAction.java</tt></h4></div></div><div></div></div><p> Most Seam application use session beans as JSF action listeners (you can use JavaBeans instead if
                    you like). </p><p> We have exactly one JSF action in our application, and one session bean method attached to it. In
                    this case, we'll use a stateless session bean, since all the state associated with our action is
                    held by the <tt class="literal">User</tt> bean. </p><p> This is the only really interesting code in the example! </p><div class="example"><a name="d0e488"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateless                                                                               <span class="co">(1)</span>
@Name("register")
public class RegisterAction implements Register
{

   @In                                                                                   <span class="co">(2)</span>
   private User user;
   
   @PersistenceContext                                                                   <span class="co">(3)</span>
   private EntityManager em;
   
   @Logger                                                                               <span class="co">(4)</span>
   private Log log;
   
   public String register()                                                              <span class="co">(5)</span>
   {
      List existing = em.createQuery(
         "select username from User where username=#{user.username}")                    <span class="co">(6)</span>
         .getResultList();
         
      if (existing.size()==0)
      {
         em.persist(user);
         log.info("Registered new user #{user.username}");                               <span class="co">(7)</span>
         return "/registered.xhtml";                                                     <span class="co">(8)</span>
      }
      else
      {
         FacesMessages.instance().add("User #{user.username} already exists");           <span class="co">(9)</span>
         return null;
      }
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Stateless</tt> annotation marks this class as
                                    stateless session bean. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <a href="annotations.html#in-annotation">
                                        <tt class="literal">@In</tt>
                                    </a> annotation marks an attribute of the bean as injected by Seam. In this case,
                                    the attribute is injected from a context variable named <tt class="literal">user</tt> (the
                                    instance variable name). </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@PersistenceContext</tt> annotation is used to
                                    inject the EJB3 entity manager. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@Logger</tt> annotation is used to inject the component's
                                        <tt class="literal">Log</tt> instance. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The action listener method uses the standard EJB3
                                    <tt class="literal">EntityManager</tt> API to interact with the database, and returns the
                                    JSF outcome. Note that, since this is a sesson bean, a transaction is automatically
                                    begun when the <tt class="literal">register()</tt> method is called, and committed when it
                                    completes. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> Notice that Seam lets you use a JSF EL expression inside EJB-QL. Under the
                                    covers, this results in an ordinary JPA <tt class="literal">setParameter()</tt> call on
                                    the standard JPA <tt class="literal">Query</tt> object. Nice, huh? </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">Log</tt> API lets us easily display templated log messages.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> JSF action listener methods return a string-valued outcome that determines what
                                    page will be displayed next. A null outcome (or a void action listener method)
                                    redisplays the previous page. In plain JSF, it is normal to always use a JSF
                                        <span class="emphasis"><em>navigation rule</em></span> to determine the JSF view id from the
                                    outcome. For complex application this indirection is useful and a good practice.
                                    However, for very simple examples like this one, Seam lets you use the JSF view id
                                    as the outcome, eliminating the requirement for a navigation rule. <span class="emphasis"><em>Note
                                        that when you use a view id as an outcome, Seam always performs a browser
                                        redirect.</em></span>
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p> Seam provides a number of <span class="emphasis"><em>built-in components</em></span> to help solve
                                    common problems. The <tt class="literal">FacesMessages</tt> component makes it easy to
                                    display templated error or success messages. Built-in Seam components may be
                                    obtained by injection, or by calling an <tt class="literal">instance()</tt> method.
                                </p></td></tr></table></div></div><p> Note that we did not explicitly specify a <tt class="literal">@Scope</tt> this time. Each Seam
                        component type has a default scope if not explicitly specified. For stateless session beans, the
                        default scope is the stateless context. Actually, <span class="emphasis"><em>all</em></span> stateless session
                        beans belong in the stateless context. </p><p> Our session bean action listener performs the business and persistence logic for our
                        mini-application. In more complex applications, we might need to layer the code and refactor
                        persistence logic into a dedicated data access component. That's perfectly trivial to do. But
                        notice that Seam does not force you into any particular strategy for application layering. </p><p> Furthermore, notice that our session bean has simultaneous access to context associated with
                        the web request (the form values in the <tt class="literal">User</tt> object, for example), and state
                        held in transactional resources (the <tt class="literal">EntityManager</tt> object). This is a break
                        from traditional J2EE architectures. Again, if you are more comfortable with the traditional
                        J2EE layering, you can certainly implement that in a Seam application. But for many
                        applications, it's simply not very useful. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e599"></a>1.2.1.3.&nbsp;The session bean local interface: <tt class="literal">Register.java</tt></h4></div></div><div></div></div><p>Naturally, our session bean needs a local interface.</p><div class="example"><a name="d0e606"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;</b></p><pre class="programlisting">@Local
public interface Register
{
   public String register();
}</pre></div><p> That's the end of the Java code. Now onto the deployment descriptors. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e611"></a>1.2.1.4.&nbsp;The Seam component deployment descriptor: <tt class="literal">components.xml</tt></h4></div></div><div></div></div><p> If you've used many Java frameworks before, you'll be used to having to declare all your
                    component classes in some kind of XML file that gradually grows more and more unmanageable as your
                    project matures. You'll be relieved to know that Seam does not require that application components
                    be accompanied by XML. Most Seam applications require a very small amount of XML that does not grow
                    very much as the project gets bigger. </p><p> Nevertheless, it is often useful to be able to provide for <span class="emphasis"><em>some</em></span> external
                    configuration of <span class="emphasis"><em>some</em></span> components (particularly the components built in to
                    Seam). You have a couple of options here, but the most flexible option is to provide this
                    configuration in a file called <tt class="literal">components.xml</tt>, located in the
                    <tt class="literal">WEB-INF</tt> directory. We'll use the <tt class="literal">components.xml</tt> file to tell
                    Seam how to find our EJB components in JNDI: </p><div class="example"><a name="d0e635"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/core http://jboss.com/products/seam/core-2.0.xsd 
                 http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd"&gt;
            
     &lt;core:init jndi-pattern="@jndiPattern@"/&gt;
     
&lt;/components&gt;</pre></div><p> This code configures a property named <tt class="literal">jndiPattern</tt> of a built-in Seam component
                    named <tt class="literal">org.jboss.seam.core.init</tt>. The funny <tt class="literal">@</tt> symbols are
                    there because our Ant build script puts the correct JNDI pattern in when we deploy the application.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e649"></a>1.2.1.5.&nbsp;The web deployment description: <tt class="literal">web.xml</tt></h4></div></div><div></div></div><p> The presentation layer for our mini-application will be deployed in a WAR. So we'll need a web
                    deployment descriptor. </p><div class="example"><a name="d0e656"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5"
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;!-- Seam --&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.jboss.seam.servlet.SeamListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- JSF --&gt;
              
    &lt;listener&gt;
        &lt;listener-class&gt;com.sun.faces.config.ConfigureListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    
    &lt;context-param&gt;
        &lt;param-name&gt;javax.faces.DEFAULT_SUFFIX&lt;/param-name&gt;
        &lt;param-value&gt;.xhtml&lt;/param-value&gt;
    &lt;/context-param&gt;
              
    &lt;servlet&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
              
    &lt;session-config&gt;
        &lt;session-timeout&gt;10&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;</pre></div><p> This <tt class="literal">web.xml</tt> file configures Seam and JSF. The configuration you see here is
                    pretty much identical in all Seam applications. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e664"></a>1.2.1.6.&nbsp;The JSF configration: <tt class="literal">faces-config.xml</tt></h4></div></div><div></div></div><p> Most Seam applications use JSF views as the presentation layer. So usually we'll need
                        <tt class="literal">faces-config.xml</tt>. In our case, we are going to use Facelets for
                        defining our views, so we need to tell JSF to use Facelets as its templating engine. </p><div class="example"><a name="registration-faces-config-xml"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;faces-config version="1.2"
              xmlns="http://java.sun.com/xml/ns/javaee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd"&gt;

    &lt;!-- Facelets support --&gt;
    &lt;application&gt;
        &lt;view-handler&gt;com.sun.facelets.FaceletViewHandler&lt;/view-handler&gt;
    &lt;/application&gt;
    
&lt;/faces-config&gt;</pre></div><p> Note that we don't need
                    any JSF managed bean declarations! Our managed beans are annotated Seam components. In Seam applications,
                    the <tt class="literal">faces-config.xml</tt> is used much less often than in plain JSF. </p><p> In fact, once you have all the basic descriptors set up, the <span class="emphasis"><em>only</em></span> XML you
                    need to write as you add new functionality to a Seam application is orchestration: navigation rules 
                    or jBPM process definitions. Seam takes the view that <span class="emphasis"><em>process flow</em></span> and
                        <span class="emphasis"><em>configuration data</em></span> are the only things that truly belong in XML. </p><p> In this simple example, we don't even need a navigation rule, since we decided to embed the view
                    id in our action code. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e695"></a>1.2.1.7.&nbsp;The EJB deployment descriptor: <tt class="literal">ejb-jar.xml</tt></h4></div></div><div></div></div><p> The <tt class="literal">ejb-jar.xml</tt> file integrates Seam with EJB3, by attaching the
                        <tt class="literal">SeamInterceptor</tt> to all session beans in the archive. </p><pre class="programlisting">&lt;ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                             http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd"
         version="3.0"&gt;
         
   &lt;interceptors&gt;
      &lt;interceptor&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor&gt;
   &lt;/interceptors&gt;
   
   &lt;assembly-descriptor&gt;
      &lt;interceptor-binding&gt;
         &lt;ejb-name&gt;*&lt;/ejb-name&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor-binding&gt;
   &lt;/assembly-descriptor&gt;
   
&lt;/ejb-jar&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e710"></a>1.2.1.8.&nbsp;The EJB persistence deployment descriptor: <tt class="literal">persistence.xml</tt></h4></div></div><div></div></div><p> The <tt class="literal">persistence.xml</tt> file tells the EJB persistence provider where to find the
                    datasource, and contains some vendor-specific settings. In this case, enables automatic schema
                    export at startup time. </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" 
             version="1.0"&gt;

   &lt;persistence-unit name="userDatabase"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
    &lt;/persistence-unit&gt;
    
&lt;/persistence&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e722"></a>1.2.1.9.&nbsp;The view: <tt class="literal">register.xhtml</tt> and <tt class="literal">registered.xhtml</tt></h4></div></div><div></div></div><p> The view pages for a Seam application could be implemented using any technology that supports
                    JSF. In this example we use Facelets, because we think it's better than JSP.</p><div class="example"><a name="registration-simpleform"></a><p class="title"><b>Example&nbsp;1.7.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:s="http://jboss.com/products/seam/taglib"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Register New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         &lt;h:form&gt;
            &lt;s:validateAll&gt;
               &lt;h:panelGrid columns="2"&gt;
                  Username: &lt;h:inputText value="#{user.username}" required="true"/&gt;
                  Real Name: &lt;h:inputText value="#{user.name}" required="true"/&gt;
                  Password: &lt;h:inputSecret value="#{user.password}" required="true"/&gt;
               &lt;/h:panelGrid&gt;
            &lt;/s:validateAll&gt;
            &lt;h:messages/&gt;
            &lt;h:commandButton value="Register" action="#{register.register}"/&gt;
         &lt;/h:form&gt;
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;</pre></div><p> The only thing here that is specific to Seam is the
                    <tt class="literal">&lt;s:validateAll&gt;</tt> tag. This JSF component tells JSF to validate all
                    the contained input fields against the Hibernate Validator annotations specified on the entity bean. </p><div class="example"><a name="registration-simplepage"></a><p class="title"><b>Example&nbsp;1.8.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Successfully Registered New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         Welcome, #{user.name}, you are successfully registered as #{user.username}.
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;
</pre></div><p> This is a boring old Facelets page using some embedded EL. There is nothing specific to Seam
                    here. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e745"></a>1.2.1.10.&nbsp;The EAR deployment descriptor: <tt class="literal">application.xml</tt></h4></div></div><div></div></div><p> Finally, since our application is deployed as an EAR, we need a deployment descriptor there, too. </p><div class="example"><a name="registration-application-xml"></a><p class="title"><b>Example&nbsp;1.9.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;application xmlns="http://java.sun.com/xml/ns/javaee" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                                 http://java.sun.com/xml/ns/javaee/application_5.xsd"
             version="5"&gt;
             
    &lt;display-name&gt;Seam Registration&lt;/display-name&gt;

    &lt;module&gt;
        &lt;web&gt;
            &lt;web-uri&gt;jboss-seam-registration.war&lt;/web-uri&gt;
            &lt;context-root&gt;/seam-registration&lt;/context-root&gt;
        &lt;/web&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam-registration.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;java&gt;jboss-el.jar&lt;/java&gt;
    &lt;/module&gt;

&lt;/application&gt;</pre></div><p> This deployment descriptor links modules in the enterprise archive and binds the web application
                    to the context root <tt class="literal">/seam-registration</tt>. </p></div><p> We've now seen <span class="emphasis"><em>all</em></span> the files in the entire application! </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e765"></a>1.2.2.&nbsp;How it works</h3></div></div><div></div></div><p> When the form is submitted, JSF asks Seam to resolve the variable named <tt class="literal">user</tt>.
                Since there is no value already bound to that name (in any Seam context), Seam instantiates the
                    <tt class="literal">user</tt> component, and returns the resulting <tt class="literal">User</tt> entity bean
                instance to JSF after storing it in the Seam session context. </p><p> The form input values are now validated against the Hibernate Validator constraints specified on the
                    <tt class="literal">User</tt> entity. If the constraints are violated, JSF redisplays the page. Otherwise,
                JSF binds the form input values to properties of the <tt class="literal">User</tt> entity bean. </p><p> Next, JSF asks Seam to resolve the variable named <tt class="literal">register</tt>. Seam finds the
                    <tt class="literal">RegisterAction</tt> stateless session bean in the stateless context and returns it.
                JSF invokes the <tt class="literal">register()</tt> action listener method. </p><p> Seam intercepts the method call and injects the <tt class="literal">User</tt> entity from the Seam session
                context, before continuing the invocation. </p><p> The <tt class="literal">register()</tt> method checks if a user with the entered username already exists.
                If so, an error message is queued with the <tt class="literal">FacesMessages</tt> component, and a null
                outcome is returned, causing a page redisplay. The <tt class="literal">FacesMessages</tt> component
                interpolates the JSF expression embedded in the message string and adds a JSF
                <tt class="literal">FacesMessage</tt> to the view. </p><p> If no user with that username exists, the <tt class="literal">"/registered.xhtml"</tt> outcome triggers a
                browser redirect to the <tt class="literal">registered.xhtml</tt> page. When JSF comes to render the page, it
                asks Seam to resolve the variable named <tt class="literal">user</tt> and uses property values of the returned
                    <tt class="literal">User</tt> entity from Seam's session scope. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="messages"></a>1.3.&nbsp;Clickable lists in Seam: the messages example</h2></div></div><div></div></div><p> Clickable lists of database search results are such an important part of any online application that Seam
            provides special functionality on top of JSF to make it easier to query data using EJB-QL or HQL and display
            it as a clickable list using a JSF <tt class="literal">&lt;h:dataTable&gt;</tt>. The messages example
            demonstrates this functionality. </p><div class="mediaobject" align="center"><img src="../shared/images/messages.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e844"></a>1.3.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The message list example has one entity bean, <tt class="literal">Message</tt>, one session bean,
                    <tt class="literal">MessageListBean</tt> and one JSP. </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e855"></a>1.3.1.1.&nbsp;The entity bean: <tt class="literal">Message.java</tt></h4></div></div><div></div></div><p> The <tt class="literal">Message</tt> entity defines the title, text, date and time of a message, and a
                    flag indicating whether the message has been read: </p><div class="example"><a name="d0e865"></a><p class="title"><b>Example&nbsp;1.10.&nbsp;</b></p><pre class="programlisting">@Entity
@Name("message")
@Scope(EVENT)
public class Message implements Serializable
{
   private Long id;
   private String title;
   private String text;
   private boolean read;
   private Date datetime;
   
   @Id @GeneratedValue
   public Long getId() {
      return id;
   }
   public void setId(Long id) {
      this.id = id;
   }
   
   @NotNull @Length(max=100)
   public String getTitle() {
      return title;
   }
   public void setTitle(String title) {
      this.title = title;
   }
   
   @NotNull @Lob
   public String getText() {
      return text;
   }
   public void setText(String text) {
      this.text = text;
   }
   
   @NotNull
   public boolean isRead() {
      return read;
   }
   public void setRead(boolean read) {
      this.read = read;
   }
   
   @NotNull 
   @Basic @Temporal(TemporalType.TIMESTAMP)
   public Date getDatetime() {
      return datetime;
   }
   public void setDatetime(Date datetime) {
      this.datetime = datetime;
   }
   
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e868"></a>1.3.1.2.&nbsp;The stateful session bean: <tt class="literal">MessageManagerBean.java</tt></h4></div></div><div></div></div><p> Just like in the previous example, we have a session bean, <tt class="literal">MessageManagerBean</tt>,
                    which defines the action listener methods for the two buttons on our form. One of the buttons
                    selects a message from the list, and displays that message. The other button deletes a message. So
                    far, this is not so different to the previous example. </p><p> But <tt class="literal">MessageManagerBean</tt> is also responsible for fetching the list of messages
                    the first time we navigate to the message list page. There are various ways the user could navigate
                    to the page, and not all of them are preceded by a JSF action&#8212;the user might have
                    bookmarked the page, for example. So the job of fetching the message list takes place in a Seam
                        <span class="emphasis"><em>factory method</em></span>, instead of in an action listener method. </p><p> We want to cache the list of messages in memory between server requests, so we will make this a
                    stateful session bean. </p><div class="example"><a name="d0e888"></a><p class="title"><b>Example&nbsp;1.11.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful
@Scope(SESSION)
@Name("messageManager")
public class MessageManagerBean implements Serializable, MessageManager
{

   @DataModel                                                                            <span class="co">(1)</span>
   private List&lt;Message&gt; messageList;
   
   @DataModelSelection                                                                   <span class="co">(2)</span>
   @Out(required=false)                                                                  <span class="co">(3)</span>
   private Message message;
   
   @PersistenceContext(type=EXTENDED)                                                    <span class="co">(4)</span>
   private EntityManager em;
   
   @Factory("messageList")                                                               <span class="co">(5)</span>
   public void findMessages()
   {
      messageList = em.createQuery("from Message msg order by msg.datetime desc")
                      .getResultList();
   }
   
   public void select()                                                                  <span class="co">(6)</span>
   {
      message.setRead(true);
   }
   
   public void delete()                                                                  <span class="co">(7)</span>
   {
      messageList.remove(message);
      em.remove(message);
      message=null;
   }
   
   @Remove                                                                               <span class="co">(8)</span>
   public void destroy() {}

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">@DataModel</tt> annotation exposes an attibute of type
                                        <tt class="literal">java.util.List</tt> to the JSF page as an instance of
                                        <tt class="literal">javax.faces.model.DataModel</tt>. This allows us to use the list
                                    in a JSF <tt class="literal">&lt;h:dataTable&gt;</tt> with clickable links for
                                    each row. In this case, the <tt class="literal">DataModel</tt> is made available in a
                                    session context variable named <tt class="literal">messageList</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@DataModelSelection</tt> annotation tells Seam to inject the
                                        <tt class="literal">List</tt> element that corresponded to the clicked link. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <tt class="literal">@Out</tt> annotation then exposes the selected value directly
                                    to the page. So ever time a row of the clickable list is selected, the
                                        <tt class="literal">Message</tt> is injected to the attribute of the stateful bean,
                                    and the subsequently <span class="emphasis"><em>outjected</em></span> to the event context variable
                                    named <tt class="literal">message</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> This stateful bean has an EJB3 <span class="emphasis"><em>extended persistence context</em></span>.
                                    The messages retrieved in the query remain in the managed state as long as the bean
                                    exists, so any subsequent method calls to the stateful bean can update them without
                                    needing to make any explicit call to the <tt class="literal">EntityManager</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The first time we navigate to the JSP page, there will be no value in the
                                        <tt class="literal">messageList</tt> context variable. The <tt class="literal">@Factory</tt>
                                    annotation tells Seam to create an instance of <tt class="literal">MessageManagerBean</tt>
                                    and invoke the <tt class="literal">findMessages()</tt> method to initialize the value. We
                                    call <tt class="literal">findMessages()</tt> a <span class="emphasis"><em>factory method</em></span> for
                                        <tt class="literal">messages</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> The <tt class="literal">select()</tt> action listener method marks the selected
                                        <tt class="literal">Message</tt> as read, and updates it in the database. </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">delete()</tt> action listener method removes the selected
                                        <tt class="literal">Message</tt> from the database. </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> All stateful session bean Seam components <span class="emphasis"><em>must</em></span> have a method
                                    with no parameters marked <tt class="literal">@Remove</tt> that Seam uses to remove 
                                    the stateful bean when the Seam context ends, and clean up any server-side state.
                                </p></td></tr></table></div></div></div><p> Note that this is a session-scoped Seam component. It is associated with the user login session,
                    and all requests from a login session share the same instance of the component. (In Seam
                    applications, we usually use session-scoped components sparingly.) </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1009"></a>1.3.1.3.&nbsp;The session bean local interface: <tt class="literal">MessageManager.java</tt></h4></div></div><div></div></div><p> All session beans have a business interface, of course. </p><pre class="programlisting">@Local
public interface MessageManager
{
   public void findMessages();
   public void select();
   public void delete();
   public void destroy();
}</pre><p> From now on, we won't show local interfaces in our code examples. </p><p> Let's skip over <tt class="literal">components.xml</tt>, <tt class="literal">persistence.xml</tt>,
                        <tt class="literal">web.xml</tt>, <tt class="literal">ejb-jar.xml</tt>, <tt class="literal">faces-config.xml</tt>
                    and <tt class="literal">application.xml</tt> since they are much the same as the previous example, and go
                    straight to the JSP. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1040"></a>1.3.1.4.&nbsp;The view: <tt class="literal">messages.jsp</tt></h4></div></div><div></div></div><p> The JSP page is a straightforward use of the JSF <tt class="literal">&lt;h:dataTable&gt;</tt>
                    component. Again, nothing specific to Seam. </p><div class="example"><a name="d0e1050"></a><p class="title"><b>Example&nbsp;1.12.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Messages&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;f:view&gt;
   &lt;h:form&gt;
     &lt;h2&gt;Message List&lt;/h2&gt;
     &lt;h:outputText value="No messages to display" 
                   rendered="#{messageList.rowCount==0}"/&gt;
     &lt;h:dataTable var="msg" value="#{messageList}" 
                  rendered="#{messageList.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Read"/&gt;
           &lt;/f:facet&gt;
           &lt;h:selectBooleanCheckbox value="#{msg.read}" disabled="true"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Title"/&gt;
           &lt;/f:facet&gt;
           &lt;h:commandLink value="#{msg.title}" action="#{messageManager.select}"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Date/Time"/&gt;
           &lt;/f:facet&gt;
           &lt;h:outputText value="#{msg.datetime}"&gt;
              &lt;f:convertDateTime type="both" dateStyle="medium" timeStyle="short"/&gt;
           &lt;/h:outputText&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;h:commandButton value="Delete" action="#{messageManager.delete}"/&gt;
        &lt;/h:column&gt;
     &lt;/h:dataTable&gt;
     &lt;h3&gt;&lt;h:outputText value="#{message.title}"/&gt;&lt;/h3&gt;
     &lt;div&gt;&lt;h:outputText value="#{message.text}"/&gt;&lt;/div&gt;
   &lt;/h:form&gt;
  &lt;/f:view&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1053"></a>1.3.2.&nbsp;How it works</h3></div></div><div></div></div><p> The first time we navigate to the <tt class="literal">messages.jsp</tt> page, whether by a JSF postback
                (faces request) or a direct browser GET request (non-faces request), the page will try to resolve the
                    <tt class="literal">messageList</tt> context variable. Since this context variable is not initialized,
                Seam will call the factory method <tt class="literal">findMessages()</tt>, which performs a query against the
                database and results in a <tt class="literal">DataModel</tt> being outjected. This
                <tt class="literal">DataModel</tt> provides the row data needed for rendering the
                    <tt class="literal">&lt;h:dataTable&gt;</tt>. </p><p> When the user clicks the <tt class="literal">&lt;h:commandLink&gt;</tt>, JSF calls the
                    <tt class="literal">select()</tt> action listener. Seam intercepts this call and injects the selected row
                data into the <tt class="literal">message</tt> attribute of the <tt class="literal">messageManager</tt> component.
                The action listener fires, marking the selected <tt class="literal">Message</tt> as read. At the end of the
                call, Seam outjects the selected <tt class="literal">Message</tt> to the context variable named
                    <tt class="literal">message</tt>. Next, the EJB container commits the transaction, and the change to the
                    <tt class="literal">Message</tt> is flushed to the database. Finally, the page is re-rendered,
                redisplaying the message list, and displaying the selected message below it. </p><p> If the user clicks the <tt class="literal">&lt;h:commandButton&gt;</tt>, JSF calls the
                    <tt class="literal">delete()</tt> action listener. Seam intercepts this call and injects the selected row
                data into the <tt class="literal">message</tt> attribute of the <tt class="literal">messageList</tt> component. The
                action listener fires, removing the selected <tt class="literal">Message</tt> from the list, and also calling
                    <tt class="literal">remove()</tt> on the <tt class="literal">EntityManager</tt>. At the end of the call, Seam
                refreshes the <tt class="literal">messageList</tt> context variable and clears the context variable named
                    <tt class="literal">message</tt>. The EJB container commits the transaction, and deletes the
                    <tt class="literal">Message</tt> from the database. Finally, the page is re-rendered, redisplaying the
                message list. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="todo"></a>1.4.&nbsp;Seam and jBPM: the todo list example</h2></div></div><div></div></div><p> jBPM provides sophisticated functionality for workflow and task management. To get a small taste of how
            jBPM integrates with Seam, we'll show you a simple "todo list" application. Since managing lists of tasks is
            such core functionality for jBPM, there is hardly any Java code at all in this example. </p><div class="mediaobject" align="center"><img src="../shared/images/todo.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1144"></a>1.4.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The center of this example is the jBPM process definition. There are also two JSPs and two trivial
                JavaBeans (There was no reason to use session beans, since they do not access the database, or have any
                other transactional behavior). Let's start with the process definition: </p><div class="example"><a name="d0e1149"></a><p class="title"><b>Example&nbsp;1.13.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;process-definition name="todo"&gt;
   
   &lt;start-state name="start"&gt;                                                            <span class="co">(1)</span>
      &lt;transition to="todo"/&gt;
   &lt;/start-state&gt;
   
   &lt;task-node name="todo"&gt;                                                               <span class="co">(2)</span>
      &lt;task name="todo" description="#{todoList.description}"&gt;                           <span class="co">(3)</span>
         &lt;assignment actor-id="#{actor.id}"/&gt;                                            <span class="co">(4)</span>
      &lt;/task&gt;
      &lt;transition to="done"/&gt;
   &lt;/task-node&gt;
   
   &lt;end-state name="done"/&gt;                                                              <span class="co">(5)</span>
   
&lt;/process-definition&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;start-state&gt;</tt> node represents the logical start
                                of the process. When the process starts, it immediately transitions to the
                                <tt class="literal">todo</tt> node. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;task-node&gt;</tt> node represents a <span class="emphasis"><em>wait
                                    state</em></span>, where business process execution pauses, waiting for one or more
                                tasks to be performed. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;task&gt;</tt> element defines a task to be performed by
                                a user. Since there is only one task defined on this node, when it is complete,
                                execution resumes, and we transition to the end state. The task gets its description
                                from a Seam component named <tt class="literal">todoList</tt> (one of the JavaBeans). </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> Tasks need to be assigned to a user or group of users when they are created. In this
                                case, the task is assigned to the current user, which we get from a built-in Seam
                                component named <tt class="literal">actor</tt>. Any Seam component may be used to perform task
                                assignment. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;end-state&gt;</tt> node defines the logical end of the
                                business process. When execution reaches this node, the process instance is destroyed.
                            </p></td></tr></table></div></div></div><p> If we view this process definition using the process definition editor provided by JBossIDE, this is
                what it looks like: </p><div class="mediaobject" align="center"><img src="../shared/images/todo-process.png" align="middle"></div><p> This document defines our <span class="emphasis"><em>business process</em></span> as a graph of nodes. This is the most
                trivial possible business process: there is one <span class="emphasis"><em>task</em></span> to be performed, and when that
                task is complete, the business process ends. </p><p> The first JavaBean handles the login screen <tt class="literal">login.jsp</tt>. Its job is just to
                initialize the jBPM actor id using the <tt class="literal">actor</tt> component. (In a real application, it
                would also need to authenticate the user.) </p><div class="example"><a name="d0e1222"></a><p class="title"><b>Example&nbsp;1.14.&nbsp;</b></p><pre class="programlisting">@Name("login")
public class Login {
   
   @In
   private Actor actor;
   
   private String user;

   public String getUser() {
      return user;
   }

   public void setUser(String user) {
      this.user = user;
   }
   
   public String login()
   {
      actor.setId(user);
      return "/todo.jsp";
   }
}</pre></div><p> Here we see the use of <tt class="literal">@In</tt> to inject the built-in <tt class="literal">Actor</tt>
                component. </p><p> The JSP itself is trivial: </p><div class="example"><a name="d0e1235"></a><p class="title"><b>Example&nbsp;1.15.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h"%&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;f:view&gt;
    &lt;h:form&gt;
      &lt;div&gt;
        &lt;h:inputText value="#{login.user}"/&gt;
        &lt;h:commandButton value="Login" action="#{login.login}"/&gt;
      &lt;/div&gt;
    &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p> The second JavaBean is responsible for starting business process instances, and ending tasks. </p><div class="example"><a name="d0e1240"></a><p class="title"><b>Example&nbsp;1.16.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("todoList")
public class TodoList {
   
   private String description;
   
   public String getDescription()                                                        <span class="co">(1)</span>
   {
      return description;
   }

   public void setDescription(String description) {
      this.description = description;
   }
   
   @CreateProcess(definition="todo")                                                     <span class="co">(2)</span>
   public void createTodo() {}
   
   @StartTask @EndTask                                                                   <span class="co">(3)</span>
   public void done() {}

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The description property accepts user input form the JSP page, and exposes it to the
                                process definition, allowing the task description to be set. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@CreateProcess</tt> annotation creates a new jBPM process
                                instance for the named process definition. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@StartTask</tt> annotation starts work on a task. The
                                    <tt class="literal">@EndTask</tt> ends the task, and allows the business process execution
                                to resume. </p></td></tr></table></div></div></div><p> In a more realistic example, <tt class="literal">@StartTask</tt> and <tt class="literal">@EndTask</tt> would not
                appear on the same method, because there is usually work to be done using the application in order to
                complete the task. </p><p> Finally, the meat of the application is in <tt class="literal">todo.jsp</tt>: </p><div class="example"><a name="d0e1280"></a><p class="title"><b>Example&nbsp;1.17.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;%@ taglib uri="http://jboss.com/products/seam/taglib" prefix="s" %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Todo List&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Todo List&lt;/h1&gt;
&lt;f:view&gt;
   &lt;h:form id="list"&gt;
      &lt;div&gt;
         &lt;h:outputText value="There are no todo items." 
                       rendered="#{empty taskInstanceList}"/&gt;
         &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                      rendered="#{not empty taskInstanceList}"&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Description"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.description}"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Created"/&gt;
                &lt;/f:facet&gt;
                &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
                    &lt;f:convertDateTime type="date"/&gt;
                &lt;/h:outputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Priority"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Due Date"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
                    &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
                &lt;/h:inputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
            &lt;/h:column&gt;
         &lt;/h:dataTable&gt;
      &lt;/div&gt;
      &lt;div&gt;
      &lt;h:messages/&gt;
      &lt;/div&gt;
      &lt;div&gt;
         &lt;h:commandButton value="Update Items" action="update"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
   &lt;h:form id="new"&gt;
      &lt;div&gt;
         &lt;h:inputText value="#{todoList.description}"/&gt;
         &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p> Let's take this one piece at a time. </p><p> The page renders a list of tasks, which it gets from a built-in Seam component named
                    <tt class="literal">taskInstanceList</tt>. The list is defined inside a JSF form. </p><pre class="programlisting">&lt;h:form id="list"&gt;
   &lt;div&gt;
      &lt;h:outputText value="There are no todo items." rendered="#{empty taskInstanceList}"/&gt;
      &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                   rendered="#{not empty taskInstanceList}"&gt;
         ...
      &lt;/h:dataTable&gt;
   &lt;/div&gt;
&lt;/h:form&gt;</pre><p> Each element of the list is an instance of the jBPM class <tt class="literal">TaskInstance</tt>. The
                following code simply displays the interesting properties of each task in the list. For the description,
                priority and due date, we use input controls, to allow the user to update these values. </p><pre class="programlisting">&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
       &lt;h:outputText value="Description"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.description}"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Created"/&gt;
    &lt;/f:facet&gt;
    &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
        &lt;f:convertDateTime type="date"/&gt;
    &lt;/h:outputText&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Priority"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Due Date"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
        &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
    &lt;/h:inputText&gt;
&lt;/h:column&gt;</pre><p> This button ends the task by calling the action method annotated <tt class="literal">@StartTask
                @EndTask</tt>. It passes the task id to Seam as a request parameter: </p><pre class="programlisting">&lt;h:column&gt;
    &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
&lt;/h:column&gt;</pre><p> (Note that this is using a Seam <tt class="literal">&lt;s:button&gt;</tt> JSF control from the
                    <tt class="literal">seam-ui.jar</tt> package.) </p><p> This button is used to update the properties of the tasks. When the form is submitted, Seam and jBPM
                will make any changes to the tasks persistent. There is no need for any action listener method: </p><pre class="programlisting">&lt;h:commandButton value="Update Items" action="update"/&gt;</pre><p> A second form on the page is used to create new items, by calling the action method annotated
                    <tt class="literal">@CreateProcess</tt>. </p><pre class="programlisting">&lt;h:form id="new"&gt;
    &lt;div&gt;
        &lt;h:inputText value="#{todoList.description}"/&gt;
        &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;</pre><p> There are several other files needed for the example, but they are just standard jBPM and Seam
                configuration and not very interesting. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1327"></a>1.4.2.&nbsp;How it works</h3></div></div><div></div></div><p>TODO</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="numberguess"></a>1.5.&nbsp;Seam pageflow: the numberguess example</h2></div></div><div></div></div><p> For Seam applications with relatively freeform (ad hoc) navigation, JSF/Seam navigation rules are a
            perfectly good way to define the page flow. For applications with a more constrained style of navigation,
            especially for user interfaces which are more stateful, navigation rules make it difficult to really
            understand the flow of the system. To understand the flow, you need to piece it together from the view
            pages, the actions and the navigation rules. </p><p> Seam allows you to use a jPDL process definition to define pageflow. The simple number guessing example
            shows how this is done. </p><div class="mediaobject" align="center"><img src="../shared/images/numberguess.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1344"></a>1.5.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The example is implemented using one JavaBean, three JSP pages and a jPDL pageflow definition. Let's
                begin with the pageflow: </p><div class="example"><a name="d0e1349"></a><p class="title"><b>Example&nbsp;1.18.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;pageflow-definition 
        xmlns="http://jboss.com/products/seam/pageflow"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.com/products/seam/pageflow 
                            http://jboss.com/products/seam/pageflow-2.0.xsd"
        name="numberGuess"&gt;
   
   &lt;start-page name="displayGuess" view-id="/numberGuess.jspx"&gt;                          <span class="co">(1)</span>
      &lt;redirect/&gt;
      &lt;transition name="guess" to="evaluateGuess"&gt;                                       <span class="co">(2)</span>
         &lt;action expression="#{numberGuess.guess}"/&gt;                                     <span class="co">(3)</span>
      &lt;/transition&gt;
      &lt;transition name="giveup" to="giveup"/&gt;
   &lt;/start-page&gt;
   
   &lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;              <span class="co">(4)</span>
      &lt;transition name="true" to="win"/&gt;
      &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
   &lt;/decision&gt;
   
   &lt;decision name="evaluateRemainingGuesses" expression="#{numberGuess.lastGuess}"&gt;
      &lt;transition name="true" to="lose"/&gt;
      &lt;transition name="false" to="displayGuess"/&gt;
   &lt;/decision&gt;
   
   &lt;page name="giveup" view-id="/giveup.jspx"&gt;
      &lt;redirect/&gt;
      &lt;transition name="yes" to="lose"/&gt;
      &lt;transition name="no" to="displayGuess"/&gt;
   &lt;/page&gt;
   
   &lt;page name="win" view-id="/win.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
   &lt;page name="lose" view-id="/lose.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;page&gt;</tt> element defines a wait state where the
                                system displays a particular JSF view and waits for user input. The
                                <tt class="literal">view-id</tt> is the same JSF view id used in plain JSF navigation rules.
                                The <tt class="literal">redirect</tt> attribute tells Seam to use post-then-redirect when
                                navigating to the page. (This results in friendly browser URLs.) </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;transition&gt;</tt> element names a JSF outcome. The
                                transition is triggered when a JSF action results in that outcome. Execution will then
                                proceed to the next node of the pageflow graph, after invocation of any jBPM transition
                                actions. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> A transition <tt class="literal">&lt;action&gt;</tt> is just like a JSF action,
                                except that it occurs when a jBPM transition occurs. The transition action can invoke
                                any Seam component. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> A <tt class="literal">&lt;decision&gt;</tt> node branches the pageflow, and
                                determines the next node to execute by evaluating a JSF EL expression. </p></td></tr></table></div></div></div><p> Here is what the pageflow looks like in the JBossIDE pageflow editor: </p><div class="mediaobject" align="center"><img src="../shared/images/numberguess-pageflow.png" align="middle"></div><p> Now that we have seen the pageflow, it is very, very easy to understand the rest of the application! </p><p> Here is the main page of the application, <tt class="literal">numberGuess.jspx</tt>: </p><div class="example"><a name="d0e1403"></a><p class="title"><b>Example&nbsp;1.19.&nbsp;</b></p><pre class="programlisting">&lt;&lt;?xml version="1.0"?&gt;
&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns:s="http://jboss.com/products/seam/taglib"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html" 
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Guess a number...&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
    &lt;script language="javascript" type="text/javascript" src="niceforms.js" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Guess a number...&lt;/h1&gt;
    &lt;f:view&gt;
	  &lt;h:form styleClass="niceform"&gt;
	    
	    &lt;div&gt;
	    &lt;h:messages globalOnly="true"/&gt;
	    &lt;h:outputText value="Higher!" 
	           rendered="#{numberGuess.randomNumber gt numberGuess.currentGuess}"/&gt;
	    &lt;h:outputText value="Lower!" 
	           rendered="#{numberGuess.randomNumber lt numberGuess.currentGuess}"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        I'm thinking of a number between 
        &lt;h:outputText value="#{numberGuess.smallest}"/&gt; and 
        &lt;h:outputText value="#{numberGuess.biggest}"/&gt;. You have 
        &lt;h:outputText value="#{numberGuess.remainingGuesses}"/&gt; guesses.
        &lt;/div&gt;
        
        &lt;div&gt;
        Your guess: 
        &lt;h:inputText value="#{numberGuess.currentGuess}" id="inputGuess" 
                     required="true" size="3" 
                     rendered="#{(numberGuess.biggest-numberGuess.smallest) gt 20}"&gt;
          &lt;f:validateLongRange maximum="#{numberGuess.biggest}" 
                               minimum="#{numberGuess.smallest}"/&gt;
        &lt;/h:inputText&gt;
        &lt;h:selectOneMenu value="#{numberGuess.currentGuess}" 
                         id="selectGuessMenu" required="true"
                         rendered="#{(numberGuess.biggest-numberGuess.smallest) le 20 and 
                                     (numberGuess.biggest-numberGuess.smallest) gt 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneMenu&gt;
        &lt;h:selectOneRadio value="#{numberGuess.currentGuess}" id="selectGuessRadio" 
                          required="true"
                          rendered="#{(numberGuess.biggest-numberGuess.smallest) le 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneRadio&gt;
		&lt;h:commandButton value="Guess" action="guess"/&gt;
        &lt;s:button value="Cheat" view="/confirm.jspx"/&gt;
        &lt;s:button value="Give up" action="giveup"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        &lt;h:message for="inputGuess" style="color: red"/&gt;
        &lt;/div&gt;
        
	  &lt;/h:form&gt;
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;</pre></div><p> Notice how the command button names the <tt class="literal">guess</tt> transition instead of calling an
                action directly. </p><p> The <tt class="literal">win.jspx</tt> page is predictable: </p><div class="example"><a name="d0e1416"></a><p class="title"><b>Example&nbsp;1.20.&nbsp;</b></p><pre class="programlisting">&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html"
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;You won!&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;You won!&lt;/h1&gt;
    &lt;f:view&gt;
      Yes, the answer was &lt;h:outputText value="#{numberGuess.currentGuess}" /&gt;.
      It took you &lt;h:outputText value="#{numberGuess.guessCount}" /&gt; guesses.
      &lt;h:outputText value="But you cheated, so it doesn't count!" 
                    rendered="#{numberGuess.cheat}"/&gt;
      Would you like to &lt;a href="numberGuess.seam"&gt;play again&lt;/a&gt;?
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;
</pre></div><p> As is <tt class="literal">lose.jspx</tt> (which I can't be bothered copy/pasting). Finally, the JavaBean
                Seam component: </p><div class="example"><a name="d0e1424"></a><p class="title"><b>Example&nbsp;1.21.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("numberGuess")
@Scope(ScopeType.CONVERSATION)
public class NumberGuess implements Serializable {
   
   private int randomNumber;
   private Integer currentGuess;
   private int biggest;
   private int smallest;
   private int guessCount;
   private int maxGuesses;
   private boolean cheated;
   
   @Create                                                                               <span class="co">(1)</span>
   public void begin()
   {
      randomNumber = new Random().nextInt(100);
      guessCount = 0;
      biggest = 100;
      smallest = 1;
   }
   
   public void setCurrentGuess(Integer guess)
   {
      this.currentGuess = guess;
   }
   
   public Integer getCurrentGuess()
   {
      return currentGuess;
   }
   
   public void guess()
   {
      if (currentGuess&gt;randomNumber)
      {
         biggest = currentGuess - 1;
      }
      if (currentGuess&lt;randomNumber)
      {
         smallest = currentGuess + 1;
      }
      guessCount ++;
   }
   
   public boolean isCorrectGuess()
   {
      return currentGuess==randomNumber;
   }
   
   public int getBiggest()
   {
      return biggest;
   }
   
   public int getSmallest()
   {
      return smallest;
   }
   
   public int getGuessCount()
   {
      return guessCount;
   }
   
   public boolean isLastGuess()
   {
      return guessCount==maxGuesses;
   }

   public int getRemainingGuesses() {
      return maxGuesses-guessCount;
   }

   public void setMaxGuesses(int maxGuesses) {
      this.maxGuesses = maxGuesses;
   }

   public int getMaxGuesses() {
      return maxGuesses;
   }

   public int getRandomNumber() {
      return randomNumber;
   }

   public void cheated()
   {
      cheated = true;
   }
   
   public boolean isCheat() {
      return cheated;
   }
   
   public List&lt;Integer&gt; getPossibilities()
   {
      List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
      for(int i=smallest; i&lt;=biggest; i++) result.add(i);
      return result;
   }
   
}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The first time a JSP page asks for a <tt class="literal">numberGuess</tt> component, Seam
                                will create a new one for it, and the <tt class="literal">@Create</tt> method will be invoked,
                                allowing the component to initialize itself. </p></td></tr></table></div></div></div><p>The <tt class="literal">pages.xml</tt> file starts a Seam
                <span class="emphasis"><em>conversation</em></span> (much more about that later), and specifies the
                pageflow definition to use for the conversation's page flow. 
            </p><div class="example"><a name="d0e1448"></a><p class="title"><b>Example&nbsp;1.22.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;pages xmlns="http://jboss.com/products/seam/pages"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://jboss.com/products/seam/pages http://jboss.com/products/seam/pages-2.0.xsd"&gt;

  &lt;page view-id="/numberGuess.jspx"&gt;
    &lt;begin-conversation join="true" pageflow="numberGuess"/&gt;
  &lt;/page&gt;

  &lt;page view-id="/confirm.jspx"&gt;
    &lt;begin-conversation nested="true" pageflow="cheat"/&gt;
  &lt;/page&gt;

&lt;/pages&gt;      
</pre></div><p> As you can see, this Seam component is pure business logic! It doesn't need to know anything at all
                about the user interaction flow. This makes the component potentially more reuseable. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1453"></a>1.5.2.&nbsp;How it works</h3></div></div><div></div></div><p>TODO</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="booking"></a>1.6.&nbsp;A complete Seam application: the Hotel Booking example</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1461"></a>1.6.1.&nbsp;Introduction</h3></div></div><div></div></div><p> The booking application is a complete hotel room reservation system incorporating the following
                features: </p><div class="itemizedlist"><ul type="disc"><li><p>User registration</p></li><li><p>Login</p></li><li><p>Logout</p></li><li><p>Set password</p></li><li><p>Hotel search</p></li><li><p>Hotel selection</p></li><li><p>Room reservation</p></li><li><p>Reservation confirmation</p></li><li><p>Existing reservation list</p></li></ul></div><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/booking.png" align="middle"></div></div><p> The booking application uses JSF, EJB 3.0 and Seam, together with Facelets for the view. There is
                also a port of this application to JSF, Facelets, Seam, JavaBeans and Hibernate3. </p><p> One of the things you'll notice if you play with this application for long enough is that it is
                extremely <span class="emphasis"><em>robust</em></span>. You can play with back buttons and browser refresh and opening
                multiple windows and entering nonsensical data as much as you like and you will find it very difficult
                to make the application crash. You might think that we spent weeks testing and fixing bugs to achive
                this. Actually, this is not the case. Seam was designed to make it very straightforward to build robust
                web applications and a lot of robustness that you are probably used to having to code yourself comes
                naturally and automatically with Seam. </p><p> As you browse the sourcecode of the example application, and learn how the application works, observe
                how the declarative state management and integrated validation has been used to achieve this robustness. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1511"></a>1.6.2.&nbsp;Overview of the booking example</h3></div></div><div></div></div><p> The project structure is identical to the previous one, to install and deploy this application,
                please refer to <a href="tutorial.html#try-examples" title="1.1.&nbsp;Try the examples">Section&nbsp;1.1, &#8220;Try the examples&#8221;</a>. Once you've successfully started the application, you
                can access it by pointing your browser to <a href="http://localhost:8080/seam-booking/" target="_top">
                    <tt class="literal">http://localhost:8080/seam-booking/</tt>
                </a>
            </p><p> Just nine classes (plus six session beans local interfaces) where used to implement this application.
                Six session bean action listeners contain all the business logic for the listed features. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">BookingListAction</tt> retrieves existing bookings for the currently logged in user. </p></li><li><p><tt class="literal">ChangePasswordAction</tt> updates the password of the currently logged in user.</p></li><li><p><tt class="literal">HotelBookingAction</tt> implements the core functionality of the application: hotel
                    room searching, selection, booking and booking confirmation. This functionality is implemented as a
                        <span class="emphasis"><em>conversation</em></span>, so this is the most interesting class in the application. </p></li><li><p><tt class="literal">RegisterAction</tt> registers a new system user.</p></li></ul></div><p> Three entity beans implement the application's persistent domain model. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Hotel</tt> is an entity bean that represent a hotel </p></li><li><p><tt class="literal">Booking</tt> is an entity bean that represents an existing booking </p></li><li><p><tt class="literal">User</tt> is an entity bean to represents a user who can make hotel bookings</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1568"></a>1.6.3.&nbsp;Understanding Seam conversations</h3></div></div><div></div></div><p> We encourage you browse the sourcecode at your pleasure. In this tutorial we'll concentrate upon one
                particular piece of functionality: hotel search, selection, booking and confirmation. From the point of
                view of the user, everything from selecting a hotel to confirming a booking is one continuous unit of
                work, a <span class="emphasis"><em>conversation</em></span>. Searching, however, is <span class="emphasis"><em>not</em></span> part of the
                conversation. The user can select multiple hotels from the same search results page, in different
                browser tabs. </p><p> Most web application architectures have no first class construct to represent a conversation. This
                causes enormous problems managing state associated with the conversation. Usually, Java web applications
                use a combination of two techniques: first, some state is thrown into the
                <tt class="literal">HttpSession</tt>; second, persistable state is flushed to the database after every
                request, and reconstructed from the database at the beginning of each new request. </p><p> Since the database is the least scalable tier, this often results in an utterly unacceptable lack of
                scalability. Added latency is also a problem, due to the extra traffic to and from the database on every
                request. To reduce this redundant traffic, Java applications often introduce a data (second-level) cache
                that keeps commonly accessed data between requests. This cache is necessarily inefficient, because
                invalidation is based upon an LRU policy instead of being based upon when the user has finished working
                with the data. Furthermore, because the cache is shared between many concurrent transactions, we've
                introduced a whole raft of problem's associated with keeping the cached state consistent with the
                database. </p><p> Now consider the state held in the <tt class="literal">HttpSession</tt>. By very careful programming, we
                might be able to control the size of the session data. This is a lot more difficult than it sounds,
                since web browsers permit ad hoc non-linear navigation. But suppose we suddenly discover a system
                requirement that says that a user is allowed to have <span class="emphasis"><em>mutiple concurrent
                conversations</em></span>, halfway through the development of the system (this has happened to me).
                Developing mechanisms to isolate session state associated with different concurrent conversations, and
                incorporating failsafes to ensure that conversation state is destroyed when the user aborts one of the
                conversations by closing a browser window or tab is not for the faint hearted (I've implemented this
                stuff twice so far, once for a client application, once for Seam, but I'm famously psychotic). </p><p> Now there is a better way. </p><p> Seam introduces the <span class="emphasis"><em>conversation context</em></span> as a first class construct. You can
                safely keep conversational state in this context, and be assured that it will have a well-defined
                lifecycle. Even better, you won't need to be continually pushing data back and forth between the
                application server and the database, since the conversation context is a natural cache of data that the
                user is currently working with. </p><p> Usually, the components we keep in the conversation context are stateful session beans. (We can also
                keep entity beans and JavaBeans in the conversation context.) There is an ancient canard in the Java
                community that stateful session beans are a scalability killer. This may have been true in 1998 when
                WebFoobar 1.0 was released. It is no longer true today. Application servers like JBoss AS have extremely
                sophisticated mechanisms for stateful session bean state replication. (For example, the JBoss EJB3
                container performs fine-grained replication, replicating only those bean attribute values which actually
                changed.) Note that all the traditional technical arguments for why stateful beans are inefficient apply
                equally to the <tt class="literal">HttpSession</tt>, so the practice of shifting state from business tier
                stateful session bean components to the web session to try and improve performance is unbelievably
                misguided. It is certainly possible to write unscalable applications using stateful session beans, by
                using stateful beans incorrectly, or by using them for the wrong thing. But that doesn't mean you should
                    <span class="emphasis"><em>never</em></span> use them. Anyway, Seam guides you toward a safe usage model. Welcome to
                2005. </p><p> OK, I'll stop ranting now, and get back to the tutorial. </p><p> The booking example application shows how stateful components with different scopes can collaborate
                together to achieve complex behaviors. The main page of the booking application allows the user to
                search for hotels. The search results are kept in the Seam session scope. When the user navigates to one
                of these hotels, a conversation begins, and a conversation scoped component calls back to the session
                scoped component to retrieve the selected hotel. </p><p> The booking example also demonstrates the use of RichFaces Ajax to implement rich client behavior without
                the use of handwritten JavaScript. </p><p> The search functionality is implemented using a session-scope stateful session bean, similar to the
                one we saw in the message list example above. </p><div class="example"><a name="d0e1617"></a><p class="title"><b>Example&nbsp;1.23.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful                                                                                <span class="co">(1)</span>
@Name("hotelSearch")
@Scope(ScopeType.SESSION)
@Restrict("#{identity.loggedIn}")                                                        <span class="co">(2)</span>
public class HotelSearchingAction implements HotelSearching
{
   
   @PersistenceContext
   private EntityManager em;
   
   private String searchString;
   private int pageSize = 10;
   private int page;
   
   @DataModel                                                                            <span class="co">(3)</span>
   private List&lt;Hotel&gt; hotels;
   
   public void find()
   {
      page = 0;
      queryHotels();
   }
   public void nextPage()
   {
      page++;
      queryHotels();
   }
      
   private void queryHotels()
   {
      hotels = 
          em.createQuery("select h from Hotel h where lower(h.name) like #{pattern} " + 
                         "or lower(h.city) like #{pattern} " + 
                         "or lower(h.zip) like #{pattern} " +
                         "or lower(h.address) like #{pattern}")
            .setMaxResults(pageSize)
            .setFirstResult( page * pageSize )
            .getResultList();
   }
   
   public boolean isNextPageAvailable()
   {
      return hotels!=null &amp;&amp; hotels.size()==pageSize;
   }
   
   public int getPageSize() {
      return pageSize;
   }
   
   public void setPageSize(int pageSize) {
      this.pageSize = pageSize;
   }
   
   @Factory(value="pattern", scope=ScopeType.EVENT)
   public String getSearchPattern()
   {
      return searchString==null ? 
            "%" : '%' + searchString.toLowerCase().replace('*', '%') + '%';
   }
   
   public String getSearchString()
   {
      return searchString;
   }
   
   public void setSearchString(String searchString)
   {
      this.searchString = searchString;
   }
                                                                                         <span class="co">(4)</span>
   @Remove
   public void destroy() {}
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Stateful</tt> annotation identifies this class as a
                                stateful session bean. Stateful session beans are scoped to the conversation context by
                                default. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@Restrict</tt> annotation applies a security restriction to the
                                component. It restricts access to the component allowing only logged-in users. The
                                security chapter explains more about security in Seam. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <a href="annotations.html#datamodel-annotation">
                                    <tt class="literal">@DataModel</tt>
                                </a> annotation exposes a <tt class="literal">List</tt> as a JSF
                                <tt class="literal">ListDataModel</tt>. This makes it easy to implement clickable lists for
                                search screens. In this case, the list of hotels is exposed to the page as a
                                    <tt class="literal">ListDataModel</tt> in the conversation variable named
                                <tt class="literal">hotels</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Remove</tt> annotation specifies that a stateful
                                session bean should be removed and its state destroyed after invocation of the annotated
                                method. In Seam, all stateful session beans must define a method with no parameters marked
                                    <tt class="literal">@Remove</tt>. This method will be
                                called when Seam destroys the session context.</p></td></tr></table></div></div></div><p> The main page of the application is a Facelets page. Let's look at the fragment which relates to
                searching for hotels: </p><div class="example"><a name="d0e1671"></a><p class="title"><b>Example&nbsp;1.24.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;div class="section"&gt;
  
    &lt;span class="errors"&gt;
       &lt;h:messages globalOnly="true"/&gt;
    &lt;/span&gt;
    
    &lt;h1&gt;Search Hotels&lt;/h1&gt;

	&lt;h:form id="searchCriteria"&gt;
	&lt;fieldset&gt; 
	   &lt;h:inputText id="searchString" value="#{hotelSearch.searchString}" 
                    style="width: 165px;"&gt;
         &lt;a:support event="onkeyup" actionListener="#{hotelSearch.find}" 
                    reRender="searchResults" /&gt;                                          <span class="co">(1)</span>
       &lt;/h:inputText&gt;
       &amp;#160;
	   &lt;a:commandButton id="findHotels" value="Find Hotels" action="#{hotelSearch.find}" 
                        reRender="searchResults"/&gt;
       &amp;#160;
       &lt;a:status&gt;                                                                        <span class="co">(2)</span>
          &lt;f:facet name="start"&gt;
             &lt;h:graphicImage value="/img/spinner.gif"/&gt;
          &lt;/f:facet&gt;
       &lt;/a:status&gt;
	   &lt;br/&gt;
       &lt;h:outputLabel for="pageSize"&gt;Maximum results:&lt;/h:outputLabel&gt;&amp;#160;
       &lt;h:selectOneMenu value="#{hotelSearch.pageSize}" id="pageSize"&gt;
          &lt;f:selectItem itemLabel="5" itemValue="5"/&gt;
          &lt;f:selectItem itemLabel="10" itemValue="10"/&gt;
          &lt;f:selectItem itemLabel="20" itemValue="20"/&gt;
       &lt;/h:selectOneMenu&gt;
    &lt;/fieldset&gt;
    &lt;/h:form&gt;
    
&lt;/div&gt;

&lt;a:outputPanel id="searchResults"&gt;                                                       <span class="co">(3)</span>
  &lt;div class="section"&gt;
    &lt;h:outputText value="No Hotels Found"
                  rendered="#{hotels != null and hotels.rowCount==0}"/&gt;
    &lt;h:dataTable id="hotels" value="#{hotels}" var="hot" 
                 rendered="#{hotels.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
            #{hot.name}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Address&lt;/f:facet&gt;
            #{hot.address}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;City, State&lt;/f:facet&gt;
            #{hot.city}, #{hot.state}, #{hot.country}
        &lt;/h:column&gt; 
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Zip&lt;/f:facet&gt;
            #{hot.zip}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
            &lt;s:link id="viewHotel" value="View Hotel"                                    <span class="co">(4)</span>
                    action="#{hotelBooking.selectHotel(hot)}"/&gt;
        &lt;/h:column&gt;
    &lt;/h:dataTable&gt;
    &lt;s:link value="More results" action="#{hotelSearch.nextPage}" 
            rendered="#{hotelSearch.nextPageAvailable}"/&gt;
  &lt;/div&gt;
&lt;/a:outputPanel&gt;    </pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:support&gt;</tt> tag allows a JSF action
                                event listener to be called by asynchronous <tt class="literal">XMLHttpRequest</tt> when a
                                JavaScript event like <tt class="literal">onkeyup</tt> occurs. Even better, the
                                    <tt class="literal">reRender</tt> attribute lets us render a fragment of the JSF page and
                                perform a partial page update when the asynchronous response is received. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:status&gt;</tt> tag lets us display a cheesy
                                annimated image while we wait for asynchronous requests to return. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:outputPanel&gt;</tt> tag defines a region of
                                the page which can be re-rendered by an asynchronous request. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The Seam <tt class="literal">&lt;s:link&gt;</tt> tag lets us attach a JSF action
                                listener to an ordinary (non-JavaScript) HTML link. The advantage of this over the
                                standard JSF <tt class="literal">&lt;h:commandLink&gt;</tt> is that it preserves the
                                operation of "open in new window" and "open in new tab". Also notice that we use a
                                method binding with a parameter: <tt class="literal">#{hotelBooking.selectHotel(hot)}</tt>.
                                This is not possible in the standard Unified EL, but Seam provides an extension to the
                                EL that lets you use parameters on any method binding expression. </p></td></tr></table></div></div></div><p> This page displays the search results dynamically as we type, and lets us choose a hotel and pass it
                to the <tt class="literal">selectHotel()</tt> method of the <tt class="literal">HotelBookingAction</tt>, which is
                where the <span class="emphasis"><em>really</em></span> interesting stuff is going to happen. </p><p> Now lets see how the booking example application uses a conversation-scoped stateful session bean to
                achieve a natural cache of persistent data related to the conversation. The following code example is
                pretty long. But if you think of it as a list of scripted actions that implement the various steps of
                the conversation, it's understandable. Read the class from top to bottom, as if it were a story. </p><div class="example"><a name="d0e1733"></a><p class="title"><b>Example&nbsp;1.25.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful
@Name("hotelBooking")
@Restrict("#{identity.loggedIn}")
public class HotelBookingAction implements HotelBooking
{
   
   @PersistenceContext(type=EXTENDED)                                                    <span class="co">(1)</span>
   private EntityManager em;
   
   @In 
   private User user;
   
   @In(required=false) @Out
   private Hotel hotel;
   
   @In(required=false) 
   @Out(required=false)                                                                  <span class="co">(2)</span>
   private Booking booking;
     
   @In
   private FacesMessages facesMessages;
      
   @In
   private Events events;
   
   @Logger 
   private Log log;
   
   private boolean bookingValid;
   
   @Begin                                                                                <span class="co">(3)</span>
   public void selectHotel(Hotel selectedHotel)
   {
      hotel = em.merge(selectedHotel);
   }
   
   public void bookHotel()
   {      
      booking = new Booking(hotel, user);
      Calendar calendar = Calendar.getInstance();
      booking.setCheckinDate( calendar.getTime() );
      calendar.add(Calendar.DAY_OF_MONTH, 1);
      booking.setCheckoutDate( calendar.getTime() );
   }
   
   public void setBookingDetails()
   {
      Calendar calendar = Calendar.getInstance();
      calendar.add(Calendar.DAY_OF_MONTH, -1);
      if ( booking.getCheckinDate().before( calendar.getTime() ) )
      {
         facesMessages.addToControl("checkinDate", "Check in date must be a future date");
         bookingValid=false;
      }
      else if ( !booking.getCheckinDate().before( booking.getCheckoutDate() ) )
      {
         facesMessages.addToControl("checkoutDate", 
                                    "Check out date must be later than check in date");
         bookingValid=false;
      }
      else
      {
         bookingValid=true;
      }
   }
   
   public boolean isBookingValid()
   {
      return bookingValid;
   }
   
   @End                                                                                  <span class="co">(4)</span>
   public void confirm()
   {
      em.persist(booking);
      facesMessages.add("Thank you, #{user.name}, your confimation number " + 
                        " for #{hotel.name} is #{booking.id}");
      log.info("New booking: #{booking.id} for #{user.username}");
      events.raiseTransactionSuccessEvent("bookingConfirmed");
   }
   
   @End
   public void cancel() {}
   
   @Remove                                                                               <span class="co">(5)</span>
   public void destroy() {}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> This bean uses an EJB3 <span class="emphasis"><em>extended persistence context</em></span>, so that any
                                entity instances remain managed for the whole lifecycle of the stateful session bean.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <a href="annotations.html#out-annotation">
                                    <tt class="literal">@Out</tt>
                                </a> annotation declares that an attribute value is <span class="emphasis"><em>outjected</em></span> to
                                a context variable after method invocations. In this case, the context variable named
                                    <tt class="literal">hotel</tt> will be set to the value of the <tt class="literal">hotel</tt>
                                instance variable after every action listener invocation completes. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <a href="annotations.html#begin-annotation">
                                    <tt class="literal">@Begin</tt>
                                </a> annotation specifies that the annotated method begins a <span class="emphasis"><em>long-running
                                    conversation</em></span>, so the current conversation context will not be destroyed
                                at the end of the request. Instead, it will be reassociated with every request from the
                                current window, and destroyed either by timeout due to conversation inactivity or
                                invocation of a matching <tt class="literal">@End</tt> method. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The <a href="annotations.html#end-annotation">
                                    <tt class="literal">@End</tt>
                                </a> annotation specifies that the annotated method ends the current long-running
                                conversation, so the current conversation context will be destroyed at the end of the
                                request. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> This EJB remove method will be called when Seam destroys the conversation context.
                                Don't forget to define this method! </p></td></tr></table></div></div></div><p>
                <tt class="literal">HotelBookingAction</tt> contains all the action listener methods that implement selection,
                booking and booking confirmation, and holds state related to this work in its instance variables. We
                think you'll agree that this code is much cleaner and simpler than getting and setting
                    <tt class="literal">HttpSession</tt> attributes. </p><p> Even better, a user can have multiple isolated conversations per login session. Try it! Log in, run a
                search, and navigate to different hotel pages in multiple browser tabs. You'll be able to work on
                creating two different hotel reservations at the same time. If you leave any one conversation inactive
                for long enough, Seam will eventually time out that conversation and destroy its state. If, after ending
                a conversation, you backbutton to a page of that conversation and try to perform an action, Seam will
                detect that the conversation was already ended, and redirect you to the search page. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1805"></a>1.6.4.&nbsp;The Seam UI control library</h3></div></div><div></div></div><p> If you check inside the WAR file for the booking application, you'll find
                <tt class="literal">seam-ui.jar</tt> in the <tt class="literal">WEB-INF/lib</tt> directory. This package contains a
                number of JSF custom controls that integrate with Seam. The booking application uses the
                    <tt class="literal">&lt;s:link&gt;</tt> control for navigation from the search screen to the hotel
                page: </p><pre class="programlisting">&lt;s:link value="View Hotel" action="#{hotelBooking.selectHotel(hot)}"/&gt;</pre><p> The use of <tt class="literal">&lt;s:link&gt;</tt> here allows us to attach an action listener to a
                HTML link without breaking the browser's "open in new window" feature. The standard JSF
                    <tt class="literal">&lt;h:commandLink&gt;</tt> does not work with "open in new window". We'll see
                later that <tt class="literal">&lt;s:link&gt;</tt> also offers a number of other useful features,
                including conversation propagation rules. </p><p> The booking application uses some other Seam and RichFaces Ajax controls, especially on the
                    <tt class="literal">/book.xhtml</tt> page. We won't get into the details of those controls here, but if
                you want to understand this code, please refer to the chapter covering Seam's functionality for JSF form
                validation. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1837"></a>1.6.5.&nbsp;The Seam Debug Page</h3></div></div><div></div></div><p> The WAR also includes <tt class="literal">seam-debug.jar</tt>.  The Seam debug page will be availabled 
                if this jar is deployed in
                    <tt class="literal">WEB-INF/lib</tt>, along with the Facelets, and if you set the debug property
                of the <tt class="literal">init</tt> component:</p><pre class="programlisting">&lt;core:init jndi-pattern="@jndiPattern@" debug="true"/&gt;</pre><p>  This page lets you browse and inspect the Seam components
                in any of the Seam contexts associated with your current login session. Just point your browser at
                    <a href="http://localhost:8080/seam-booking/debug.seam" target="_top">
                    <tt class="literal">http://localhost:8080/seam-booking/debug.seam</tt>
                </a>. </p><div class="mediaobject" align="center"><img src="../shared/images/debug.png" align="middle"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dvdstore"></a>1.7.&nbsp;A complete application featuring Seam and jBPM: the DVD Store example</h2></div></div><div></div></div><p> The DVD Store demo application shows the practical usage of jBPM for both task management and pageflow. </p><p> The user screens take advantage of a jPDL pageflow to implement searching and shopping cart
            functionality. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/dvdsearch.png" align="middle"></div></div><p> The administration screens take use jBPM to manage the approval and shipping cycle for orders. The
            business process may even be changed dynamically, by selecting a different process definition! </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/dvdtasks.png" align="middle"></div></div><p>TODO</p><p>Look in the <tt class="literal">dvdstore</tt> directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hibernate"></a>1.8.&nbsp;An example of Seam with Hibernate: the Hibernate Booking example</h2></div></div><div></div></div><p> The Hibernate Booking demo is a straight port of the Booking demo to an alternative architecture that
            uses Hibernate for persistence and JavaBeans instead of session beans. </p><p>TODO</p><p>Look in the <tt class="literal">hibernate</tt> directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blog"></a>1.9.&nbsp;A RESTful Seam application: the Blog example</h2></div></div><div></div></div><p> Seam makes it very easy to implement applications which keep state on the server-side. However,
            server-side state is not always appropriate, especially in for functionality that serves up
                <span class="emphasis"><em>content</em></span>. For this kind of problem we often need to let the user bookmark pages and
            have a relatively stateless server, so that any page can be accessed at any time, via the bookmark. The Blog
            example shows how to a implement RESTful application using Seam. Every page of the application can be
            bookmarked, including the search results page. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/blog.png" align="middle"></div></div><p> The Blog example demonstrates the use of "pull"-style MVC, where instead of using action listener methods
            to retrieve data and prepare the data for the view, the view pulls data from components as it is being
            rendered. </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1928"></a>1.9.1.&nbsp;Using "pull"-style MVC</h3></div></div><div></div></div><p> This snippet from the <tt class="literal">index.xhtml</tt> facelets page displays a list of recent blog
                entries: </p><div class="example"><a name="d0e1936"></a><p class="title"><b>Example&nbsp;1.26.&nbsp;</b></p><pre class="programlisting">&lt;h:dataTable value="#{blog.recentBlogEntries}" var="blogEntry" rows="3"&gt;
   &lt;h:column&gt;
      &lt;div class="blogEntry"&gt;
         &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
         &lt;div&gt;
            &lt;h:outputText escape="false" 
                  value="#{blogEntry.excerpt==null ? blogEntry.body : blogEntry.excerpt}"/&gt;
         &lt;/div&gt;
         &lt;p&gt;
            &lt;h:outputLink value="entry.seam" rendered="#{blogEntry.excerpt!=null}"&gt;
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
               Read more...
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
         &lt;p&gt;
            [Posted on 
            &lt;h:outputText value="#{blogEntry.date}"&gt;
               &lt;f:convertDateTime timeZone="#{blog.timeZone}" 
                                  locale="#{blog.locale}" type="both"/&gt;
            &lt;/h:outputText&gt;]
            &amp;#160;
            &lt;h:outputLink value="entry.seam"&gt;[Link]
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p> If we navigate to this page from a bookmark, how does the data used by the
                    <tt class="literal">&lt;h:dataTable&gt;</tt> actually get initialized? Well, what happens is that
                the <tt class="literal">Blog</tt> is retrieved lazily&#8212;"pulled"&#8212;when needed, by a Seam
                component named <tt class="literal">blog</tt>. This is the opposite flow of control to what is usual in
                traditional web action-based frameworks like Struts. </p><div class="example"><a name="d0e1950"></a><p class="title"><b>Example&nbsp;1.27.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("blog")
@Scope(ScopeType.STATELESS)
@AutoCreate
public class BlogService 
{
   
   @In EntityManager entityManager;                                                      <span class="co">(1)</span>
  
   @Unwrap                                                                               <span class="co">(2)</span>
   public Blog getBlog()
   {
      return (Blog) entityManager.createQuery("select distinct b from Blog b left join fetch b.blogEntries")
            .setHint("org.hibernate.cacheable", true)
            .getSingleResult();
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> This component uses a <span class="emphasis"><em>seam-managed persistence context</em></span>. Unlike
                                the other examples we've seen, this persistence context is managed by Seam, instead of
                                by the EJB3 container. The persistence context spans the entire web request, allowing us
                                to avoid any exceptions that occur when accessing unfetched associations in the view.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@Unwrap</tt> annotation tells Seam to provide the return value of
                                the method&#8212;the <tt class="literal">Blog</tt>&#8212;instead of the actual
                                    <tt class="literal">BlogService</tt> component to clients. This is the Seam
                                    <span class="emphasis"><em>manager component pattern</em></span>. </p></td></tr></table></div></div></div><p> This is good so far, but what about bookmarking the result of form submissions, such as a search
                results page? </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1981"></a>1.9.2.&nbsp;Bookmarkable search results page</h3></div></div><div></div></div><p> The blog example has a tiny form in the top right of each page that allows the user to search for
                blog entries. This is defined in a file, <tt class="literal">menu.xhtml</tt>, included by the facelets
                template, <tt class="literal">template.xhtml</tt>: </p><div class="example"><a name="d0e1992"></a><p class="title"><b>Example&nbsp;1.28.&nbsp;</b></p><pre class="programlisting">&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="/search.xhtml"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p> To implement a bookmarkable search results page, we need to perform a browser redirect after
                processing the search form submission. Because we used the JSF view id as the action outcome, Seam
                automatically redirects to the view id when the form is submitted. Alternatively, we could have defined
                a navigation rule like this: </p><div class="example"><a name="d0e1997"></a><p class="title"><b>Example&nbsp;1.29.&nbsp;</b></p><pre class="programlisting">&lt;navigation-rule&gt;
   &lt;navigation-case&gt;
      &lt;from-outcome&gt;searchResults&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/search.xhtml&lt;/to-view-id&gt;
      &lt;redirect/&gt;
   &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p> Then the form would have looked like this: </p><div class="example"><a name="d0e2002"></a><p class="title"><b>Example&nbsp;1.30.&nbsp;</b></p><pre class="programlisting">&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="searchResults"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p> But when we redirect, we need to include the values submitted with the form as request parameters, to
                get a bookmarkable URL like
                <tt class="literal">http://localhost:8080/seam-blog/search.seam?searchPattern=seam</tt>. JSF does not provide
                an easy way to do this, but Seam does. We use a Seam <span class="emphasis"><em>page parameter</em></span>, defined in
                    <tt class="literal">WEB-INF/pages.xml</tt>: </p><div class="example"><a name="d0e2016"></a><p class="title"><b>Example&nbsp;1.31.&nbsp;</b></p><pre class="programlisting">&lt;pages&gt;
   &lt;page view-id="/search.xhtml"&gt;
      &lt;param name="searchPattern" value="#{searchService.searchPattern}"/&gt;
   &lt;/page&gt;
   ...
&lt;/pages&gt;</pre></div><p> This tells Seam to include the value of <tt class="literal">#{searchService.searchPattern}</tt> as a
                request parameter named <tt class="literal">searchPattern</tt> when redirecting to the page, and then re-apply
                the value of that parameter to the model before rendering the page. </p><p> The redirect takes us to the <tt class="literal">search.xhtml</tt> page: </p><div class="example"><a name="d0e2032"></a><p class="title"><b>Example&nbsp;1.32.&nbsp;</b></p><pre class="programlisting">&lt;h:dataTable value="#{searchResults}" var="blogEntry"&gt;
   &lt;h:column&gt;
      &lt;div&gt;
         &lt;h:outputLink value="entry.seam"&gt;
            &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            #{blogEntry.title}
         &lt;/h:outputLink&gt;
         posted on 
         &lt;h:outputText value="#{blogEntry.date}"&gt;
            &lt;f:convertDateTime timeZone="#{blog.timeZone}" locale="#{blog.locale}" type="both"/&gt;
         &lt;/h:outputText&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p> Which again uses "pull"-style MVC to retrieve the actual search results: </p><div class="example"><a name="d0e2037"></a><p class="title"><b>Example&nbsp;1.33.&nbsp;</b></p><pre class="programlisting">@Name("searchService")
public class SearchService 
{
   
   @In
   private EntityManager entityManager;
   
   private String searchPattern;
   
   @Factory("searchResults")
   public List&lt;BlogEntry&gt; getSearchResults()
   {
      if (searchPattern==null)
      {
         return null;
      }
      else
      {
         return entityManager.createQuery("select be from BlogEntry be "" + 
                      "where lower(be.title) like :searchPattern " + 
                      "lower(be.body) like :searchPattern order by be.date desc")
               .setParameter( "searchPattern", getSqlSearchPattern() )
               .setMaxResults(100)
               .getResultList();
      }
   }

   private String getSqlSearchPattern()
   {
      return searchPattern==null ? "" :
             '%' + searchPattern.toLowerCase().replace('*', '%').replace('?', '_') + '%';
   }

   public String getSearchPattern()
   {
      return searchPattern;
   }

   public void setSearchPattern(String searchPattern)
   {
      this.searchPattern = searchPattern;
   }

}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2040"></a>1.9.3.&nbsp;Using "push"-style MVC in a RESTful application</h3></div></div><div></div></div><p> Very occasionally, it makes more sense to use push-style MVC for processing RESTful pages, and so
                Seam provides the notion of a <span class="emphasis"><em>page action</em></span>. The Blog example uses a page action for
                the blog entry page, <tt class="literal">entry.xhtml</tt>. Note that this is a little bit contrived, it would
                have been easier to use pull-style MVC here as well. </p><p> The <tt class="literal">entryAction</tt> component works much like an action class in a traditional
                push-MVC action-oriented framework like Struts: </p><div class="example"><a name="d0e2056"></a><p class="title"><b>Example&nbsp;1.34.&nbsp;</b></p><pre class="programlisting">@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry(String id) throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry(id);
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}</pre></div><p> Page actions are also declared in <tt class="literal">pages.xml</tt>: </p><div class="example"><a name="d0e2064"></a><p class="title"><b>Example&nbsp;1.35.&nbsp;</b></p><pre class="programlisting">&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry(blogEntry.id)}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;

   &lt;page view-id="/post.xhtml" action="#{loginAction.challenge}"/&gt;

   &lt;page view-id="*" action="#{blog.hitCount.hit}"/&gt;

&lt;/pages&gt;</pre></div><p> Notice that the example is using page actions for some other functionality&#8212;the login
                challenge, and the pageview counter. Also notice the use of a parameter in the page action method
                binding. This is not a standard feature of JSF EL, but Seam lets you use it, not just for page actions,
                but also in JSF method bindings. </p><p> When the <tt class="literal">entry.xhtml</tt> page is requested, Seam first binds the page parameter
                    <tt class="literal">blogEntryId</tt> to the model, then runs the page action, which retrieves the needed
                data&#8212;the <tt class="literal">blogEntry</tt>&#8212;and places it in the Seam event context.
                Finally, the following is rendered: </p><div class="example"><a name="d0e2080"></a><p class="title"><b>Example&nbsp;1.36.&nbsp;</b></p><pre class="programlisting">&lt;div class="blogEntry"&gt;
   &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
   &lt;div&gt;
      &lt;h:outputText escape="false" value="#{blogEntry.body}"/&gt;
   &lt;/div&gt;
   &lt;p&gt;
      [Posted on&amp;#160;
      &lt;h:outputText value="#{blogEntry.date}"&gt;
         &lt;f:convertDateTime timezone="#{blog.timeZone}" 
                            locale="#{blog.locale}" type="both"/&gt;
      &lt;/h:outputText&gt;]
   &lt;/p&gt;
&lt;/div&gt;</pre></div><p> If the blog entry is not found in the database, the <tt class="literal">EntryNotFoundException</tt>
                exception is thrown. We want this exception to result in a 404 error, not a 505, so we annotate the
                exception class: </p><div class="example"><a name="d0e2088"></a><p class="title"><b>Example&nbsp;1.37.&nbsp;</b></p><pre class="programlisting">@ApplicationException(rollback=true)
@HttpError(errorCode=HttpServletResponse.SC_NOT_FOUND)
public class EntryNotFoundException extends Exception
{
   EntryNotFoundException(String id)
   {
      super("entry not found: " + id);
   }
}</pre></div><p> An alternative implementation of the example does not use the parameter in the method binding: </p><div class="example"><a name="d0e2093"></a><p class="title"><b>Example&nbsp;1.38.&nbsp;</b></p><pre class="programlisting">@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @In @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry() throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry( blogEntry.getId() );
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}</pre><pre class="programlisting">&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;
   
   ...
&lt;/pages&gt;</pre></div><p> It is a matter of taste which implementation you prefer. </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pr01.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="gettingstarted.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Introduction to JBoss Seam&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;Getting started with Seam, using seam-gen</td></tr></table></div></body></html>