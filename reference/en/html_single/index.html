<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Seam - Contextual Components</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Seam - Contextual Components</h1></div><div><h2 class="subtitle">A Framework for Enterprise Java</h2></div><div><p class="releaseinfo">2.0.0.GA</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d0e10">Introduction to JBoss Seam</a></span></dt><dt><span class="chapter"><a href="#tutorial">1. Seam Tutorial</a></span></dt><dd><dl><dt><span class="section"><a href="#try-examples">1.1. Try the examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e233">1.1.1. Running the examples on JBoss AS</a></span></dt><dt><span class="section"><a href="#d0e271">1.1.2. Running the examples on Tomcat</a></span></dt><dt><span class="section"><a href="#d0e309">1.1.3. Running the example tests</a></span></dt></dl></dd><dt><span class="section"><a href="#registration-example">1.2. Your first Seam application: the registration example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e336">1.2.1. Understanding the code</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e348">1.2.1.1. The entity bean: User.java</a></span></dt><dt><span class="section"><a href="#d0e474">1.2.1.2. The stateless session bean class: RegisterAction.java</a></span></dt><dt><span class="section"><a href="#d0e599">1.2.1.3. The session bean local interface: Register.java</a></span></dt><dt><span class="section"><a href="#d0e611">1.2.1.4. The Seam component deployment descriptor: components.xml</a></span></dt><dt><span class="section"><a href="#d0e649">1.2.1.5. The web deployment description: web.xml</a></span></dt><dt><span class="section"><a href="#d0e664">1.2.1.6. The JSF configration: faces-config.xml</a></span></dt><dt><span class="section"><a href="#d0e695">1.2.1.7. The EJB deployment descriptor: ejb-jar.xml</a></span></dt><dt><span class="section"><a href="#d0e710">1.2.1.8. The EJB persistence deployment descriptor: persistence.xml</a></span></dt><dt><span class="section"><a href="#d0e722">1.2.1.9. The view: register.xhtml and registered.xhtml</a></span></dt><dt><span class="section"><a href="#d0e745">1.2.1.10. The EAR deployment descriptor: application.xml</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e765">1.2.2. How it works</a></span></dt></dl></dd><dt><span class="section"><a href="#messages">1.3. Clickable lists in Seam: the messages example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e844">1.3.1. Understanding the code</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e855">1.3.1.1. The entity bean: Message.java</a></span></dt><dt><span class="section"><a href="#d0e868">1.3.1.2. The stateful session bean: MessageManagerBean.java</a></span></dt><dt><span class="section"><a href="#d0e1009">1.3.1.3. The session bean local interface: MessageManager.java</a></span></dt><dt><span class="section"><a href="#d0e1040">1.3.1.4. The view: messages.jsp</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1053">1.3.2. How it works</a></span></dt></dl></dd><dt><span class="section"><a href="#todo">1.4. Seam and jBPM: the todo list example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1144">1.4.1. Understanding the code</a></span></dt><dt><span class="section"><a href="#d0e1327">1.4.2. How it works</a></span></dt></dl></dd><dt><span class="section"><a href="#numberguess">1.5. Seam pageflow: the numberguess example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1344">1.5.1. Understanding the code</a></span></dt><dt><span class="section"><a href="#d0e1453">1.5.2. How it works</a></span></dt></dl></dd><dt><span class="section"><a href="#booking">1.6. A complete Seam application: the Hotel Booking example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1461">1.6.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e1511">1.6.2. Overview of the booking example</a></span></dt><dt><span class="section"><a href="#d0e1568">1.6.3. Understanding Seam conversations</a></span></dt><dt><span class="section"><a href="#d0e1805">1.6.4. The Seam UI control library</a></span></dt><dt><span class="section"><a href="#d0e1837">1.6.5. The Seam Debug Page</a></span></dt></dl></dd><dt><span class="section"><a href="#dvdstore">1.7. A complete application featuring Seam and jBPM: the DVD Store example</a></span></dt><dt><span class="section"><a href="#hibernate">1.8. An example of Seam with Hibernate: the Hibernate Booking example</a></span></dt><dt><span class="section"><a href="#blog">1.9. A RESTful Seam application: the Blog example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1928">1.9.1. Using "pull"-style MVC</a></span></dt><dt><span class="section"><a href="#d0e1981">1.9.2. Bookmarkable search results page</a></span></dt><dt><span class="section"><a href="#d0e2040">1.9.3. Using "push"-style MVC in a RESTful application</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gettingstarted">2. Getting started with Seam, using seam-gen</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2116">2.1. Before you start</a></span></dt><dt><span class="section"><a href="#d0e2139">2.2. Setting up a new Eclipse project</a></span></dt><dt><span class="section"><a href="#d0e2251">2.3. Creating a new action</a></span></dt><dt><span class="section"><a href="#d0e2300">2.4. Creating a form with an action</a></span></dt><dt><span class="section"><a href="#d0e2314">2.5. Generating an application from an existing database</a></span></dt><dt><span class="section"><a href="#d0e2329">2.6. Deploying the application as an EAR</a></span></dt><dt><span class="section"><a href="#gettingstarted-hotdeployment">2.7. Seam and incremental hot deployment</a></span></dt><dt><span class="section"><a href="#d0e2445">2.8. Using Seam with JBoss 4.0</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2450">2.8.1. Install JBoss 4.0</a></span></dt><dt><span class="section"><a href="#d0e2458">2.8.2. Install the JSF 1.2 RI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#concepts">3. The contextual component model</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e2517">3.1. Seam contexts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2556">3.1.1. Stateless context</a></span></dt><dt><span class="sect2"><a href="#d0e2561">3.1.2. Event context</a></span></dt><dt><span class="sect2"><a href="#d0e2568">3.1.3. Page context</a></span></dt><dt><span class="sect2"><a href="#d0e2573">3.1.4. Conversation context</a></span></dt><dt><span class="sect2"><a href="#d0e2606">3.1.5. Session context</a></span></dt><dt><span class="sect2"><a href="#d0e2613">3.1.6. Business process context</a></span></dt><dt><span class="sect2"><a href="#d0e2621">3.1.7. Application context</a></span></dt><dt><span class="sect2"><a href="#d0e2626">3.1.8. Context variables</a></span></dt><dt><span class="sect2"><a href="#d0e2650">3.1.9. Context search priority</a></span></dt><dt><span class="sect2"><a href="#concurrency">3.1.10. Concurrency model</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e2704">3.2. Seam components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2728">3.2.1. Stateless session beans</a></span></dt><dt><span class="sect2"><a href="#d0e2750">3.2.2. Stateful session beans</a></span></dt><dt><span class="sect2"><a href="#d0e2775">3.2.3. Entity beans</a></span></dt><dt><span class="sect2"><a href="#d0e2799">3.2.4. JavaBeans</a></span></dt><dt><span class="sect2"><a href="#d0e2821">3.2.5. Message-driven beans</a></span></dt><dt><span class="sect2"><a href="#d0e2830">3.2.6. Interception</a></span></dt><dt><span class="sect2"><a href="#d0e2844">3.2.7. Component names</a></span></dt><dt><span class="sect2"><a href="#d0e2907">3.2.8. Defining the component scope</a></span></dt><dt><span class="sect2"><a href="#d0e2922">3.2.9. Components with multiple roles</a></span></dt><dt><span class="sect2"><a href="#d0e2945">3.2.10. Built-in components</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e2960">3.3. Bijection</a></span></dt><dt><span class="sect1"><a href="#d0e3063">3.4. Lifecycle methods</a></span></dt><dt><span class="sect1"><a href="#d0e3115">3.5. Conditional installation</a></span></dt><dt><span class="sect1"><a href="#d0e3201">3.6. Logging</a></span></dt><dt><span class="sect1"><a href="#d0e3249">3.7. The Mutable interface and @ReadOnly</a></span></dt><dt><span class="sect1"><a href="#d0e3302">3.8. Factory and manager components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">4. Configuring Seam components</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e3374">4.1. Configuring components via property settings</a></span></dt><dt><span class="sect1"><a href="#d0e3416">4.2. Configuring components via components.xml</a></span></dt><dt><span class="sect1"><a href="#d0e3583">4.3. Fine-grained configuration files</a></span></dt><dt><span class="sect1"><a href="#d0e3621">4.4. Configurable property types</a></span></dt><dt><span class="sect1"><a href="#d0e3653">4.5. Using XML Namespaces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">5. Events, interceptors and exception handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e3798">5.1. Seam events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3832">5.1.1. Page actions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e3872">5.1.1.1. Page parameters</a></span></dt><dt><span class="sect3"><a href="#d0e4000">5.1.1.2. Navigation</a></span></dt><dt><span class="sect3"><a href="#d0e4073">5.1.1.3. Fine-grained files for definition of navigation, page actions and parameters</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e4089">5.1.2. Component-driven events</a></span></dt><dt><span class="sect2"><a href="#d0e4140">5.1.3. Contextual events</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e4310">5.2. Seam interceptors</a></span></dt><dt><span class="sect1"><a href="#d0e4383">5.3. Managing exceptions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4391">5.3.1. Exceptions and transactions</a></span></dt><dt><span class="sect2"><a href="#d0e4417">5.3.2. Enabling Seam exception handling</a></span></dt><dt><span class="sect2"><a href="#d0e4435">5.3.3. Using annotations for exception handling</a></span></dt><dt><span class="sect2"><a href="#d0e4460">5.3.4. Using XML for exception handling</a></span></dt><dt><span class="sect2"><a href="#d0e4495">5.3.5. Some common exceptions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#conversations">6. Conversations and workspace management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4559">6.1. Seam's conversation model</a></span></dt><dt><span class="section"><a href="#d0e4656">6.2. Nested conversations</a></span></dt><dt><span class="section"><a href="#d0e4681">6.3. Starting conversations with GET requests</a></span></dt><dt><span class="section"><a href="#d0e4782">6.4. Using &lt;s:link&gt; and &lt;s:button&gt;</a></span></dt><dt><span class="section"><a href="#d0e4886">6.5. Success messages</a></span></dt><dt><span class="section"><a href="#d0e4914">6.6. Using an "explicit" conversation id</a></span></dt><dt><span class="section"><a href="#d0e4938">6.7. Workspace management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4953">6.7.1. Workspace management and JSF navigation</a></span></dt><dt><span class="section"><a href="#d0e4974">6.7.2. Workspace management and jPDL pageflow</a></span></dt><dt><span class="section"><a href="#d0e4990">6.7.3. The conversation switcher</a></span></dt><dt><span class="section"><a href="#d0e5006">6.7.4. The conversation list</a></span></dt><dt><span class="section"><a href="#d0e5024">6.7.5. Breadcrumbs</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5036">6.8. Conversational components and JSF component bindings</a></span></dt><dt><span class="section"><a href="#d0e5062">6.9. Concurrent calls to conversational components</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5101">6.9.1. RichFaces Ajax</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#jbpm">7. Pageflows and business processes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5165">7.1. Pageflow in Seam</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5185">7.1.1. The two navigation models</a></span></dt><dt><span class="section"><a href="#d0e5241">7.1.2. Seam and the back button</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5286">7.2. Using jPDL pageflows</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5289">7.2.1. Installing pageflows</a></span></dt><dt><span class="section"><a href="#d0e5301">7.2.2. Starting pageflows</a></span></dt><dt><span class="section"><a href="#d0e5342">7.2.3. Page nodes and transitions</a></span></dt><dt><span class="section"><a href="#d0e5400">7.2.4. Controlling the flow</a></span></dt><dt><span class="section"><a href="#d0e5412">7.2.5. Ending the flow</a></span></dt><dt><span class="section"><a href="#d0e5435">7.2.6. Pageflow composition</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5456">7.3. Business process management in Seam</a></span></dt><dt><span class="section"><a href="#d0e5496">7.4. Using jPDL business process definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5499">7.4.1. Installing process definitions</a></span></dt><dt><span class="section"><a href="#d0e5506">7.4.2. Initializing actor ids</a></span></dt><dt><span class="section"><a href="#d0e5522">7.4.3. Initiating a business process</a></span></dt><dt><span class="section"><a href="#d0e5536">7.4.4. Task assignment</a></span></dt><dt><span class="section"><a href="#d0e5547">7.4.5. Task lists</a></span></dt><dt><span class="section"><a href="#d0e5579">7.4.6. Performing a task</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistence">8. Seam and Object/Relational Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5620">8.1. Introduction</a></span></dt><dt><span class="section"><a href="#persistence.seam-managed-transactions">8.2. Seam managed transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5686">8.2.1. Disabling Seam-managed transactions</a></span></dt><dt><span class="section"><a href="#d0e5699">8.2.2. Configuring a Seam transaction manager</a></span></dt><dt><span class="section"><a href="#d0e5759">8.2.3. Transaction synchronization</a></span></dt></dl></dd><dt><span class="section"><a href="#persistence.seam-managed-persistence-contexts">8.3. Seam-managed persistence contexts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5797">8.3.1. Using a Seam-managed persistence context with JPA</a></span></dt><dt><span class="section"><a href="#d0e5849">8.3.2. Using a Seam-managed Hibernate session</a></span></dt><dt><span class="section"><a href="#d0e5881">8.3.3. Seam-managed persistence contexts and atomic conversations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5933">8.4. Using the JPA "delegate"</a></span></dt><dt><span class="section"><a href="#d0e5962">8.5. Using EL in EJB-QL/HQL</a></span></dt><dt><span class="section"><a href="#d0e5988">8.6. Using Hibernate filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validation">9. JSF form validation in Seam</a></span></dt><dt><span class="chapter"><a href="#groovy">10. Groovy integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6104">10.1. Groovy introduction</a></span></dt><dt><span class="section"><a href="#d0e6118">10.2. Writing Seam applications in Groovy</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6123">10.2.1. Writing Groovy components</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6128">10.2.1.1. Entity</a></span></dt><dt><span class="section"><a href="#d0e6148">10.2.1.2. Seam component</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6156">10.2.2. seam-gen</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6173">10.3. Deployment</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6183">10.3.1. Deploying Groovy code</a></span></dt><dt><span class="section"><a href="#d0e6194">10.3.2. Native .groovy file deployment at development time</a></span></dt><dt><span class="section"><a href="#d0e6228">10.3.3. seam-gen</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#framework">11. The Seam Application Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6259">11.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6304">11.2. Home objects</a></span></dt><dt><span class="section"><a href="#d0e6472">11.3. Query objects</a></span></dt><dt><span class="section"><a href="#d0e6522">11.4. Controller objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#drools">12. Seam and JBoss Rules</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6553">12.1. Installing rules</a></span></dt><dt><span class="section"><a href="#d0e6614">12.2. Using rules from a Seam component</a></span></dt><dt><span class="section"><a href="#d0e6624">12.3. Using rules from a jBPM process definition</a></span></dt></dl></dd><dt><span class="chapter"><a href="#security">13. Security</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e6672">13.1. Overview</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6690">13.1.1. Which mode is right for my application?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e6697">13.2. Requirements</a></span></dt><dt><span class="sect1"><a href="#d0e6729">13.3. Disabling Security</a></span></dt><dt><span class="sect1"><a href="#d0e6750">13.4. Authentication</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6755">13.4.1. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e6784">13.4.2. Writing an authentication method</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e6832">13.4.2.1. Identity.addRole()</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e6854">13.4.3. Writing a login form</a></span></dt><dt><span class="sect2"><a href="#d0e6878">13.4.4. Simplified Configuration - Summary</a></span></dt><dt><span class="sect2"><a href="#d0e6896">13.4.5. Handling Security Exceptions</a></span></dt><dt><span class="sect2"><a href="#d0e6932">13.4.6. Login Redirection</a></span></dt><dt><span class="sect2"><a href="#d0e6953">13.4.7. HTTP Authentication</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e6990">13.4.7.1. Writing a Digest Authenticator</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e7003">13.4.8. Advanced Authentication Features</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e7008">13.4.8.1. Using your container's JAAS configuration</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e7030">13.5. Error Messages</a></span></dt><dt><span class="sect1"><a href="#d0e7075">13.6. Authorization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7083">13.6.1. Core concepts</a></span></dt><dt><span class="sect2"><a href="#d0e7105">13.6.2. Securing components</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e7113">13.6.2.1. The @Restrict annotation</a></span></dt><dt><span class="sect3"><a href="#d0e7214">13.6.2.2. Inline restrictions</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e7255">13.6.3. Security in the user interface</a></span></dt><dt><span class="sect2"><a href="#d0e7298">13.6.4. Securing pages</a></span></dt><dt><span class="sect2"><a href="#d0e7338">13.6.5. Securing Entities</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e7463">13.6.5.1. Entity security with JPA</a></span></dt><dt><span class="sect3"><a href="#d0e7476">13.6.5.2. Entity security with Hibernate</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e7484">13.7. Writing Security Rules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7489">13.7.1. Permissions Overview</a></span></dt><dt><span class="sect2"><a href="#d0e7497">13.7.2. Configuring a rules file</a></span></dt><dt><span class="sect2"><a href="#d0e7518">13.7.3. Creating a security rules file</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e7675">13.7.3.1. Wildcard permission checks</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e7699">13.8. SSL Security</a></span></dt><dt><span class="sect1"><a href="#d0e7769">13.9. Implementing a Captcha Test</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7798">13.9.1. Configuring the Captcha Servlet</a></span></dt><dt><span class="sect2"><a href="#d0e7808">13.9.2. Adding a Captcha to a page</a></span></dt><dt><span class="sect2"><a href="#d0e7826">13.9.3. Customising the Captcha image</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#i18n">14. Internationalization and themes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7863">14.1. Locales</a></span></dt><dt><span class="section"><a href="#d0e7917">14.2. Labels</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7928">14.2.1. Defining labels</a></span></dt><dt><span class="section"><a href="#d0e8001">14.2.2. Displaying labels</a></span></dt><dt><span class="section"><a href="#d0e8027">14.2.3. Faces messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8045">14.3. Timezones</a></span></dt><dt><span class="section"><a href="#d0e8067">14.4. Themes</a></span></dt><dt><span class="section"><a href="#d0e8112">14.5. Persisting locale and theme preferences via cookies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#text">15. Seam Text</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8136">15.1. Basic fomatting</a></span></dt><dt><span class="section"><a href="#d0e8179">15.2. Entering code and text with special characters</a></span></dt><dt><span class="section"><a href="#d0e8221">15.3. Links</a></span></dt><dt><span class="section"><a href="#d0e8234">15.4. Entering HTML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#itext">16. iText PDF generation</a></span></dt><dd><dl><dt><span class="section"><a href="#itext.intro">16.1. Using PDF Support</a></span></dt><dd><dl><dt><span class="section"><a href="#itext.document">16.1.1. Creating a document</a></span></dt><dt><span class="section"><a href="#itext.text">16.1.2. Basic Text Elements</a></span></dt><dt><span class="section"><a href="#itext.header">16.1.3. Headers and Footers</a></span></dt><dt><span class="section"><a href="#itext.chapters">16.1.4. Chapters and Sections</a></span></dt><dt><span class="section"><a href="#itext.list">16.1.5. Lists</a></span></dt><dt><span class="section"><a href="#itext.tables">16.1.6. Tables</a></span></dt><dt><span class="section"><a href="#itext.constant">16.1.7. Document Constants</a></span></dt><dd><dl><dt><span class="section"><a href="#itext.colors">16.1.7.1. Color Values</a></span></dt><dt><span class="section"><a href="#itext.alignment">16.1.7.2. Alignment Values</a></span></dt></dl></dd><dt><span class="section"><a href="#itext.configuration">16.1.8. Configuring iText</a></span></dt></dl></dd><dt><span class="section"><a href="#itext.charting">16.2. Charting</a></span></dt><dt><span class="section"><a href="#itext.barcodes">16.3. Bar codes</a></span></dt><dt><span class="section"><a href="#itext.links">16.4. Further documentation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mail">17. Email</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10698">17.1. Creating a message</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10739">17.1.1. Attachments</a></span></dt><dt><span class="section"><a href="#d0e10817">17.1.2. HTML/Text alternative part</a></span></dt><dt><span class="section"><a href="#d0e10824">17.1.3. Multiple recipients</a></span></dt><dt><span class="section"><a href="#d0e10834">17.1.4. Multiple messages</a></span></dt><dt><span class="section"><a href="#d0e10844">17.1.5. Templating</a></span></dt><dt><span class="section"><a href="#d0e10879">17.1.6. Internationalisation</a></span></dt><dt><span class="section"><a href="#d0e10890">17.1.7. Other Headers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10906">17.2. Receiving emails</a></span></dt><dt><span class="section"><a href="#d0e10948">17.3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10972">17.3.1. mailSession</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10982">17.3.1.1. JNDI lookup in JBoss AS</a></span></dt><dt><span class="section"><a href="#d0e11000">17.3.1.2. Seam configured Session</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e11013">17.4. Meldware</a></span></dt><dt><span class="section"><a href="#mail.tags">17.5. Tags</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jms">18. Asynchronicity and messaging</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e11371">18.1. Asynchronicity</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e11413">18.1.1. Asynchronous methods</a></span></dt><dt><span class="sect2"><a href="#d0e11477">18.1.2. Asynchronous methods with the Quartz Dispatcher</a></span></dt><dt><span class="sect2"><a href="#d0e11549">18.1.3. Asynchronous events</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e11569">18.2. Messaging in Seam</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e11574">18.2.1. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e11618">18.2.2. Sending messages</a></span></dt><dt><span class="sect2"><a href="#d0e11635">18.2.3. Receiving messages using a message-driven bean</a></span></dt><dt><span class="sect2"><a href="#d0e11640">18.2.4. Receiving messages in the client</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#cache">19. Caching</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11692">19.1. Using JBossCache in Seam</a></span></dt><dt><span class="section"><a href="#d0e11738">19.2. Page fragment caching</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webservices">20. Web Services</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e11781">20.1. Configuration and Packaging</a></span></dt><dt><span class="sect1"><a href="#d0e11803">20.2. Conversational Web Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e11833">20.2.1. A Recommended Strategy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e11848">20.3. An example web service</a></span></dt></dl></dd><dt><span class="chapter"><a href="#remoting">21. Remoting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e11921">21.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#d0e11953">21.2. The "Seam" object</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e11970">21.2.1. A Hello World example</a></span></dt><dt><span class="sect2"><a href="#d0e12050">21.2.2. Seam.Component</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e12070">21.2.2.1. Seam.Component.newInstance()</a></span></dt><dt><span class="sect3"><a href="#d0e12085">21.2.2.2. Seam.Component.getInstance()</a></span></dt><dt><span class="sect3"><a href="#d0e12106">21.2.2.3. Seam.Component.getComponentName()</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e12116">21.2.3. Seam.Remoting</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e12124">21.2.3.1. Seam.Remoting.createType()</a></span></dt><dt><span class="sect3"><a href="#d0e12134">21.2.3.2. Seam.Remoting.getTypeName()</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e12145">21.3. Evaluating EL Expressions</a></span></dt><dt><span class="sect1"><a href="#d0e12174">21.4. Client Interfaces</a></span></dt><dt><span class="sect1"><a href="#d0e12196">21.5. The Context</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12201">21.5.1. Setting and reading the Conversation ID</a></span></dt><dt><span class="sect2"><a href="#d0e12217">21.5.2. Remote calls within the current conversation scope</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12224">21.6. Batch Requests</a></span></dt><dt><span class="sect1"><a href="#d0e12250">21.7. Working with Data types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12253">21.7.1. Primitives / Basic Types</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e12258">21.7.1.1. String</a></span></dt><dt><span class="sect3"><a href="#d0e12263">21.7.1.2. Number</a></span></dt><dt><span class="sect3"><a href="#d0e12286">21.7.1.3. Boolean</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e12291">21.7.2. JavaBeans</a></span></dt><dt><span class="sect2"><a href="#d0e12333">21.7.3. Dates and Times</a></span></dt><dt><span class="sect2"><a href="#d0e12347">21.7.4. Enums</a></span></dt><dt><span class="sect2"><a href="#d0e12366">21.7.5. Collections</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e12369">21.7.5.1. Bags</a></span></dt><dt><span class="sect3"><a href="#d0e12374">21.7.5.2. Maps</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e12416">21.8. Debugging</a></span></dt><dt><span class="sect1"><a href="#d0e12438">21.9. The Loading Message</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12443">21.9.1. Changing the message</a></span></dt><dt><span class="sect2"><a href="#d0e12453">21.9.2. Hiding the loading message</a></span></dt><dt><span class="sect2"><a href="#d0e12466">21.9.3. A Custom Loading Indicator</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12479">21.10. Controlling what data is returned</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12499">21.10.1. Constraining normal fields</a></span></dt><dt><span class="sect2"><a href="#d0e12534">21.10.2. Constraining Maps and Collections</a></span></dt><dt><span class="sect2"><a href="#d0e12593">21.10.3. Constraining objects of a specific type</a></span></dt><dt><span class="sect2"><a href="#d0e12600">21.10.4. Combining Constraints</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12607">21.11. JMS Messaging</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12612">21.11.1. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e12631">21.11.2. Subscribing to a JMS Topic</a></span></dt><dt><span class="sect2"><a href="#d0e12672">21.11.3. Unsubscribing from a Topic</a></span></dt><dt><span class="sect2"><a href="#d0e12682">21.11.4. Tuning the Polling Process</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gwt">22. Seam and the Google Web Toolkit</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e12720">22.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#d0e12727">22.2. Preparing your component</a></span></dt><dt><span class="sect1"><a href="#d0e12758">22.3. Hooking up a GWT widget to the Seam component</a></span></dt><dt><span class="sect1"><a href="#d0e12793">22.4. GWT Ant Targets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring">23. Spring Framework integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12868">23.1. Injecting Seam components into Spring beans</a></span></dt><dt><span class="section"><a href="#d0e12915">23.2. Injecting Spring beans into Seam components</a></span></dt><dt><span class="section"><a href="#d0e12954">23.3. Making a Spring bean into a Seam component</a></span></dt><dt><span class="section"><a href="#d0e12995">23.4. Seam-scoped Spring beans</a></span></dt><dt><span class="section"><a href="#spring-transactions">23.5. Using Spring PlatformTransactionManagement</a></span></dt><dt><span class="section"><a href="#spring-persistence">23.6. Using a Seam Managed Persistence Context in Spring</a></span></dt><dt><span class="section"><a href="#spring-hibernate">23.7. Using a Seam Managed Hibernate Session in Spring</a></span></dt><dt><span class="section"><a href="#d0e13157">23.8. Spring Application Context as a Seam Component</a></span></dt><dt><span class="section"><a href="#d0e13197">23.9. Using a Spring TaskExecutor for @Asynchronous</a></span></dt></dl></dd><dt><span class="chapter"><a href="#search">24. Hibernate Search</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13229">24.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e13241">24.2. Configuration</a></span></dt><dt><span class="section"><a href="#d0e13286">24.3. Usage</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">25. Configuring Seam and packaging Seam applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e13374">25.1. Basic Seam configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13379">25.1.1. Integrating Seam with JSF and your servlet container</a></span></dt><dt><span class="sect2"><a href="#d0e13404">25.1.2. Using facelets</a></span></dt><dt><span class="sect2"><a href="#d0e13421">25.1.3. Seam Resource Servlet</a></span></dt><dt><span class="sect2"><a href="#d0e13431">25.1.4. Seam servlet filters</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e13456">25.1.4.1. Exception handling</a></span></dt><dt><span class="sect3"><a href="#d0e13481">25.1.4.2. Conversation propagation with redirects</a></span></dt><dt><span class="sect3"><a href="#d0e13500">25.1.4.3. Multipart form submissions</a></span></dt><dt><span class="sect3"><a href="#d0e13538">25.1.4.4. Character encoding</a></span></dt><dt><span class="sect3"><a href="#d0e13581">25.1.4.5. RichFaces</a></span></dt><dt><span class="sect3"><a href="#d0e13632">25.1.4.6. Identity Logging</a></span></dt><dt><span class="sect3"><a href="#d0e13654">25.1.4.7. Context management for custom servlets</a></span></dt><dt><span class="sect3"><a href="#d0e13691">25.1.4.8. Adding custom filters</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e13721">25.1.5. Integrating Seam with your EJB container</a></span></dt><dt><span class="sect2"><a href="#d0e13767">25.1.6. Don't forget!</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e13802">25.2. Configuring Seam in Java EE 5</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13812">25.2.1. Packaging</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e13869">25.3. Configuring Seam in J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13892">25.3.1. Boostrapping Hibernate in Seam</a></span></dt><dt><span class="sect2"><a href="#d0e13915">25.3.2. Boostrapping JPA in Seam</a></span></dt><dt><span class="sect2"><a href="#d0e13938">25.3.3. Packaging</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e13947">25.4. Configuring Seam in Java SE, without JBoss Embedded</a></span></dt><dt><span class="sect1"><a href="#d0e13965">25.5. Configuring Seam in Java SE, with JBoss Embedded</a></span></dt><dd><dl><dt><span class="sect2"><a href="#config.install.embedded">25.5.1. Installing Embedded JBoss</a></span></dt><dt><span class="sect2"><a href="#d0e14044">25.5.2. Packaging</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e14056">25.6. Configuring jBPM in Seam</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e14078">25.6.1. Packaging</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e14085">25.7. Configuring Seam in a Portal</a></span></dt><dt><span class="sect1"><a href="#d0e14096">25.8. Configuring SFSB and Session Timeouts in JBoss AS</a></span></dt></dl></dd><dt><span class="chapter"><a href="#oc4j">26. Seam on OC4J</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14142">26.1. The jee5/booking example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14153">26.1.1. Booking Example Dependencies</a></span></dt><dt><span class="section"><a href="#d0e14204">26.1.2. Extra dependencies required by OC4J</a></span></dt><dt><span class="section"><a href="#d0e14273">26.1.3. Configuration file changes</a></span></dt><dt><span class="section"><a href="#d0e14304">26.1.4. Building the jee5/booking example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14345">26.2. Deploying a Seam application to OC4J</a></span></dt><dt><span class="section"><a href="#d0e14449">26.3. 
        Deploying an application created using seam-gen
        to OC4J
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14744">26.3.1. OC4J Deployment Descriptors for the seam-gen'd application</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#annotations">27. Seam annotations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14787">27.1. Annotations for component definition</a></span></dt><dt><span class="section"><a href="#d0e15023">27.2. Annotations for bijection</a></span></dt><dt><span class="section"><a href="#d0e15243">27.3. Annotations for component lifecycle methods</a></span></dt><dt><span class="section"><a href="#d0e15291">27.4. Annotations for context demarcation</a></span></dt><dt><span class="section"><a href="#d0e15607">27.5. Annotations for use with Seam JavaBean components in a J2EE environment</a></span></dt><dt><span class="section"><a href="#d0e15657">27.6. Annotations for exceptions</a></span></dt><dt><span class="section"><a href="#d0e15732">27.7. Annotations for Seam Remoting</a></span></dt><dt><span class="section"><a href="#d0e15752">27.8. Annotations for Seam interceptors</a></span></dt><dt><span class="section"><a href="#d0e15786">27.9. Annotations for asynchronicity</a></span></dt><dt><span class="section"><a href="#d0e15840">27.10. Annotations for use with JSF</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15890">27.10.1. Annotations for use with dataTable</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16044">27.11. Meta-annotations for databinding</a></span></dt><dt><span class="section"><a href="#d0e16078">27.12. Annotations for packaging</a></span></dt><dt><span class="section"><a href="#d0e16108">27.13. Annotations for integrating with the servlet container</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">28. Built-in Seam components</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16164">28.1. Context injection components</a></span></dt><dt><span class="section"><a href="#d0e16194">28.2. Utility components</a></span></dt><dt><span class="section"><a href="#d0e16389">28.3. Components for internationalization and themes</a></span></dt><dt><span class="section"><a href="#d0e16590">28.4. Components for controlling conversations</a></span></dt><dt><span class="section"><a href="#d0e16738">28.5. jBPM-related components</a></span></dt><dt><span class="section"><a href="#d0e16967">28.6. Security-related components</a></span></dt><dt><span class="section"><a href="#d0e16993">28.7. JMS-related components</a></span></dt><dt><span class="section"><a href="#components.mail">28.8. Mail-related components</a></span></dt><dt><span class="section"><a href="#d0e17095">28.9. Infrastructural components</a></span></dt><dt><span class="section"><a href="#d0e17388">28.10. Miscellaneous components</a></span></dt><dt><span class="section"><a href="#d0e17425">28.11. Special components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#controls">29. Seam JSF controls</a></span></dt><dd><dl><dt><span class="section"><a href="#controls.tags">29.1. Tags</a></span></dt><dt><span class="section"><a href="#controls.annotations">29.2. Annotations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#elenhancements">30. Expression language enhancements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19150">30.1. Parameterized Method Bindings</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19160">30.1.1. Usage</a></span></dt><dt><span class="section"><a href="#d0e19215">30.1.2. Limitations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19220">30.1.2.1. Incompatibility with JSP 2.1</a></span></dt><dt><span class="section"><a href="#d0e19225">30.1.2.2. Calling a MethodExpression from Java code</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e19263">30.2. Parameterized Value Bindings</a></span></dt><dt><span class="section"><a href="#d0e19292">30.3. Projection</a></span></dt></dl></dd><dt><span class="chapter"><a href="#testing">31. Testing Seam applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19342">31.1. Unit testing Seam components</a></span></dt><dt><span class="section"><a href="#d0e19362">31.2. Integration testing Seam components</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19371">31.2.1. Using mocks in integration tests</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e19387">31.3. Integration testing Seam application user interactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19428">31.3.1. Integration Testing with Mock Data</a></span></dt><dt><span class="section"><a href="#testing.mail">31.3.2. Integration Testing Seam Mail</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#tools">32. Seam tools</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19495">32.1. jBPM designer and viewer</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19500">32.1.1. Business process designer</a></span></dt><dt><span class="section"><a href="#d0e19513">32.1.2. Pageflow viewer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#dependencies">33. Dependencies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19530">33.1. Project Dependencies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19549">33.1.1. Core</a></span></dt><dt><span class="section"><a href="#d0e19753">33.1.2. RichFaces</a></span></dt><dt><span class="section"><a href="#d0e19821">33.1.3. Seam Mail</a></span></dt><dt><span class="section"><a href="#d0e19904">33.1.4. Seam PDF</a></span></dt><dt><span class="section"><a href="#d0e19986">33.1.5. JBoss Rules</a></span></dt><dt><span class="section"><a href="#d0e20097">33.1.6. JBPM</a></span></dt><dt><span class="section"><a href="#d0e20136">33.1.7. GWT</a></span></dt><dt><span class="section"><a href="#d0e20178">33.1.8. Spring</a></span></dt><dt><span class="section"><a href="#d0e20220">33.1.9. Groovy</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e20262">33.2. Dependency Management using Maven</a></span></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e10"></a>Introduction to JBoss Seam</h2></div></div><div></div></div><p>
            Seam is an application framework for Enterprise Java. It is inspired by the following principles:
        </p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>One kind of "stuff"</em></span></span></dt><dd><p>
                        Seam defines a uniform component model for all business logic in your application. 
                        A Seam component may be stateful, with the state associated with any one of several
                        well-defined contexts, including the long-running, persistent, <span class="emphasis"><em>business process 
                        context</em></span> and the <span class="emphasis"><em>conversation context</em></span>, which is
                        preserved across multiple web requests in a user interaction.
                    </p><p>
                        There is no distinction between presentation tier components and business logic
                        components in Seam. You can layer your application according to whatever architecture
                        you devise, rather than being forced to shoehorn your application logic into an
                        unnatural layering scheme forced upon you by whatever combination of stovepipe 
                        frameworks you're using today.
                    </p><p>
                        Unlike plain Java EE or J2EE components, Seam components may <span class="emphasis"><em>simultaneously</em></span>
                        access state associated with the web request and state held in transactional resources (without
                        the need to propagate web request state manually via method parameters). You might object
                        that the application layering imposed upon you by the old J2EE platform was a Good Thing.
                        Well, nothing stops you creating an equivalent layered architecture using Seam&#8212;the difference
                        is that <span class="emphasis"><em>you</em></span> get to architect your own application and decide what the
                        layers are and how they work together.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Integrate JSF with EJB 3.0</em></span></span></dt><dd><p>
                        JSF and EJB 3.0 are two of the best new features of Java EE 5. EJB3 is a brand new
                        component model for server side business and persistence logic. Meanwhile, JSF is a
                        great component model for the presentation tier. Unfortunately, neither component
                        model is able to solve all problems in computing by itself. Indeed, JSF and EJB3
                        work best used together. But the Java EE 5 specification provides no standard way
                        to integrate the two component models. Fortunately, the creators of both models
                        foresaw this situation and provided standard extension points to allow extension
                        and integration with other frameworks.
                    </p><p>
                        Seam unifies the component models of JSF and EJB3, eliminating glue code, and letting
                        the developer think about the business problem.
                    </p><p>
                        It is possible to write Seam applications where "everything" is an EJB. This may come 
                        as a surprise if you're used to thinking of EJBs as coarse-grained, so-called 
                        "heavyweight" objects. However, version 3.0 has completely changed the nature of EJB 
                        from the point of view of the developer. An EJB is a fine-grained object&#8212;nothing 
                        more complex than an annotated JavaBean. Seam even encourages you to use session beans 
                        as JSF action listeners!                    
                    </p><p>
                        On the other hand, if you prefer not to adopt EJB 3.0 at this time, you don't have to.
                        Virtually any Java class may be a Seam component, and Seam provides all the functionality
                        that you expect from a "lightweight" container, and more, for any component, EJB or 
                        otherwise.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Integrated AJAX</em></span></span></dt><dd><p>
                        Seam supports the best open source JSF-based AJAX solutions: JBoss RichFaces and 
                        ICEfaces. These solutions let you add AJAX capability to your user interface without 
                        the need to write any JavaScript code.
                    </p><p>
                        Alternatively, Seam provides a built-in JavaScript remoting layer that lets you call 
                        components asynchronously from client-side JavaScript without the need for an intermediate 
                        action layer. You can ever subscribe to server-side JMS topics and receive messages via AJAX
                        push.
                    </p><p>
                        Neither of these approaches would work well, were it not for Seam's built-in concurrency 
                        and state management, which ensures that many concurrent fine-grained, asynchronous AJAX 
                        requests are handled safely and efficiently on the server side.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Business process as a first class construct</em></span></span></dt><dd><p>
                        Optionally, Seam provides transparent business process management via jBPM. You won't 
                        believe how easy it is to implement complex workflows, collaboration and and task management 
                        using jBPM and Seam.
                    </p><p>
                        Seam even allows you to define presentation tier pageflow using the same language (jPDL)
                        that jBPM uses for business process definition.
                    </p><p>
                        JSF provides an incredibly rich event model for the presentation tier. Seam enhances this
                        model by exposing jBPM's business process related events via exactly the same event handling
                        mechanism, providing a uniform event model for Seam's uniform component model.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Declarative state management</em></span></span></dt><dd><p>
                        We're all used to the concept of declarative transaction management and declarative
                        security from the early days of EJB. EJB 3.0 even introduces declarative persistence context
                        management. These are three examples of a broader problem of managing state that is
                        associated with a particular <span class="emphasis"><em>context</em></span>, while ensuring that all needed
                        cleanup occurs when the context ends. Seam takes the concept of declarative state
                        management much further and applies it to <span class="emphasis"><em>application state</em></span>.
                        Traditionally, J2EE applications implement state management manually, by getting
                        and setting servlet session and request attributes. This approach to state management is the
                        source of many bugs and memory leaks when applications fail to clean up session attributes,
                        or when session data associated with different workflows collides in a multi-window
                        application. Seam has the potential to almost entirely eliminate this class of bugs.
                    </p><p>
                        Declarative application state management is made possible by the richness of the
                        <span class="emphasis"><em>context model</em></span> defined by Seam. Seam extends the context model defined 
                        by the servlet spec&#8212;request, session, application&#8212;with two new
                        contexts&#8212;conversation and business process&#8212;that are more meaningful from the
                        point of view of the business logic.
                    </p><p>
                        You'll be amazed at how many things become easier once you start using conversations.
                        Have you ever suffered pain dealing with lazy association fetching in an ORM solution
                        like Hibernate or JPA? Seam's conversation-scoped persistence contexts mean you'll
                        rarely have to see a <tt class="literal">LazyInitializationException</tt>. Have you ever
                        had problems with the refresh button? The back button? With duplicate form submission?
                        With propagating messages across a post-then-redirect? Seam's conversation management 
                        solves these problems without you even needing to really think about them. They're all
                        symptoms of the broken state management architecture has been prevalent since the 
                        earliest days of the web.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Bijection</em></span></span></dt><dd><p>
                        The notion of <span class="emphasis"><em>Inversion of Control</em></span> or <span class="emphasis"><em>dependency injection</em></span>
                        exists in both JSF and EJB3, as well as in numerous so-called "lightweight containers". Most of
                        these containers emphasize injection of components that implement <span class="emphasis"><em>stateless services</em></span>.
                        Even when injection of stateful components is supported (such as in JSF), it is virtually useless
                        for handling application state because the scope of the stateful component cannot be defined with
                        sufficient flexibility, and because components belonging to wider scopes may not be injected into 
                        components belonging to narrower scopes.
                    </p><p>
                        <span class="emphasis"><em>Bijection</em></span> differs from IoC in that it is <span class="emphasis"><em>dynamic</em></span>, 
                        <span class="emphasis"><em>contextual</em></span>, and <span class="emphasis"><em>bidirectional</em></span>.
                        You can think of it as a mechanism for aliasing contextual variables (names in the various contexts
                        bound to the current thread) to attributes of the component. Bijection allows auto-assembly of stateful
                        components by the container. It even allows a component to safely and easily manipulate the
                        value of a context variable, just by assigning to an attribute of the component.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Workspace management and multi-window browsing</em></span></span></dt><dd><p>
                        Seam applications let the user freely switch between multiple browser tabs, each associated with a
                        different, safely isolated, conversation. Applications may even take advantage of <span class="emphasis"><em>workspace 
                        management</em></span>, allowing the user to switch between conversations (workspaces) in a single
                        browser tab. Seam provides not only correct multi-window operation, but also multi-window-like
                        operation in a single window!
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Prefer annotations to XML</em></span></span></dt><dd><p>
                        Traditionally, the Java community has been in a state of deep confusion about precisely 
                        what kinds of meta-information counts as configuration. J2EE and popular "lightweight"
                        containers have provided XML-based deployment descriptors both for things which are
                        truly configurable between different deployments of the system, and for any other kinds
                        or declaration which can not easily be expressed in Java. Java 5 annotations changed
                        all this.
                    </p><p>
                        EJB 3.0 embraces annotations and "configuration by exception" as the easiest way to provide
                        information to the container in a declarative form. Unfortunately, JSF is still heavily
                        dependent on verbose XML configuration files. Seam extends the annotations provided by
                        EJB 3.0 with a set of annotations for declarative state management and declarative
                        context demarcation. This lets you eliminate the noisy JSF managed bean declarations
                        and reduce the required XML to just that information which truly belongs in XML
                        (the JSF navigation rules).
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Integration testing is easy</em></span></span></dt><dd><p>
                        Seam components, being plain Java classes, are by nature unit testable. But for complex applications,
                        unit testing alone is insufficient. Integration testing has traditionally been a messy and
                        difficult task for Java web applications. Therefore, Seam provides for testability of Seam
                        applications as a core feature of the framework. You can easily write JUnit or TestNG tests
                        that reproduce a whole interaction with a user, exercising all components of the system
                        apart from the view (the JSP or Facelets page). You can run these tests directly inside your
                        IDE, where Seam will automatically deploy EJB components using JBoss Embedded.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>The specs ain't perfect</em></span></span></dt><dd><p>
                        We think the latest incarnation of Java EE is great. But we know it's never going to be 
                        perfect. Where there are holes in the specifications (for example, limitations in the
                        JSF lifecycle for GET requests), Seam fixes them. And the authors of Seam are working
                        with the JCP expert groups to make sure those fixes make their way back into the next
                        revision of the standards.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>There's more to a web application than serving HTML pages</em></span></span></dt><dd><p>
                        Today's web frameworks think too small. They let you get user input off a form and
                        into your Java objects. And then they leave you hanging. A truly complete web application
                        framework should address problems like persistence, concurrency, asynchronicity, state 
                        management, security, email, messaging, PDF and chart generation, workflow, wikitext
                        rendering, webservices, caching and more. Once you scratch the surface of Seam, you'll
                        be amazed at how many problems become simpler...
                    </p><p>
                        Seam integrates JPA and Hibernate3 for persistence, the EJB Timer Service and Quartz 
                        for lightweight asychronicity, jBPM for workflow, JBoss Rules for business rules, Meldware 
                        Mail for email, Hibernate Search and Lucene for full text search, JMS for messaging and JBoss 
                        Cache for page fragment caching. Seam layers an innovative rule-based security framework over
                        JAAS and JBoss Rules. There's even JSF tag libraries for rendering PDF, outgoing email, charts 
                        and wikitext. Seam components may be called synchronously as a Web Service, asynchronously 
                        from client-side JavaScript or Google Web Toolkit or, of course, directly from JSF.
                    </p></dd><dt><span class="term"><span class="emphasis"><em>Get started now!</em></span></span></dt><dd><p>
                        Seam works in any Java EE application server, and even works in Tomcat. If your environment
                        supports EJB 3.0, great! If it doesn't, no problem, you can use Seam's built-in transaction
                        management with JPA or Hibernate3 for persistence. Or, you can deploy JBoss Embedded in
                        Tomcat, and get full support for EJB 3.0.
                    </p></dd></dl></div><div class="mediaobject" align="center"><img src="../shared/images/architecture.png" align="middle"></div><p>
            It turns out that the combination of Seam, JSF and EJB3 is <span class="emphasis"><em>the</em></span> simplest way
            to write a complex web application in Java. You won't believe how little code is required!
        </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial"></a>Chapter&nbsp;1.&nbsp;Seam Tutorial</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="try-examples"></a>1.1.&nbsp;Try the examples</h2></div></div><div></div></div><p> In this tutorial, we'll assume that you have downloaded JBoss AS 4.2.0. You should also have a copy of
            Seam downloaded and extracted to a work directory. </p><p> The directory structure of each example in Seam follows this pattern: </p><div class="itemizedlist"><ul type="disc"><li><p> Web pages, images and stylesheets may be found in
                        <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/view</tt>
                </p></li><li><p> Resources such as deployment descriptors and data import scripts may be found in
                            <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/resources</tt>
                </p></li><li><p> Java source code may be found in
                    <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/src</tt>
                </p></li><li><p> The Ant build script is
                    <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i>/build.xml</tt>
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e233"></a>1.1.1.&nbsp;Running the examples on JBoss AS</h3></div></div><div></div></div><p> First, make sure you have Ant correctly installed, with <tt class="literal">$ANT_HOME</tt> and
                    <tt class="literal">$JAVA_HOME</tt> set correctly. Next, make sure you set the location of your JBoss AS
                4.2.0 installation in the <tt class="literal">build.properties</tt> file in the root folder of your Seam
                installation. If you haven't already done so, start JBoss AS now by typing <tt class="literal">bin/run.sh</tt>
                or <tt class="literal">bin/run.bat</tt> in the root directory of your JBoss installation. </p><p> Now, build and deploy the example by typing <tt class="literal">ant deploy</tt> in the
                        <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory. </p><p> Try it out by accessing <a href="http://localhost:8080/seam-registration/" target="_top">
                    <tt class="literal">http://localhost:8080/seam-registration/</tt>
                </a> with your web browser. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e271"></a>1.1.2.&nbsp;Running the examples on Tomcat</h3></div></div><div></div></div><p> 
                First, make sure you have Ant correctly installed, with <tt class="literal">$ANT_HOME</tt> and
                <tt class="literal">$JAVA_HOME</tt> set correctly. Next, make sure you set the location of your Tomcat 
                6.0 installation in the <tt class="literal">build.properties</tt> file in the root folder of your Seam
                installation.  You will need to follow the instructions in <a href="#config.install.embedded" title="25.5.1.&nbsp;Installing Embedded JBoss">Section&nbsp;25.5.1, &#8220;Installing Embedded JBoss&#8221;</a>
                for installing JBoss Embedded on Tomcat 6.0.  JBoss Embedded is required to run the Seam demo
                applications on Tomcat. (However, it is possible to use Seam on Tomcat without JBoss Embedded.)
            </p><p> 
                Now, build and deploy the example by typing <tt class="literal">ant tomcat.deploy</tt> in the
                <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory.
            </p><p>Finally, start Tomcat.</p><p>
                Try it out by accessing <a href="http://localhost:8080/jboss-seam-registration/" target="_top">
                <tt class="literal">http://localhost:8080/jboss-seam-registration/</tt>
                </a> with your web browser.
            </p><p>
                When you deploy the example to Tomcat, any EJB3 components will run inside the JBoss Embeddable EJB3
                container, a complete standalone EJB3 container environment.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e309"></a>1.1.3.&nbsp;Running the example tests</h3></div></div><div></div></div><p> 
                Most of the examples come with a suite of TestNG integration tests. The easiest way to run the tests
                is to run <tt class="literal">ant testexample</tt> inside the
                <tt class="filename">examples/<i class="replaceable"><tt>registration</tt></i></tt> directory. It is also possible
                to run the tests inside your IDE using the TestNG plugin.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="registration-example"></a>1.2.&nbsp;Your first Seam application: the registration example</h2></div></div><div></div></div><p> The registration example is a fairly trivial application that lets a new user store his username, real
            name and password in the database. The example isn't intended to show off all of the cool functionality of
            Seam. However, it demonstrates the use of an EJB3 session bean as a JSF action listener, and basic
            configuration of Seam. </p><p> We'll go slowly, since we realize you might not yet be familiar with EJB 3.0. </p><p> The start page displays a very basic form with three input fields. Try filling them in and then
            submitting the form. This will save a user object in the database. </p><div class="mediaobject" align="center"><img src="../shared/images/registration.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e336"></a>1.2.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The example is implemented with two JSP pages, one entity bean and one stateless session bean. </p><div class="mediaobject" align="center"><img src="../shared/images/register.png" align="middle"></div><p> Let's take a look at the code, starting from the "bottom". </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e348"></a>1.2.1.1.&nbsp;The entity bean: <tt class="literal">User.java</tt></h4></div></div><div></div></div><p> We need an EJB entity bean for user data. This class defines <span class="emphasis"><em>persistence</em></span> and
                        <span class="emphasis"><em>validation</em></span> declaratively, via annotations. It also needs some extra
                    annotations that define the class as a Seam component. </p><div class="example"><a name="d0e361"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Entity                                                                                  <span class="co">(1)</span>
@Name("user")                                                                            <span class="co">(2)</span>
@Scope(SESSION)                                                                          <span class="co">(3)</span>
@Table(name="users")                                                                     <span class="co">(4)</span>
public class User implements Serializable
{
   private static final long serialVersionUID = 1881413500711441951L;
   
   private String username;                                                              <span class="co">(5)</span>
   private String password;
   private String name;
   
   public User(String name, String password, String username)
   {
      this.name = name;
      this.password = password;
      this.username = username;
   }
   
   public User() {}                                                                      <span class="co">(6)</span>
   
   @NotNull @Length(min=5, max=15)                                                       <span class="co">(7)</span>
   public String getPassword()
   {
      return password;
   }

   public void setPassword(String password)
   {
      this.password = password;
   }
   
   @NotNull
   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
   
   @Id @NotNull @Length(min=5, max=15)                                                   <span class="co">(8)</span>
   public String getUsername()
   {
      return username;
   }

   public void setUsername(String username)
   {
      this.username = username;
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB3 standard <tt class="literal">@Entity</tt> annotation indicates that the
                                        <tt class="literal">User</tt> class is an entity bean. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> A Seam component needs a <span class="emphasis"><em>component name</em></span> specified by the
                                        <a href="#name-annotation">
                                        <tt class="literal">@Name</tt>
                                    </a> annotation. This name must be unique within the Seam application. When JSF
                                    asks Seam to resolve a context variable with a name that is the same as a Seam
                                    component name, and the context variable is currently undefined (null), Seam will
                                    instantiate that component, and bind the new instance to the context variable. In
                                    this case, Seam will instantiate a <tt class="literal">User</tt> the first time JSF
                                    encounters a variable named <tt class="literal">user</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> Whenever Seam instantiates a component, it binds the new instance to a context
                                    variable in the component's <span class="emphasis"><em>default context</em></span>. The default
                                    context is specified using the <a href="#scope-annotation">
                                        <tt class="literal">@Scope</tt>
                                    </a> annotation. The <tt class="literal">User</tt> bean is a session scoped component.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Table</tt> annotation indicates that the
                                        <tt class="literal">User</tt> class is mapped to the <tt class="literal">users</tt> table.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                                    <tt class="literal">name</tt>, <tt class="literal">password</tt> and <tt class="literal">username</tt>
                                    are the persistent attributes of the entity bean. All of our persistent attributes
                                    define accessor methods. These are needed when this component is used by JSF in the
                                    render response and update model values phases. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> An empty constructor is both required by both the EJB specification and by Seam.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">@NotNull</tt> and <tt class="literal">@Length</tt> annotations are
                                    part of the Hibernate Validator framework. Seam integrates Hibernate Validator and
                                    lets you use it for data validation (even if you are not using Hibernate for
                                    persistence). </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Id</tt> annotation indicates the primary key
                                    attribute of the entity bean. </p></td></tr></table></div></div><p> The most important things to notice in this example are the <tt class="literal">@Name</tt> and
                            <tt class="literal">@Scope</tt> annotations. These annotations establish that this class is a Seam
                        component. </p><p> We'll see below that the properties of our <tt class="literal">User</tt> class are bound to
                        directly to JSF components and are populated by JSF during the update model values phase. We
                        don't need any tedious glue code to copy data back and forth between the JSP pages and the
                        entity bean domain model. </p><p> However, entity beans shouldn't do transaction management or database access. So we can't use
                        this component as a JSF action listener. For that we need a session bean. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e474"></a>1.2.1.2.&nbsp;The stateless session bean class: <tt class="literal">RegisterAction.java</tt></h4></div></div><div></div></div><p> Most Seam application use session beans as JSF action listeners (you can use JavaBeans instead if
                    you like). </p><p> We have exactly one JSF action in our application, and one session bean method attached to it. In
                    this case, we'll use a stateless session bean, since all the state associated with our action is
                    held by the <tt class="literal">User</tt> bean. </p><p> This is the only really interesting code in the example! </p><div class="example"><a name="d0e488"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateless                                                                               <span class="co">(1)</span>
@Name("register")
public class RegisterAction implements Register
{

   @In                                                                                   <span class="co">(2)</span>
   private User user;
   
   @PersistenceContext                                                                   <span class="co">(3)</span>
   private EntityManager em;
   
   @Logger                                                                               <span class="co">(4)</span>
   private Log log;
   
   public String register()                                                              <span class="co">(5)</span>
   {
      List existing = em.createQuery(
         "select username from User where username=#{user.username}")                    <span class="co">(6)</span>
         .getResultList();
         
      if (existing.size()==0)
      {
         em.persist(user);
         log.info("Registered new user #{user.username}");                               <span class="co">(7)</span>
         return "/registered.xhtml";                                                     <span class="co">(8)</span>
      }
      else
      {
         FacesMessages.instance().add("User #{user.username} already exists");           <span class="co">(9)</span>
         return null;
      }
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Stateless</tt> annotation marks this class as
                                    stateless session bean. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <a href="#in-annotation">
                                        <tt class="literal">@In</tt>
                                    </a> annotation marks an attribute of the bean as injected by Seam. In this case,
                                    the attribute is injected from a context variable named <tt class="literal">user</tt> (the
                                    instance variable name). </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@PersistenceContext</tt> annotation is used to
                                    inject the EJB3 entity manager. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@Logger</tt> annotation is used to inject the component's
                                        <tt class="literal">Log</tt> instance. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The action listener method uses the standard EJB3
                                    <tt class="literal">EntityManager</tt> API to interact with the database, and returns the
                                    JSF outcome. Note that, since this is a sesson bean, a transaction is automatically
                                    begun when the <tt class="literal">register()</tt> method is called, and committed when it
                                    completes. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> Notice that Seam lets you use a JSF EL expression inside EJB-QL. Under the
                                    covers, this results in an ordinary JPA <tt class="literal">setParameter()</tt> call on
                                    the standard JPA <tt class="literal">Query</tt> object. Nice, huh? </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">Log</tt> API lets us easily display templated log messages.
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> JSF action listener methods return a string-valued outcome that determines what
                                    page will be displayed next. A null outcome (or a void action listener method)
                                    redisplays the previous page. In plain JSF, it is normal to always use a JSF
                                        <span class="emphasis"><em>navigation rule</em></span> to determine the JSF view id from the
                                    outcome. For complex application this indirection is useful and a good practice.
                                    However, for very simple examples like this one, Seam lets you use the JSF view id
                                    as the outcome, eliminating the requirement for a navigation rule. <span class="emphasis"><em>Note
                                        that when you use a view id as an outcome, Seam always performs a browser
                                        redirect.</em></span>
                                </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p> Seam provides a number of <span class="emphasis"><em>built-in components</em></span> to help solve
                                    common problems. The <tt class="literal">FacesMessages</tt> component makes it easy to
                                    display templated error or success messages. Built-in Seam components may be
                                    obtained by injection, or by calling an <tt class="literal">instance()</tt> method.
                                </p></td></tr></table></div></div><p> Note that we did not explicitly specify a <tt class="literal">@Scope</tt> this time. Each Seam
                        component type has a default scope if not explicitly specified. For stateless session beans, the
                        default scope is the stateless context. Actually, <span class="emphasis"><em>all</em></span> stateless session
                        beans belong in the stateless context. </p><p> Our session bean action listener performs the business and persistence logic for our
                        mini-application. In more complex applications, we might need to layer the code and refactor
                        persistence logic into a dedicated data access component. That's perfectly trivial to do. But
                        notice that Seam does not force you into any particular strategy for application layering. </p><p> Furthermore, notice that our session bean has simultaneous access to context associated with
                        the web request (the form values in the <tt class="literal">User</tt> object, for example), and state
                        held in transactional resources (the <tt class="literal">EntityManager</tt> object). This is a break
                        from traditional J2EE architectures. Again, if you are more comfortable with the traditional
                        J2EE layering, you can certainly implement that in a Seam application. But for many
                        applications, it's simply not very useful. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e599"></a>1.2.1.3.&nbsp;The session bean local interface: <tt class="literal">Register.java</tt></h4></div></div><div></div></div><p>Naturally, our session bean needs a local interface.</p><div class="example"><a name="d0e606"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;</b></p><pre class="programlisting">@Local
public interface Register
{
   public String register();
}</pre></div><p> That's the end of the Java code. Now onto the deployment descriptors. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e611"></a>1.2.1.4.&nbsp;The Seam component deployment descriptor: <tt class="literal">components.xml</tt></h4></div></div><div></div></div><p> If you've used many Java frameworks before, you'll be used to having to declare all your
                    component classes in some kind of XML file that gradually grows more and more unmanageable as your
                    project matures. You'll be relieved to know that Seam does not require that application components
                    be accompanied by XML. Most Seam applications require a very small amount of XML that does not grow
                    very much as the project gets bigger. </p><p> Nevertheless, it is often useful to be able to provide for <span class="emphasis"><em>some</em></span> external
                    configuration of <span class="emphasis"><em>some</em></span> components (particularly the components built in to
                    Seam). You have a couple of options here, but the most flexible option is to provide this
                    configuration in a file called <tt class="literal">components.xml</tt>, located in the
                    <tt class="literal">WEB-INF</tt> directory. We'll use the <tt class="literal">components.xml</tt> file to tell
                    Seam how to find our EJB components in JNDI: </p><div class="example"><a name="d0e635"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/core http://jboss.com/products/seam/core-2.0.xsd 
                 http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd"&gt;
            
     &lt;core:init jndi-pattern="@jndiPattern@"/&gt;
     
&lt;/components&gt;</pre></div><p> This code configures a property named <tt class="literal">jndiPattern</tt> of a built-in Seam component
                    named <tt class="literal">org.jboss.seam.core.init</tt>. The funny <tt class="literal">@</tt> symbols are
                    there because our Ant build script puts the correct JNDI pattern in when we deploy the application.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e649"></a>1.2.1.5.&nbsp;The web deployment description: <tt class="literal">web.xml</tt></h4></div></div><div></div></div><p> The presentation layer for our mini-application will be deployed in a WAR. So we'll need a web
                    deployment descriptor. </p><div class="example"><a name="d0e656"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5"
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;!-- Seam --&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.jboss.seam.servlet.SeamListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- JSF --&gt;
              
    &lt;listener&gt;
        &lt;listener-class&gt;com.sun.faces.config.ConfigureListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    
    &lt;context-param&gt;
        &lt;param-name&gt;javax.faces.DEFAULT_SUFFIX&lt;/param-name&gt;
        &lt;param-value&gt;.xhtml&lt;/param-value&gt;
    &lt;/context-param&gt;
              
    &lt;servlet&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
              
    &lt;session-config&gt;
        &lt;session-timeout&gt;10&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;</pre></div><p> This <tt class="literal">web.xml</tt> file configures Seam and JSF. The configuration you see here is
                    pretty much identical in all Seam applications. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e664"></a>1.2.1.6.&nbsp;The JSF configration: <tt class="literal">faces-config.xml</tt></h4></div></div><div></div></div><p> Most Seam applications use JSF views as the presentation layer. So usually we'll need
                        <tt class="literal">faces-config.xml</tt>. In our case, we are going to use Facelets for
                        defining our views, so we need to tell JSF to use Facelets as its templating engine. </p><div class="example"><a name="registration-faces-config-xml"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;faces-config version="1.2"
              xmlns="http://java.sun.com/xml/ns/javaee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd"&gt;

    &lt;!-- Facelets support --&gt;
    &lt;application&gt;
        &lt;view-handler&gt;com.sun.facelets.FaceletViewHandler&lt;/view-handler&gt;
    &lt;/application&gt;
    
&lt;/faces-config&gt;</pre></div><p> Note that we don't need
                    any JSF managed bean declarations! Our managed beans are annotated Seam components. In Seam applications,
                    the <tt class="literal">faces-config.xml</tt> is used much less often than in plain JSF. </p><p> In fact, once you have all the basic descriptors set up, the <span class="emphasis"><em>only</em></span> XML you
                    need to write as you add new functionality to a Seam application is orchestration: navigation rules 
                    or jBPM process definitions. Seam takes the view that <span class="emphasis"><em>process flow</em></span> and
                        <span class="emphasis"><em>configuration data</em></span> are the only things that truly belong in XML. </p><p> In this simple example, we don't even need a navigation rule, since we decided to embed the view
                    id in our action code. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e695"></a>1.2.1.7.&nbsp;The EJB deployment descriptor: <tt class="literal">ejb-jar.xml</tt></h4></div></div><div></div></div><p> The <tt class="literal">ejb-jar.xml</tt> file integrates Seam with EJB3, by attaching the
                        <tt class="literal">SeamInterceptor</tt> to all session beans in the archive. </p><pre class="programlisting">&lt;ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                             http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd"
         version="3.0"&gt;
         
   &lt;interceptors&gt;
      &lt;interceptor&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor&gt;
   &lt;/interceptors&gt;
   
   &lt;assembly-descriptor&gt;
      &lt;interceptor-binding&gt;
         &lt;ejb-name&gt;*&lt;/ejb-name&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor-binding&gt;
   &lt;/assembly-descriptor&gt;
   
&lt;/ejb-jar&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e710"></a>1.2.1.8.&nbsp;The EJB persistence deployment descriptor: <tt class="literal">persistence.xml</tt></h4></div></div><div></div></div><p> The <tt class="literal">persistence.xml</tt> file tells the EJB persistence provider where to find the
                    datasource, and contains some vendor-specific settings. In this case, enables automatic schema
                    export at startup time. </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" 
             version="1.0"&gt;

   &lt;persistence-unit name="userDatabase"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
    &lt;/persistence-unit&gt;
    
&lt;/persistence&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e722"></a>1.2.1.9.&nbsp;The view: <tt class="literal">register.xhtml</tt> and <tt class="literal">registered.xhtml</tt></h4></div></div><div></div></div><p> The view pages for a Seam application could be implemented using any technology that supports
                    JSF. In this example we use Facelets, because we think it's better than JSP.</p><div class="example"><a name="registration-simpleform"></a><p class="title"><b>Example&nbsp;1.7.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:s="http://jboss.com/products/seam/taglib"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Register New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         &lt;h:form&gt;
            &lt;s:validateAll&gt;
               &lt;h:panelGrid columns="2"&gt;
                  Username: &lt;h:inputText value="#{user.username}" required="true"/&gt;
                  Real Name: &lt;h:inputText value="#{user.name}" required="true"/&gt;
                  Password: &lt;h:inputSecret value="#{user.password}" required="true"/&gt;
               &lt;/h:panelGrid&gt;
            &lt;/s:validateAll&gt;
            &lt;h:messages/&gt;
            &lt;h:commandButton value="Register" action="#{register.register}"/&gt;
         &lt;/h:form&gt;
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;</pre></div><p> The only thing here that is specific to Seam is the
                    <tt class="literal">&lt;s:validateAll&gt;</tt> tag. This JSF component tells JSF to validate all
                    the contained input fields against the Hibernate Validator annotations specified on the entity bean. </p><div class="example"><a name="registration-simplepage"></a><p class="title"><b>Example&nbsp;1.8.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Successfully Registered New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         Welcome, #{user.name}, you are successfully registered as #{user.username}.
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;
</pre></div><p> This is a boring old Facelets page using some embedded EL. There is nothing specific to Seam
                    here. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e745"></a>1.2.1.10.&nbsp;The EAR deployment descriptor: <tt class="literal">application.xml</tt></h4></div></div><div></div></div><p> Finally, since our application is deployed as an EAR, we need a deployment descriptor there, too. </p><div class="example"><a name="registration-application-xml"></a><p class="title"><b>Example&nbsp;1.9.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;application xmlns="http://java.sun.com/xml/ns/javaee" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                                 http://java.sun.com/xml/ns/javaee/application_5.xsd"
             version="5"&gt;
             
    &lt;display-name&gt;Seam Registration&lt;/display-name&gt;

    &lt;module&gt;
        &lt;web&gt;
            &lt;web-uri&gt;jboss-seam-registration.war&lt;/web-uri&gt;
            &lt;context-root&gt;/seam-registration&lt;/context-root&gt;
        &lt;/web&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam-registration.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;java&gt;jboss-el.jar&lt;/java&gt;
    &lt;/module&gt;

&lt;/application&gt;</pre></div><p> This deployment descriptor links modules in the enterprise archive and binds the web application
                    to the context root <tt class="literal">/seam-registration</tt>. </p></div><p> We've now seen <span class="emphasis"><em>all</em></span> the files in the entire application! </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e765"></a>1.2.2.&nbsp;How it works</h3></div></div><div></div></div><p> When the form is submitted, JSF asks Seam to resolve the variable named <tt class="literal">user</tt>.
                Since there is no value already bound to that name (in any Seam context), Seam instantiates the
                    <tt class="literal">user</tt> component, and returns the resulting <tt class="literal">User</tt> entity bean
                instance to JSF after storing it in the Seam session context. </p><p> The form input values are now validated against the Hibernate Validator constraints specified on the
                    <tt class="literal">User</tt> entity. If the constraints are violated, JSF redisplays the page. Otherwise,
                JSF binds the form input values to properties of the <tt class="literal">User</tt> entity bean. </p><p> Next, JSF asks Seam to resolve the variable named <tt class="literal">register</tt>. Seam finds the
                    <tt class="literal">RegisterAction</tt> stateless session bean in the stateless context and returns it.
                JSF invokes the <tt class="literal">register()</tt> action listener method. </p><p> Seam intercepts the method call and injects the <tt class="literal">User</tt> entity from the Seam session
                context, before continuing the invocation. </p><p> The <tt class="literal">register()</tt> method checks if a user with the entered username already exists.
                If so, an error message is queued with the <tt class="literal">FacesMessages</tt> component, and a null
                outcome is returned, causing a page redisplay. The <tt class="literal">FacesMessages</tt> component
                interpolates the JSF expression embedded in the message string and adds a JSF
                <tt class="literal">FacesMessage</tt> to the view. </p><p> If no user with that username exists, the <tt class="literal">"/registered.xhtml"</tt> outcome triggers a
                browser redirect to the <tt class="literal">registered.xhtml</tt> page. When JSF comes to render the page, it
                asks Seam to resolve the variable named <tt class="literal">user</tt> and uses property values of the returned
                    <tt class="literal">User</tt> entity from Seam's session scope. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="messages"></a>1.3.&nbsp;Clickable lists in Seam: the messages example</h2></div></div><div></div></div><p> Clickable lists of database search results are such an important part of any online application that Seam
            provides special functionality on top of JSF to make it easier to query data using EJB-QL or HQL and display
            it as a clickable list using a JSF <tt class="literal">&lt;h:dataTable&gt;</tt>. The messages example
            demonstrates this functionality. </p><div class="mediaobject" align="center"><img src="../shared/images/messages.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e844"></a>1.3.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The message list example has one entity bean, <tt class="literal">Message</tt>, one session bean,
                    <tt class="literal">MessageListBean</tt> and one JSP. </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e855"></a>1.3.1.1.&nbsp;The entity bean: <tt class="literal">Message.java</tt></h4></div></div><div></div></div><p> The <tt class="literal">Message</tt> entity defines the title, text, date and time of a message, and a
                    flag indicating whether the message has been read: </p><div class="example"><a name="d0e865"></a><p class="title"><b>Example&nbsp;1.10.&nbsp;</b></p><pre class="programlisting">@Entity
@Name("message")
@Scope(EVENT)
public class Message implements Serializable
{
   private Long id;
   private String title;
   private String text;
   private boolean read;
   private Date datetime;
   
   @Id @GeneratedValue
   public Long getId() {
      return id;
   }
   public void setId(Long id) {
      this.id = id;
   }
   
   @NotNull @Length(max=100)
   public String getTitle() {
      return title;
   }
   public void setTitle(String title) {
      this.title = title;
   }
   
   @NotNull @Lob
   public String getText() {
      return text;
   }
   public void setText(String text) {
      this.text = text;
   }
   
   @NotNull
   public boolean isRead() {
      return read;
   }
   public void setRead(boolean read) {
      this.read = read;
   }
   
   @NotNull 
   @Basic @Temporal(TemporalType.TIMESTAMP)
   public Date getDatetime() {
      return datetime;
   }
   public void setDatetime(Date datetime) {
      this.datetime = datetime;
   }
   
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e868"></a>1.3.1.2.&nbsp;The stateful session bean: <tt class="literal">MessageManagerBean.java</tt></h4></div></div><div></div></div><p> Just like in the previous example, we have a session bean, <tt class="literal">MessageManagerBean</tt>,
                    which defines the action listener methods for the two buttons on our form. One of the buttons
                    selects a message from the list, and displays that message. The other button deletes a message. So
                    far, this is not so different to the previous example. </p><p> But <tt class="literal">MessageManagerBean</tt> is also responsible for fetching the list of messages
                    the first time we navigate to the message list page. There are various ways the user could navigate
                    to the page, and not all of them are preceded by a JSF action&#8212;the user might have
                    bookmarked the page, for example. So the job of fetching the message list takes place in a Seam
                        <span class="emphasis"><em>factory method</em></span>, instead of in an action listener method. </p><p> We want to cache the list of messages in memory between server requests, so we will make this a
                    stateful session bean. </p><div class="example"><a name="d0e888"></a><p class="title"><b>Example&nbsp;1.11.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful
@Scope(SESSION)
@Name("messageManager")
public class MessageManagerBean implements Serializable, MessageManager
{

   @DataModel                                                                            <span class="co">(1)</span>
   private List&lt;Message&gt; messageList;
   
   @DataModelSelection                                                                   <span class="co">(2)</span>
   @Out(required=false)                                                                  <span class="co">(3)</span>
   private Message message;
   
   @PersistenceContext(type=EXTENDED)                                                    <span class="co">(4)</span>
   private EntityManager em;
   
   @Factory("messageList")                                                               <span class="co">(5)</span>
   public void findMessages()
   {
      messageList = em.createQuery("from Message msg order by msg.datetime desc")
                      .getResultList();
   }
   
   public void select()                                                                  <span class="co">(6)</span>
   {
      message.setRead(true);
   }
   
   public void delete()                                                                  <span class="co">(7)</span>
   {
      messageList.remove(message);
      em.remove(message);
      message=null;
   }
   
   @Remove                                                                               <span class="co">(8)</span>
   public void destroy() {}

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">@DataModel</tt> annotation exposes an attibute of type
                                        <tt class="literal">java.util.List</tt> to the JSF page as an instance of
                                        <tt class="literal">javax.faces.model.DataModel</tt>. This allows us to use the list
                                    in a JSF <tt class="literal">&lt;h:dataTable&gt;</tt> with clickable links for
                                    each row. In this case, the <tt class="literal">DataModel</tt> is made available in a
                                    session context variable named <tt class="literal">messageList</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@DataModelSelection</tt> annotation tells Seam to inject the
                                        <tt class="literal">List</tt> element that corresponded to the clicked link. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <tt class="literal">@Out</tt> annotation then exposes the selected value directly
                                    to the page. So ever time a row of the clickable list is selected, the
                                        <tt class="literal">Message</tt> is injected to the attribute of the stateful bean,
                                    and the subsequently <span class="emphasis"><em>outjected</em></span> to the event context variable
                                    named <tt class="literal">message</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> This stateful bean has an EJB3 <span class="emphasis"><em>extended persistence context</em></span>.
                                    The messages retrieved in the query remain in the managed state as long as the bean
                                    exists, so any subsequent method calls to the stateful bean can update them without
                                    needing to make any explicit call to the <tt class="literal">EntityManager</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The first time we navigate to the JSP page, there will be no value in the
                                        <tt class="literal">messageList</tt> context variable. The <tt class="literal">@Factory</tt>
                                    annotation tells Seam to create an instance of <tt class="literal">MessageManagerBean</tt>
                                    and invoke the <tt class="literal">findMessages()</tt> method to initialize the value. We
                                    call <tt class="literal">findMessages()</tt> a <span class="emphasis"><em>factory method</em></span> for
                                        <tt class="literal">messages</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p> The <tt class="literal">select()</tt> action listener method marks the selected
                                        <tt class="literal">Message</tt> as read, and updates it in the database. </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p> The <tt class="literal">delete()</tt> action listener method removes the selected
                                        <tt class="literal">Message</tt> from the database. </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p> All stateful session bean Seam components <span class="emphasis"><em>must</em></span> have a method
                                    with no parameters marked <tt class="literal">@Remove</tt> that Seam uses to remove 
                                    the stateful bean when the Seam context ends, and clean up any server-side state.
                                </p></td></tr></table></div></div></div><p> Note that this is a session-scoped Seam component. It is associated with the user login session,
                    and all requests from a login session share the same instance of the component. (In Seam
                    applications, we usually use session-scoped components sparingly.) </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1009"></a>1.3.1.3.&nbsp;The session bean local interface: <tt class="literal">MessageManager.java</tt></h4></div></div><div></div></div><p> All session beans have a business interface, of course. </p><pre class="programlisting">@Local
public interface MessageManager
{
   public void findMessages();
   public void select();
   public void delete();
   public void destroy();
}</pre><p> From now on, we won't show local interfaces in our code examples. </p><p> Let's skip over <tt class="literal">components.xml</tt>, <tt class="literal">persistence.xml</tt>,
                        <tt class="literal">web.xml</tt>, <tt class="literal">ejb-jar.xml</tt>, <tt class="literal">faces-config.xml</tt>
                    and <tt class="literal">application.xml</tt> since they are much the same as the previous example, and go
                    straight to the JSP. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1040"></a>1.3.1.4.&nbsp;The view: <tt class="literal">messages.jsp</tt></h4></div></div><div></div></div><p> The JSP page is a straightforward use of the JSF <tt class="literal">&lt;h:dataTable&gt;</tt>
                    component. Again, nothing specific to Seam. </p><div class="example"><a name="d0e1050"></a><p class="title"><b>Example&nbsp;1.12.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Messages&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;f:view&gt;
   &lt;h:form&gt;
     &lt;h2&gt;Message List&lt;/h2&gt;
     &lt;h:outputText value="No messages to display" 
                   rendered="#{messageList.rowCount==0}"/&gt;
     &lt;h:dataTable var="msg" value="#{messageList}" 
                  rendered="#{messageList.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Read"/&gt;
           &lt;/f:facet&gt;
           &lt;h:selectBooleanCheckbox value="#{msg.read}" disabled="true"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Title"/&gt;
           &lt;/f:facet&gt;
           &lt;h:commandLink value="#{msg.title}" action="#{messageManager.select}"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Date/Time"/&gt;
           &lt;/f:facet&gt;
           &lt;h:outputText value="#{msg.datetime}"&gt;
              &lt;f:convertDateTime type="both" dateStyle="medium" timeStyle="short"/&gt;
           &lt;/h:outputText&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;h:commandButton value="Delete" action="#{messageManager.delete}"/&gt;
        &lt;/h:column&gt;
     &lt;/h:dataTable&gt;
     &lt;h3&gt;&lt;h:outputText value="#{message.title}"/&gt;&lt;/h3&gt;
     &lt;div&gt;&lt;h:outputText value="#{message.text}"/&gt;&lt;/div&gt;
   &lt;/h:form&gt;
  &lt;/f:view&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1053"></a>1.3.2.&nbsp;How it works</h3></div></div><div></div></div><p> The first time we navigate to the <tt class="literal">messages.jsp</tt> page, whether by a JSF postback
                (faces request) or a direct browser GET request (non-faces request), the page will try to resolve the
                    <tt class="literal">messageList</tt> context variable. Since this context variable is not initialized,
                Seam will call the factory method <tt class="literal">findMessages()</tt>, which performs a query against the
                database and results in a <tt class="literal">DataModel</tt> being outjected. This
                <tt class="literal">DataModel</tt> provides the row data needed for rendering the
                    <tt class="literal">&lt;h:dataTable&gt;</tt>. </p><p> When the user clicks the <tt class="literal">&lt;h:commandLink&gt;</tt>, JSF calls the
                    <tt class="literal">select()</tt> action listener. Seam intercepts this call and injects the selected row
                data into the <tt class="literal">message</tt> attribute of the <tt class="literal">messageManager</tt> component.
                The action listener fires, marking the selected <tt class="literal">Message</tt> as read. At the end of the
                call, Seam outjects the selected <tt class="literal">Message</tt> to the context variable named
                    <tt class="literal">message</tt>. Next, the EJB container commits the transaction, and the change to the
                    <tt class="literal">Message</tt> is flushed to the database. Finally, the page is re-rendered,
                redisplaying the message list, and displaying the selected message below it. </p><p> If the user clicks the <tt class="literal">&lt;h:commandButton&gt;</tt>, JSF calls the
                    <tt class="literal">delete()</tt> action listener. Seam intercepts this call and injects the selected row
                data into the <tt class="literal">message</tt> attribute of the <tt class="literal">messageList</tt> component. The
                action listener fires, removing the selected <tt class="literal">Message</tt> from the list, and also calling
                    <tt class="literal">remove()</tt> on the <tt class="literal">EntityManager</tt>. At the end of the call, Seam
                refreshes the <tt class="literal">messageList</tt> context variable and clears the context variable named
                    <tt class="literal">message</tt>. The EJB container commits the transaction, and deletes the
                    <tt class="literal">Message</tt> from the database. Finally, the page is re-rendered, redisplaying the
                message list. </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="todo"></a>1.4.&nbsp;Seam and jBPM: the todo list example</h2></div></div><div></div></div><p> jBPM provides sophisticated functionality for workflow and task management. To get a small taste of how
            jBPM integrates with Seam, we'll show you a simple "todo list" application. Since managing lists of tasks is
            such core functionality for jBPM, there is hardly any Java code at all in this example. </p><div class="mediaobject" align="center"><img src="../shared/images/todo.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1144"></a>1.4.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The center of this example is the jBPM process definition. There are also two JSPs and two trivial
                JavaBeans (There was no reason to use session beans, since they do not access the database, or have any
                other transactional behavior). Let's start with the process definition: </p><div class="example"><a name="d0e1149"></a><p class="title"><b>Example&nbsp;1.13.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;process-definition name="todo"&gt;
   
   &lt;start-state name="start"&gt;                                                            <span class="co">(1)</span>
      &lt;transition to="todo"/&gt;
   &lt;/start-state&gt;
   
   &lt;task-node name="todo"&gt;                                                               <span class="co">(2)</span>
      &lt;task name="todo" description="#{todoList.description}"&gt;                           <span class="co">(3)</span>
         &lt;assignment actor-id="#{actor.id}"/&gt;                                            <span class="co">(4)</span>
      &lt;/task&gt;
      &lt;transition to="done"/&gt;
   &lt;/task-node&gt;
   
   &lt;end-state name="done"/&gt;                                                              <span class="co">(5)</span>
   
&lt;/process-definition&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;start-state&gt;</tt> node represents the logical start
                                of the process. When the process starts, it immediately transitions to the
                                <tt class="literal">todo</tt> node. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;task-node&gt;</tt> node represents a <span class="emphasis"><em>wait
                                    state</em></span>, where business process execution pauses, waiting for one or more
                                tasks to be performed. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;task&gt;</tt> element defines a task to be performed by
                                a user. Since there is only one task defined on this node, when it is complete,
                                execution resumes, and we transition to the end state. The task gets its description
                                from a Seam component named <tt class="literal">todoList</tt> (one of the JavaBeans). </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> Tasks need to be assigned to a user or group of users when they are created. In this
                                case, the task is assigned to the current user, which we get from a built-in Seam
                                component named <tt class="literal">actor</tt>. Any Seam component may be used to perform task
                                assignment. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;end-state&gt;</tt> node defines the logical end of the
                                business process. When execution reaches this node, the process instance is destroyed.
                            </p></td></tr></table></div></div></div><p> If we view this process definition using the process definition editor provided by JBossIDE, this is
                what it looks like: </p><div class="mediaobject" align="center"><img src="../shared/images/todo-process.png" align="middle"></div><p> This document defines our <span class="emphasis"><em>business process</em></span> as a graph of nodes. This is the most
                trivial possible business process: there is one <span class="emphasis"><em>task</em></span> to be performed, and when that
                task is complete, the business process ends. </p><p> The first JavaBean handles the login screen <tt class="literal">login.jsp</tt>. Its job is just to
                initialize the jBPM actor id using the <tt class="literal">actor</tt> component. (In a real application, it
                would also need to authenticate the user.) </p><div class="example"><a name="d0e1222"></a><p class="title"><b>Example&nbsp;1.14.&nbsp;</b></p><pre class="programlisting">@Name("login")
public class Login {
   
   @In
   private Actor actor;
   
   private String user;

   public String getUser() {
      return user;
   }

   public void setUser(String user) {
      this.user = user;
   }
   
   public String login()
   {
      actor.setId(user);
      return "/todo.jsp";
   }
}</pre></div><p> Here we see the use of <tt class="literal">@In</tt> to inject the built-in <tt class="literal">Actor</tt>
                component. </p><p> The JSP itself is trivial: </p><div class="example"><a name="d0e1235"></a><p class="title"><b>Example&nbsp;1.15.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h"%&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;f:view&gt;
    &lt;h:form&gt;
      &lt;div&gt;
        &lt;h:inputText value="#{login.user}"/&gt;
        &lt;h:commandButton value="Login" action="#{login.login}"/&gt;
      &lt;/div&gt;
    &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p> The second JavaBean is responsible for starting business process instances, and ending tasks. </p><div class="example"><a name="d0e1240"></a><p class="title"><b>Example&nbsp;1.16.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("todoList")
public class TodoList {
   
   private String description;
   
   public String getDescription()                                                        <span class="co">(1)</span>
   {
      return description;
   }

   public void setDescription(String description) {
      this.description = description;
   }
   
   @CreateProcess(definition="todo")                                                     <span class="co">(2)</span>
   public void createTodo() {}
   
   @StartTask @EndTask                                                                   <span class="co">(3)</span>
   public void done() {}

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The description property accepts user input form the JSP page, and exposes it to the
                                process definition, allowing the task description to be set. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@CreateProcess</tt> annotation creates a new jBPM process
                                instance for the named process definition. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The Seam <tt class="literal">@StartTask</tt> annotation starts work on a task. The
                                    <tt class="literal">@EndTask</tt> ends the task, and allows the business process execution
                                to resume. </p></td></tr></table></div></div></div><p> In a more realistic example, <tt class="literal">@StartTask</tt> and <tt class="literal">@EndTask</tt> would not
                appear on the same method, because there is usually work to be done using the application in order to
                complete the task. </p><p> Finally, the meat of the application is in <tt class="literal">todo.jsp</tt>: </p><div class="example"><a name="d0e1280"></a><p class="title"><b>Example&nbsp;1.17.&nbsp;</b></p><pre class="programlisting">&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;%@ taglib uri="http://jboss.com/products/seam/taglib" prefix="s" %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Todo List&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Todo List&lt;/h1&gt;
&lt;f:view&gt;
   &lt;h:form id="list"&gt;
      &lt;div&gt;
         &lt;h:outputText value="There are no todo items." 
                       rendered="#{empty taskInstanceList}"/&gt;
         &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                      rendered="#{not empty taskInstanceList}"&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Description"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.description}"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Created"/&gt;
                &lt;/f:facet&gt;
                &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
                    &lt;f:convertDateTime type="date"/&gt;
                &lt;/h:outputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Priority"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Due Date"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
                    &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
                &lt;/h:inputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
            &lt;/h:column&gt;
         &lt;/h:dataTable&gt;
      &lt;/div&gt;
      &lt;div&gt;
      &lt;h:messages/&gt;
      &lt;/div&gt;
      &lt;div&gt;
         &lt;h:commandButton value="Update Items" action="update"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
   &lt;h:form id="new"&gt;
      &lt;div&gt;
         &lt;h:inputText value="#{todoList.description}"/&gt;
         &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p> Let's take this one piece at a time. </p><p> The page renders a list of tasks, which it gets from a built-in Seam component named
                    <tt class="literal">taskInstanceList</tt>. The list is defined inside a JSF form. </p><pre class="programlisting">&lt;h:form id="list"&gt;
   &lt;div&gt;
      &lt;h:outputText value="There are no todo items." rendered="#{empty taskInstanceList}"/&gt;
      &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                   rendered="#{not empty taskInstanceList}"&gt;
         ...
      &lt;/h:dataTable&gt;
   &lt;/div&gt;
&lt;/h:form&gt;</pre><p> Each element of the list is an instance of the jBPM class <tt class="literal">TaskInstance</tt>. The
                following code simply displays the interesting properties of each task in the list. For the description,
                priority and due date, we use input controls, to allow the user to update these values. </p><pre class="programlisting">&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
       &lt;h:outputText value="Description"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.description}"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Created"/&gt;
    &lt;/f:facet&gt;
    &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
        &lt;f:convertDateTime type="date"/&gt;
    &lt;/h:outputText&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Priority"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Due Date"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
        &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
    &lt;/h:inputText&gt;
&lt;/h:column&gt;</pre><p> This button ends the task by calling the action method annotated <tt class="literal">@StartTask
                @EndTask</tt>. It passes the task id to Seam as a request parameter: </p><pre class="programlisting">&lt;h:column&gt;
    &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
&lt;/h:column&gt;</pre><p> (Note that this is using a Seam <tt class="literal">&lt;s:button&gt;</tt> JSF control from the
                    <tt class="literal">seam-ui.jar</tt> package.) </p><p> This button is used to update the properties of the tasks. When the form is submitted, Seam and jBPM
                will make any changes to the tasks persistent. There is no need for any action listener method: </p><pre class="programlisting">&lt;h:commandButton value="Update Items" action="update"/&gt;</pre><p> A second form on the page is used to create new items, by calling the action method annotated
                    <tt class="literal">@CreateProcess</tt>. </p><pre class="programlisting">&lt;h:form id="new"&gt;
    &lt;div&gt;
        &lt;h:inputText value="#{todoList.description}"/&gt;
        &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;</pre><p> There are several other files needed for the example, but they are just standard jBPM and Seam
                configuration and not very interesting. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1327"></a>1.4.2.&nbsp;How it works</h3></div></div><div></div></div><p>TODO</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="numberguess"></a>1.5.&nbsp;Seam pageflow: the numberguess example</h2></div></div><div></div></div><p> For Seam applications with relatively freeform (ad hoc) navigation, JSF/Seam navigation rules are a
            perfectly good way to define the page flow. For applications with a more constrained style of navigation,
            especially for user interfaces which are more stateful, navigation rules make it difficult to really
            understand the flow of the system. To understand the flow, you need to piece it together from the view
            pages, the actions and the navigation rules. </p><p> Seam allows you to use a jPDL process definition to define pageflow. The simple number guessing example
            shows how this is done. </p><div class="mediaobject" align="center"><img src="../shared/images/numberguess.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1344"></a>1.5.1.&nbsp;Understanding the code</h3></div></div><div></div></div><p> The example is implemented using one JavaBean, three JSP pages and a jPDL pageflow definition. Let's
                begin with the pageflow: </p><div class="example"><a name="d0e1349"></a><p class="title"><b>Example&nbsp;1.18.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;pageflow-definition 
        xmlns="http://jboss.com/products/seam/pageflow"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.com/products/seam/pageflow 
                            http://jboss.com/products/seam/pageflow-2.0.xsd"
        name="numberGuess"&gt;
   
   &lt;start-page name="displayGuess" view-id="/numberGuess.jspx"&gt;                          <span class="co">(1)</span>
      &lt;redirect/&gt;
      &lt;transition name="guess" to="evaluateGuess"&gt;                                       <span class="co">(2)</span>
         &lt;action expression="#{numberGuess.guess}"/&gt;                                     <span class="co">(3)</span>
      &lt;/transition&gt;
      &lt;transition name="giveup" to="giveup"/&gt;
   &lt;/start-page&gt;
   
   &lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;              <span class="co">(4)</span>
      &lt;transition name="true" to="win"/&gt;
      &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
   &lt;/decision&gt;
   
   &lt;decision name="evaluateRemainingGuesses" expression="#{numberGuess.lastGuess}"&gt;
      &lt;transition name="true" to="lose"/&gt;
      &lt;transition name="false" to="displayGuess"/&gt;
   &lt;/decision&gt;
   
   &lt;page name="giveup" view-id="/giveup.jspx"&gt;
      &lt;redirect/&gt;
      &lt;transition name="yes" to="lose"/&gt;
      &lt;transition name="no" to="displayGuess"/&gt;
   &lt;/page&gt;
   
   &lt;page name="win" view-id="/win.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
   &lt;page name="lose" view-id="/lose.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;page&gt;</tt> element defines a wait state where the
                                system displays a particular JSF view and waits for user input. The
                                <tt class="literal">view-id</tt> is the same JSF view id used in plain JSF navigation rules.
                                The <tt class="literal">redirect</tt> attribute tells Seam to use post-then-redirect when
                                navigating to the page. (This results in friendly browser URLs.) </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">&lt;transition&gt;</tt> element names a JSF outcome. The
                                transition is triggered when a JSF action results in that outcome. Execution will then
                                proceed to the next node of the pageflow graph, after invocation of any jBPM transition
                                actions. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> A transition <tt class="literal">&lt;action&gt;</tt> is just like a JSF action,
                                except that it occurs when a jBPM transition occurs. The transition action can invoke
                                any Seam component. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> A <tt class="literal">&lt;decision&gt;</tt> node branches the pageflow, and
                                determines the next node to execute by evaluating a JSF EL expression. </p></td></tr></table></div></div></div><p> Here is what the pageflow looks like in the JBossIDE pageflow editor: </p><div class="mediaobject" align="center"><img src="../shared/images/numberguess-pageflow.png" align="middle"></div><p> Now that we have seen the pageflow, it is very, very easy to understand the rest of the application! </p><p> Here is the main page of the application, <tt class="literal">numberGuess.jspx</tt>: </p><div class="example"><a name="d0e1403"></a><p class="title"><b>Example&nbsp;1.19.&nbsp;</b></p><pre class="programlisting">&lt;&lt;?xml version="1.0"?&gt;
&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns:s="http://jboss.com/products/seam/taglib"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html" 
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Guess a number...&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
    &lt;script language="javascript" type="text/javascript" src="niceforms.js" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Guess a number...&lt;/h1&gt;
    &lt;f:view&gt;
	  &lt;h:form styleClass="niceform"&gt;
	    
	    &lt;div&gt;
	    &lt;h:messages globalOnly="true"/&gt;
	    &lt;h:outputText value="Higher!" 
	           rendered="#{numberGuess.randomNumber gt numberGuess.currentGuess}"/&gt;
	    &lt;h:outputText value="Lower!" 
	           rendered="#{numberGuess.randomNumber lt numberGuess.currentGuess}"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        I'm thinking of a number between 
        &lt;h:outputText value="#{numberGuess.smallest}"/&gt; and 
        &lt;h:outputText value="#{numberGuess.biggest}"/&gt;. You have 
        &lt;h:outputText value="#{numberGuess.remainingGuesses}"/&gt; guesses.
        &lt;/div&gt;
        
        &lt;div&gt;
        Your guess: 
        &lt;h:inputText value="#{numberGuess.currentGuess}" id="inputGuess" 
                     required="true" size="3" 
                     rendered="#{(numberGuess.biggest-numberGuess.smallest) gt 20}"&gt;
          &lt;f:validateLongRange maximum="#{numberGuess.biggest}" 
                               minimum="#{numberGuess.smallest}"/&gt;
        &lt;/h:inputText&gt;
        &lt;h:selectOneMenu value="#{numberGuess.currentGuess}" 
                         id="selectGuessMenu" required="true"
                         rendered="#{(numberGuess.biggest-numberGuess.smallest) le 20 and 
                                     (numberGuess.biggest-numberGuess.smallest) gt 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneMenu&gt;
        &lt;h:selectOneRadio value="#{numberGuess.currentGuess}" id="selectGuessRadio" 
                          required="true"
                          rendered="#{(numberGuess.biggest-numberGuess.smallest) le 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneRadio&gt;
		&lt;h:commandButton value="Guess" action="guess"/&gt;
        &lt;s:button value="Cheat" view="/confirm.jspx"/&gt;
        &lt;s:button value="Give up" action="giveup"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        &lt;h:message for="inputGuess" style="color: red"/&gt;
        &lt;/div&gt;
        
	  &lt;/h:form&gt;
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;</pre></div><p> Notice how the command button names the <tt class="literal">guess</tt> transition instead of calling an
                action directly. </p><p> The <tt class="literal">win.jspx</tt> page is predictable: </p><div class="example"><a name="d0e1416"></a><p class="title"><b>Example&nbsp;1.20.&nbsp;</b></p><pre class="programlisting">&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html"
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;You won!&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;You won!&lt;/h1&gt;
    &lt;f:view&gt;
      Yes, the answer was &lt;h:outputText value="#{numberGuess.currentGuess}" /&gt;.
      It took you &lt;h:outputText value="#{numberGuess.guessCount}" /&gt; guesses.
      &lt;h:outputText value="But you cheated, so it doesn't count!" 
                    rendered="#{numberGuess.cheat}"/&gt;
      Would you like to &lt;a href="numberGuess.seam"&gt;play again&lt;/a&gt;?
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;
</pre></div><p> As is <tt class="literal">lose.jspx</tt> (which I can't be bothered copy/pasting). Finally, the JavaBean
                Seam component: </p><div class="example"><a name="d0e1424"></a><p class="title"><b>Example&nbsp;1.21.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("numberGuess")
@Scope(ScopeType.CONVERSATION)
public class NumberGuess implements Serializable {
   
   private int randomNumber;
   private Integer currentGuess;
   private int biggest;
   private int smallest;
   private int guessCount;
   private int maxGuesses;
   private boolean cheated;
   
   @Create                                                                               <span class="co">(1)</span>
   public void begin()
   {
      randomNumber = new Random().nextInt(100);
      guessCount = 0;
      biggest = 100;
      smallest = 1;
   }
   
   public void setCurrentGuess(Integer guess)
   {
      this.currentGuess = guess;
   }
   
   public Integer getCurrentGuess()
   {
      return currentGuess;
   }
   
   public void guess()
   {
      if (currentGuess&gt;randomNumber)
      {
         biggest = currentGuess - 1;
      }
      if (currentGuess&lt;randomNumber)
      {
         smallest = currentGuess + 1;
      }
      guessCount ++;
   }
   
   public boolean isCorrectGuess()
   {
      return currentGuess==randomNumber;
   }
   
   public int getBiggest()
   {
      return biggest;
   }
   
   public int getSmallest()
   {
      return smallest;
   }
   
   public int getGuessCount()
   {
      return guessCount;
   }
   
   public boolean isLastGuess()
   {
      return guessCount==maxGuesses;
   }

   public int getRemainingGuesses() {
      return maxGuesses-guessCount;
   }

   public void setMaxGuesses(int maxGuesses) {
      this.maxGuesses = maxGuesses;
   }

   public int getMaxGuesses() {
      return maxGuesses;
   }

   public int getRandomNumber() {
      return randomNumber;
   }

   public void cheated()
   {
      cheated = true;
   }
   
   public boolean isCheat() {
      return cheated;
   }
   
   public List&lt;Integer&gt; getPossibilities()
   {
      List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
      for(int i=smallest; i&lt;=biggest; i++) result.add(i);
      return result;
   }
   
}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The first time a JSP page asks for a <tt class="literal">numberGuess</tt> component, Seam
                                will create a new one for it, and the <tt class="literal">@Create</tt> method will be invoked,
                                allowing the component to initialize itself. </p></td></tr></table></div></div></div><p>The <tt class="literal">pages.xml</tt> file starts a Seam
                <span class="emphasis"><em>conversation</em></span> (much more about that later), and specifies the
                pageflow definition to use for the conversation's page flow. 
            </p><div class="example"><a name="d0e1448"></a><p class="title"><b>Example&nbsp;1.22.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;pages xmlns="http://jboss.com/products/seam/pages"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://jboss.com/products/seam/pages http://jboss.com/products/seam/pages-2.0.xsd"&gt;

  &lt;page view-id="/numberGuess.jspx"&gt;
    &lt;begin-conversation join="true" pageflow="numberGuess"/&gt;
  &lt;/page&gt;

  &lt;page view-id="/confirm.jspx"&gt;
    &lt;begin-conversation nested="true" pageflow="cheat"/&gt;
  &lt;/page&gt;

&lt;/pages&gt;      
</pre></div><p> As you can see, this Seam component is pure business logic! It doesn't need to know anything at all
                about the user interaction flow. This makes the component potentially more reuseable. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1453"></a>1.5.2.&nbsp;How it works</h3></div></div><div></div></div><p>TODO</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="booking"></a>1.6.&nbsp;A complete Seam application: the Hotel Booking example</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1461"></a>1.6.1.&nbsp;Introduction</h3></div></div><div></div></div><p> The booking application is a complete hotel room reservation system incorporating the following
                features: </p><div class="itemizedlist"><ul type="disc"><li><p>User registration</p></li><li><p>Login</p></li><li><p>Logout</p></li><li><p>Set password</p></li><li><p>Hotel search</p></li><li><p>Hotel selection</p></li><li><p>Room reservation</p></li><li><p>Reservation confirmation</p></li><li><p>Existing reservation list</p></li></ul></div><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/booking.png" align="middle"></div></div><p> The booking application uses JSF, EJB 3.0 and Seam, together with Facelets for the view. There is
                also a port of this application to JSF, Facelets, Seam, JavaBeans and Hibernate3. </p><p> One of the things you'll notice if you play with this application for long enough is that it is
                extremely <span class="emphasis"><em>robust</em></span>. You can play with back buttons and browser refresh and opening
                multiple windows and entering nonsensical data as much as you like and you will find it very difficult
                to make the application crash. You might think that we spent weeks testing and fixing bugs to achive
                this. Actually, this is not the case. Seam was designed to make it very straightforward to build robust
                web applications and a lot of robustness that you are probably used to having to code yourself comes
                naturally and automatically with Seam. </p><p> As you browse the sourcecode of the example application, and learn how the application works, observe
                how the declarative state management and integrated validation has been used to achieve this robustness. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1511"></a>1.6.2.&nbsp;Overview of the booking example</h3></div></div><div></div></div><p> The project structure is identical to the previous one, to install and deploy this application,
                please refer to <a href="#try-examples" title="1.1.&nbsp;Try the examples">Section&nbsp;1.1, &#8220;Try the examples&#8221;</a>. Once you've successfully started the application, you
                can access it by pointing your browser to <a href="http://localhost:8080/seam-booking/" target="_top">
                    <tt class="literal">http://localhost:8080/seam-booking/</tt>
                </a>
            </p><p> Just nine classes (plus six session beans local interfaces) where used to implement this application.
                Six session bean action listeners contain all the business logic for the listed features. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">BookingListAction</tt> retrieves existing bookings for the currently logged in user. </p></li><li><p><tt class="literal">ChangePasswordAction</tt> updates the password of the currently logged in user.</p></li><li><p><tt class="literal">HotelBookingAction</tt> implements the core functionality of the application: hotel
                    room searching, selection, booking and booking confirmation. This functionality is implemented as a
                        <span class="emphasis"><em>conversation</em></span>, so this is the most interesting class in the application. </p></li><li><p><tt class="literal">RegisterAction</tt> registers a new system user.</p></li></ul></div><p> Three entity beans implement the application's persistent domain model. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Hotel</tt> is an entity bean that represent a hotel </p></li><li><p><tt class="literal">Booking</tt> is an entity bean that represents an existing booking </p></li><li><p><tt class="literal">User</tt> is an entity bean to represents a user who can make hotel bookings</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1568"></a>1.6.3.&nbsp;Understanding Seam conversations</h3></div></div><div></div></div><p> We encourage you browse the sourcecode at your pleasure. In this tutorial we'll concentrate upon one
                particular piece of functionality: hotel search, selection, booking and confirmation. From the point of
                view of the user, everything from selecting a hotel to confirming a booking is one continuous unit of
                work, a <span class="emphasis"><em>conversation</em></span>. Searching, however, is <span class="emphasis"><em>not</em></span> part of the
                conversation. The user can select multiple hotels from the same search results page, in different
                browser tabs. </p><p> Most web application architectures have no first class construct to represent a conversation. This
                causes enormous problems managing state associated with the conversation. Usually, Java web applications
                use a combination of two techniques: first, some state is thrown into the
                <tt class="literal">HttpSession</tt>; second, persistable state is flushed to the database after every
                request, and reconstructed from the database at the beginning of each new request. </p><p> Since the database is the least scalable tier, this often results in an utterly unacceptable lack of
                scalability. Added latency is also a problem, due to the extra traffic to and from the database on every
                request. To reduce this redundant traffic, Java applications often introduce a data (second-level) cache
                that keeps commonly accessed data between requests. This cache is necessarily inefficient, because
                invalidation is based upon an LRU policy instead of being based upon when the user has finished working
                with the data. Furthermore, because the cache is shared between many concurrent transactions, we've
                introduced a whole raft of problem's associated with keeping the cached state consistent with the
                database. </p><p> Now consider the state held in the <tt class="literal">HttpSession</tt>. By very careful programming, we
                might be able to control the size of the session data. This is a lot more difficult than it sounds,
                since web browsers permit ad hoc non-linear navigation. But suppose we suddenly discover a system
                requirement that says that a user is allowed to have <span class="emphasis"><em>mutiple concurrent
                conversations</em></span>, halfway through the development of the system (this has happened to me).
                Developing mechanisms to isolate session state associated with different concurrent conversations, and
                incorporating failsafes to ensure that conversation state is destroyed when the user aborts one of the
                conversations by closing a browser window or tab is not for the faint hearted (I've implemented this
                stuff twice so far, once for a client application, once for Seam, but I'm famously psychotic). </p><p> Now there is a better way. </p><p> Seam introduces the <span class="emphasis"><em>conversation context</em></span> as a first class construct. You can
                safely keep conversational state in this context, and be assured that it will have a well-defined
                lifecycle. Even better, you won't need to be continually pushing data back and forth between the
                application server and the database, since the conversation context is a natural cache of data that the
                user is currently working with. </p><p> Usually, the components we keep in the conversation context are stateful session beans. (We can also
                keep entity beans and JavaBeans in the conversation context.) There is an ancient canard in the Java
                community that stateful session beans are a scalability killer. This may have been true in 1998 when
                WebFoobar 1.0 was released. It is no longer true today. Application servers like JBoss AS have extremely
                sophisticated mechanisms for stateful session bean state replication. (For example, the JBoss EJB3
                container performs fine-grained replication, replicating only those bean attribute values which actually
                changed.) Note that all the traditional technical arguments for why stateful beans are inefficient apply
                equally to the <tt class="literal">HttpSession</tt>, so the practice of shifting state from business tier
                stateful session bean components to the web session to try and improve performance is unbelievably
                misguided. It is certainly possible to write unscalable applications using stateful session beans, by
                using stateful beans incorrectly, or by using them for the wrong thing. But that doesn't mean you should
                    <span class="emphasis"><em>never</em></span> use them. Anyway, Seam guides you toward a safe usage model. Welcome to
                2005. </p><p> OK, I'll stop ranting now, and get back to the tutorial. </p><p> The booking example application shows how stateful components with different scopes can collaborate
                together to achieve complex behaviors. The main page of the booking application allows the user to
                search for hotels. The search results are kept in the Seam session scope. When the user navigates to one
                of these hotels, a conversation begins, and a conversation scoped component calls back to the session
                scoped component to retrieve the selected hotel. </p><p> The booking example also demonstrates the use of RichFaces Ajax to implement rich client behavior without
                the use of handwritten JavaScript. </p><p> The search functionality is implemented using a session-scope stateful session bean, similar to the
                one we saw in the message list example above. </p><div class="example"><a name="d0e1617"></a><p class="title"><b>Example&nbsp;1.23.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful                                                                                <span class="co">(1)</span>
@Name("hotelSearch")
@Scope(ScopeType.SESSION)
@Restrict("#{identity.loggedIn}")                                                        <span class="co">(2)</span>
public class HotelSearchingAction implements HotelSearching
{
   
   @PersistenceContext
   private EntityManager em;
   
   private String searchString;
   private int pageSize = 10;
   private int page;
   
   @DataModel                                                                            <span class="co">(3)</span>
   private List&lt;Hotel&gt; hotels;
   
   public void find()
   {
      page = 0;
      queryHotels();
   }
   public void nextPage()
   {
      page++;
      queryHotels();
   }
      
   private void queryHotels()
   {
      hotels = 
          em.createQuery("select h from Hotel h where lower(h.name) like #{pattern} " + 
                         "or lower(h.city) like #{pattern} " + 
                         "or lower(h.zip) like #{pattern} " +
                         "or lower(h.address) like #{pattern}")
            .setMaxResults(pageSize)
            .setFirstResult( page * pageSize )
            .getResultList();
   }
   
   public boolean isNextPageAvailable()
   {
      return hotels!=null &amp;&amp; hotels.size()==pageSize;
   }
   
   public int getPageSize() {
      return pageSize;
   }
   
   public void setPageSize(int pageSize) {
      this.pageSize = pageSize;
   }
   
   @Factory(value="pattern", scope=ScopeType.EVENT)
   public String getSearchPattern()
   {
      return searchString==null ? 
            "%" : '%' + searchString.toLowerCase().replace('*', '%') + '%';
   }
   
   public String getSearchString()
   {
      return searchString;
   }
   
   public void setSearchString(String searchString)
   {
      this.searchString = searchString;
   }
                                                                                         <span class="co">(4)</span>
   @Remove
   public void destroy() {}
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Stateful</tt> annotation identifies this class as a
                                stateful session bean. Stateful session beans are scoped to the conversation context by
                                default. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@Restrict</tt> annotation applies a security restriction to the
                                component. It restricts access to the component allowing only logged-in users. The
                                security chapter explains more about security in Seam. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <a href="#datamodel-annotation">
                                    <tt class="literal">@DataModel</tt>
                                </a> annotation exposes a <tt class="literal">List</tt> as a JSF
                                <tt class="literal">ListDataModel</tt>. This makes it easy to implement clickable lists for
                                search screens. In this case, the list of hotels is exposed to the page as a
                                    <tt class="literal">ListDataModel</tt> in the conversation variable named
                                <tt class="literal">hotels</tt>. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The EJB standard <tt class="literal">@Remove</tt> annotation specifies that a stateful
                                session bean should be removed and its state destroyed after invocation of the annotated
                                method. In Seam, all stateful session beans must define a method with no parameters marked
                                    <tt class="literal">@Remove</tt>. This method will be
                                called when Seam destroys the session context.</p></td></tr></table></div></div></div><p> The main page of the application is a Facelets page. Let's look at the fragment which relates to
                searching for hotels: </p><div class="example"><a name="d0e1671"></a><p class="title"><b>Example&nbsp;1.24.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">&lt;div class="section"&gt;
  
    &lt;span class="errors"&gt;
       &lt;h:messages globalOnly="true"/&gt;
    &lt;/span&gt;
    
    &lt;h1&gt;Search Hotels&lt;/h1&gt;

	&lt;h:form id="searchCriteria"&gt;
	&lt;fieldset&gt; 
	   &lt;h:inputText id="searchString" value="#{hotelSearch.searchString}" 
                    style="width: 165px;"&gt;
         &lt;a:support event="onkeyup" actionListener="#{hotelSearch.find}" 
                    reRender="searchResults" /&gt;                                          <span class="co">(1)</span>
       &lt;/h:inputText&gt;
       &amp;#160;
	   &lt;a:commandButton id="findHotels" value="Find Hotels" action="#{hotelSearch.find}" 
                        reRender="searchResults"/&gt;
       &amp;#160;
       &lt;a:status&gt;                                                                        <span class="co">(2)</span>
          &lt;f:facet name="start"&gt;
             &lt;h:graphicImage value="/img/spinner.gif"/&gt;
          &lt;/f:facet&gt;
       &lt;/a:status&gt;
	   &lt;br/&gt;
       &lt;h:outputLabel for="pageSize"&gt;Maximum results:&lt;/h:outputLabel&gt;&amp;#160;
       &lt;h:selectOneMenu value="#{hotelSearch.pageSize}" id="pageSize"&gt;
          &lt;f:selectItem itemLabel="5" itemValue="5"/&gt;
          &lt;f:selectItem itemLabel="10" itemValue="10"/&gt;
          &lt;f:selectItem itemLabel="20" itemValue="20"/&gt;
       &lt;/h:selectOneMenu&gt;
    &lt;/fieldset&gt;
    &lt;/h:form&gt;
    
&lt;/div&gt;

&lt;a:outputPanel id="searchResults"&gt;                                                       <span class="co">(3)</span>
  &lt;div class="section"&gt;
    &lt;h:outputText value="No Hotels Found"
                  rendered="#{hotels != null and hotels.rowCount==0}"/&gt;
    &lt;h:dataTable id="hotels" value="#{hotels}" var="hot" 
                 rendered="#{hotels.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
            #{hot.name}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Address&lt;/f:facet&gt;
            #{hot.address}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;City, State&lt;/f:facet&gt;
            #{hot.city}, #{hot.state}, #{hot.country}
        &lt;/h:column&gt; 
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Zip&lt;/f:facet&gt;
            #{hot.zip}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
            &lt;s:link id="viewHotel" value="View Hotel"                                    <span class="co">(4)</span>
                    action="#{hotelBooking.selectHotel(hot)}"/&gt;
        &lt;/h:column&gt;
    &lt;/h:dataTable&gt;
    &lt;s:link value="More results" action="#{hotelSearch.nextPage}" 
            rendered="#{hotelSearch.nextPageAvailable}"/&gt;
  &lt;/div&gt;
&lt;/a:outputPanel&gt;    </pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:support&gt;</tt> tag allows a JSF action
                                event listener to be called by asynchronous <tt class="literal">XMLHttpRequest</tt> when a
                                JavaScript event like <tt class="literal">onkeyup</tt> occurs. Even better, the
                                    <tt class="literal">reRender</tt> attribute lets us render a fragment of the JSF page and
                                perform a partial page update when the asynchronous response is received. </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:status&gt;</tt> tag lets us display a cheesy
                                annimated image while we wait for asynchronous requests to return. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The RichFaces Ajax <tt class="literal">&lt;a:outputPanel&gt;</tt> tag defines a region of
                                the page which can be re-rendered by an asynchronous request. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The Seam <tt class="literal">&lt;s:link&gt;</tt> tag lets us attach a JSF action
                                listener to an ordinary (non-JavaScript) HTML link. The advantage of this over the
                                standard JSF <tt class="literal">&lt;h:commandLink&gt;</tt> is that it preserves the
                                operation of "open in new window" and "open in new tab". Also notice that we use a
                                method binding with a parameter: <tt class="literal">#{hotelBooking.selectHotel(hot)}</tt>.
                                This is not possible in the standard Unified EL, but Seam provides an extension to the
                                EL that lets you use parameters on any method binding expression. </p></td></tr></table></div></div></div><p> This page displays the search results dynamically as we type, and lets us choose a hotel and pass it
                to the <tt class="literal">selectHotel()</tt> method of the <tt class="literal">HotelBookingAction</tt>, which is
                where the <span class="emphasis"><em>really</em></span> interesting stuff is going to happen. </p><p> Now lets see how the booking example application uses a conversation-scoped stateful session bean to
                achieve a natural cache of persistent data related to the conversation. The following code example is
                pretty long. But if you think of it as a list of scripted actions that implement the various steps of
                the conversation, it's understandable. Read the class from top to bottom, as if it were a story. </p><div class="example"><a name="d0e1733"></a><p class="title"><b>Example&nbsp;1.25.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Stateful
@Name("hotelBooking")
@Restrict("#{identity.loggedIn}")
public class HotelBookingAction implements HotelBooking
{
   
   @PersistenceContext(type=EXTENDED)                                                    <span class="co">(1)</span>
   private EntityManager em;
   
   @In 
   private User user;
   
   @In(required=false) @Out
   private Hotel hotel;
   
   @In(required=false) 
   @Out(required=false)                                                                  <span class="co">(2)</span>
   private Booking booking;
     
   @In
   private FacesMessages facesMessages;
      
   @In
   private Events events;
   
   @Logger 
   private Log log;
   
   private boolean bookingValid;
   
   @Begin                                                                                <span class="co">(3)</span>
   public void selectHotel(Hotel selectedHotel)
   {
      hotel = em.merge(selectedHotel);
   }
   
   public void bookHotel()
   {      
      booking = new Booking(hotel, user);
      Calendar calendar = Calendar.getInstance();
      booking.setCheckinDate( calendar.getTime() );
      calendar.add(Calendar.DAY_OF_MONTH, 1);
      booking.setCheckoutDate( calendar.getTime() );
   }
   
   public void setBookingDetails()
   {
      Calendar calendar = Calendar.getInstance();
      calendar.add(Calendar.DAY_OF_MONTH, -1);
      if ( booking.getCheckinDate().before( calendar.getTime() ) )
      {
         facesMessages.addToControl("checkinDate", "Check in date must be a future date");
         bookingValid=false;
      }
      else if ( !booking.getCheckinDate().before( booking.getCheckoutDate() ) )
      {
         facesMessages.addToControl("checkoutDate", 
                                    "Check out date must be later than check in date");
         bookingValid=false;
      }
      else
      {
         bookingValid=true;
      }
   }
   
   public boolean isBookingValid()
   {
      return bookingValid;
   }
   
   @End                                                                                  <span class="co">(4)</span>
   public void confirm()
   {
      em.persist(booking);
      facesMessages.add("Thank you, #{user.name}, your confimation number " + 
                        " for #{hotel.name} is #{booking.id}");
      log.info("New booking: #{booking.id} for #{user.username}");
      events.raiseTransactionSuccessEvent("bookingConfirmed");
   }
   
   @End
   public void cancel() {}
   
   @Remove                                                                               <span class="co">(5)</span>
   public void destroy() {}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> This bean uses an EJB3 <span class="emphasis"><em>extended persistence context</em></span>, so that any
                                entity instances remain managed for the whole lifecycle of the stateful session bean.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <a href="#out-annotation">
                                    <tt class="literal">@Out</tt>
                                </a> annotation declares that an attribute value is <span class="emphasis"><em>outjected</em></span> to
                                a context variable after method invocations. In this case, the context variable named
                                    <tt class="literal">hotel</tt> will be set to the value of the <tt class="literal">hotel</tt>
                                instance variable after every action listener invocation completes. </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p> The <a href="#begin-annotation">
                                    <tt class="literal">@Begin</tt>
                                </a> annotation specifies that the annotated method begins a <span class="emphasis"><em>long-running
                                    conversation</em></span>, so the current conversation context will not be destroyed
                                at the end of the request. Instead, it will be reassociated with every request from the
                                current window, and destroyed either by timeout due to conversation inactivity or
                                invocation of a matching <tt class="literal">@End</tt> method. </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p> The <a href="#end-annotation">
                                    <tt class="literal">@End</tt>
                                </a> annotation specifies that the annotated method ends the current long-running
                                conversation, so the current conversation context will be destroyed at the end of the
                                request. </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p> This EJB remove method will be called when Seam destroys the conversation context.
                                Don't forget to define this method! </p></td></tr></table></div></div></div><p>
                <tt class="literal">HotelBookingAction</tt> contains all the action listener methods that implement selection,
                booking and booking confirmation, and holds state related to this work in its instance variables. We
                think you'll agree that this code is much cleaner and simpler than getting and setting
                    <tt class="literal">HttpSession</tt> attributes. </p><p> Even better, a user can have multiple isolated conversations per login session. Try it! Log in, run a
                search, and navigate to different hotel pages in multiple browser tabs. You'll be able to work on
                creating two different hotel reservations at the same time. If you leave any one conversation inactive
                for long enough, Seam will eventually time out that conversation and destroy its state. If, after ending
                a conversation, you backbutton to a page of that conversation and try to perform an action, Seam will
                detect that the conversation was already ended, and redirect you to the search page. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1805"></a>1.6.4.&nbsp;The Seam UI control library</h3></div></div><div></div></div><p> If you check inside the WAR file for the booking application, you'll find
                <tt class="literal">seam-ui.jar</tt> in the <tt class="literal">WEB-INF/lib</tt> directory. This package contains a
                number of JSF custom controls that integrate with Seam. The booking application uses the
                    <tt class="literal">&lt;s:link&gt;</tt> control for navigation from the search screen to the hotel
                page: </p><pre class="programlisting">&lt;s:link value="View Hotel" action="#{hotelBooking.selectHotel(hot)}"/&gt;</pre><p> The use of <tt class="literal">&lt;s:link&gt;</tt> here allows us to attach an action listener to a
                HTML link without breaking the browser's "open in new window" feature. The standard JSF
                    <tt class="literal">&lt;h:commandLink&gt;</tt> does not work with "open in new window". We'll see
                later that <tt class="literal">&lt;s:link&gt;</tt> also offers a number of other useful features,
                including conversation propagation rules. </p><p> The booking application uses some other Seam and RichFaces Ajax controls, especially on the
                    <tt class="literal">/book.xhtml</tt> page. We won't get into the details of those controls here, but if
                you want to understand this code, please refer to the chapter covering Seam's functionality for JSF form
                validation. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1837"></a>1.6.5.&nbsp;The Seam Debug Page</h3></div></div><div></div></div><p> The WAR also includes <tt class="literal">seam-debug.jar</tt>.  The Seam debug page will be availabled 
                if this jar is deployed in
                    <tt class="literal">WEB-INF/lib</tt>, along with the Facelets, and if you set the debug property
                of the <tt class="literal">init</tt> component:</p><pre class="programlisting">&lt;core:init jndi-pattern="@jndiPattern@" debug="true"/&gt;</pre><p>  This page lets you browse and inspect the Seam components
                in any of the Seam contexts associated with your current login session. Just point your browser at
                    <a href="http://localhost:8080/seam-booking/debug.seam" target="_top">
                    <tt class="literal">http://localhost:8080/seam-booking/debug.seam</tt>
                </a>. </p><div class="mediaobject" align="center"><img src="../shared/images/debug.png" align="middle"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dvdstore"></a>1.7.&nbsp;A complete application featuring Seam and jBPM: the DVD Store example</h2></div></div><div></div></div><p> The DVD Store demo application shows the practical usage of jBPM for both task management and pageflow. </p><p> The user screens take advantage of a jPDL pageflow to implement searching and shopping cart
            functionality. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/dvdsearch.png" align="middle"></div></div><p> The administration screens take use jBPM to manage the approval and shipping cycle for orders. The
            business process may even be changed dynamically, by selecting a different process definition! </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/dvdtasks.png" align="middle"></div></div><p>TODO</p><p>Look in the <tt class="literal">dvdstore</tt> directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hibernate"></a>1.8.&nbsp;An example of Seam with Hibernate: the Hibernate Booking example</h2></div></div><div></div></div><p> The Hibernate Booking demo is a straight port of the Booking demo to an alternative architecture that
            uses Hibernate for persistence and JavaBeans instead of session beans. </p><p>TODO</p><p>Look in the <tt class="literal">hibernate</tt> directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blog"></a>1.9.&nbsp;A RESTful Seam application: the Blog example</h2></div></div><div></div></div><p> Seam makes it very easy to implement applications which keep state on the server-side. However,
            server-side state is not always appropriate, especially in for functionality that serves up
                <span class="emphasis"><em>content</em></span>. For this kind of problem we often need to let the user bookmark pages and
            have a relatively stateless server, so that any page can be accessed at any time, via the bookmark. The Blog
            example shows how to a implement RESTful application using Seam. Every page of the application can be
            bookmarked, including the search results page. </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/blog.png" align="middle"></div></div><p> The Blog example demonstrates the use of "pull"-style MVC, where instead of using action listener methods
            to retrieve data and prepare the data for the view, the view pulls data from components as it is being
            rendered. </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1928"></a>1.9.1.&nbsp;Using "pull"-style MVC</h3></div></div><div></div></div><p> This snippet from the <tt class="literal">index.xhtml</tt> facelets page displays a list of recent blog
                entries: </p><div class="example"><a name="d0e1936"></a><p class="title"><b>Example&nbsp;1.26.&nbsp;</b></p><pre class="programlisting">&lt;h:dataTable value="#{blog.recentBlogEntries}" var="blogEntry" rows="3"&gt;
   &lt;h:column&gt;
      &lt;div class="blogEntry"&gt;
         &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
         &lt;div&gt;
            &lt;h:outputText escape="false" 
                  value="#{blogEntry.excerpt==null ? blogEntry.body : blogEntry.excerpt}"/&gt;
         &lt;/div&gt;
         &lt;p&gt;
            &lt;h:outputLink value="entry.seam" rendered="#{blogEntry.excerpt!=null}"&gt;
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
               Read more...
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
         &lt;p&gt;
            [Posted on 
            &lt;h:outputText value="#{blogEntry.date}"&gt;
               &lt;f:convertDateTime timeZone="#{blog.timeZone}" 
                                  locale="#{blog.locale}" type="both"/&gt;
            &lt;/h:outputText&gt;]
            &amp;#160;
            &lt;h:outputLink value="entry.seam"&gt;[Link]
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p> If we navigate to this page from a bookmark, how does the data used by the
                    <tt class="literal">&lt;h:dataTable&gt;</tt> actually get initialized? Well, what happens is that
                the <tt class="literal">Blog</tt> is retrieved lazily&#8212;"pulled"&#8212;when needed, by a Seam
                component named <tt class="literal">blog</tt>. This is the opposite flow of control to what is usual in
                traditional web action-based frameworks like Struts. </p><div class="example"><a name="d0e1950"></a><p class="title"><b>Example&nbsp;1.27.&nbsp;</b></p><div class="programlistingco"><pre class="programlisting">@Name("blog")
@Scope(ScopeType.STATELESS)
@AutoCreate
public class BlogService 
{
   
   @In EntityManager entityManager;                                                      <span class="co">(1)</span>
  
   @Unwrap                                                                               <span class="co">(2)</span>
   public Blog getBlog()
   {
      return (Blog) entityManager.createQuery("select distinct b from Blog b left join fetch b.blogEntries")
            .setHint("org.hibernate.cacheable", true)
            .getSingleResult();
   }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p> This component uses a <span class="emphasis"><em>seam-managed persistence context</em></span>. Unlike
                                the other examples we've seen, this persistence context is managed by Seam, instead of
                                by the EJB3 container. The persistence context spans the entire web request, allowing us
                                to avoid any exceptions that occur when accessing unfetched associations in the view.
                            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p> The <tt class="literal">@Unwrap</tt> annotation tells Seam to provide the return value of
                                the method&#8212;the <tt class="literal">Blog</tt>&#8212;instead of the actual
                                    <tt class="literal">BlogService</tt> component to clients. This is the Seam
                                    <span class="emphasis"><em>manager component pattern</em></span>. </p></td></tr></table></div></div></div><p> This is good so far, but what about bookmarking the result of form submissions, such as a search
                results page? </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1981"></a>1.9.2.&nbsp;Bookmarkable search results page</h3></div></div><div></div></div><p> The blog example has a tiny form in the top right of each page that allows the user to search for
                blog entries. This is defined in a file, <tt class="literal">menu.xhtml</tt>, included by the facelets
                template, <tt class="literal">template.xhtml</tt>: </p><div class="example"><a name="d0e1992"></a><p class="title"><b>Example&nbsp;1.28.&nbsp;</b></p><pre class="programlisting">&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="/search.xhtml"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p> To implement a bookmarkable search results page, we need to perform a browser redirect after
                processing the search form submission. Because we used the JSF view id as the action outcome, Seam
                automatically redirects to the view id when the form is submitted. Alternatively, we could have defined
                a navigation rule like this: </p><div class="example"><a name="d0e1997"></a><p class="title"><b>Example&nbsp;1.29.&nbsp;</b></p><pre class="programlisting">&lt;navigation-rule&gt;
   &lt;navigation-case&gt;
      &lt;from-outcome&gt;searchResults&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/search.xhtml&lt;/to-view-id&gt;
      &lt;redirect/&gt;
   &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p> Then the form would have looked like this: </p><div class="example"><a name="d0e2002"></a><p class="title"><b>Example&nbsp;1.30.&nbsp;</b></p><pre class="programlisting">&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="searchResults"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p> But when we redirect, we need to include the values submitted with the form as request parameters, to
                get a bookmarkable URL like
                <tt class="literal">http://localhost:8080/seam-blog/search.seam?searchPattern=seam</tt>. JSF does not provide
                an easy way to do this, but Seam does. We use a Seam <span class="emphasis"><em>page parameter</em></span>, defined in
                    <tt class="literal">WEB-INF/pages.xml</tt>: </p><div class="example"><a name="d0e2016"></a><p class="title"><b>Example&nbsp;1.31.&nbsp;</b></p><pre class="programlisting">&lt;pages&gt;
   &lt;page view-id="/search.xhtml"&gt;
      &lt;param name="searchPattern" value="#{searchService.searchPattern}"/&gt;
   &lt;/page&gt;
   ...
&lt;/pages&gt;</pre></div><p> This tells Seam to include the value of <tt class="literal">#{searchService.searchPattern}</tt> as a
                request parameter named <tt class="literal">searchPattern</tt> when redirecting to the page, and then re-apply
                the value of that parameter to the model before rendering the page. </p><p> The redirect takes us to the <tt class="literal">search.xhtml</tt> page: </p><div class="example"><a name="d0e2032"></a><p class="title"><b>Example&nbsp;1.32.&nbsp;</b></p><pre class="programlisting">&lt;h:dataTable value="#{searchResults}" var="blogEntry"&gt;
   &lt;h:column&gt;
      &lt;div&gt;
         &lt;h:outputLink value="entry.seam"&gt;
            &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            #{blogEntry.title}
         &lt;/h:outputLink&gt;
         posted on 
         &lt;h:outputText value="#{blogEntry.date}"&gt;
            &lt;f:convertDateTime timeZone="#{blog.timeZone}" locale="#{blog.locale}" type="both"/&gt;
         &lt;/h:outputText&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p> Which again uses "pull"-style MVC to retrieve the actual search results: </p><div class="example"><a name="d0e2037"></a><p class="title"><b>Example&nbsp;1.33.&nbsp;</b></p><pre class="programlisting">@Name("searchService")
public class SearchService 
{
   
   @In
   private EntityManager entityManager;
   
   private String searchPattern;
   
   @Factory("searchResults")
   public List&lt;BlogEntry&gt; getSearchResults()
   {
      if (searchPattern==null)
      {
         return null;
      }
      else
      {
         return entityManager.createQuery("select be from BlogEntry be "" + 
                      "where lower(be.title) like :searchPattern " + 
                      "lower(be.body) like :searchPattern order by be.date desc")
               .setParameter( "searchPattern", getSqlSearchPattern() )
               .setMaxResults(100)
               .getResultList();
      }
   }

   private String getSqlSearchPattern()
   {
      return searchPattern==null ? "" :
             '%' + searchPattern.toLowerCase().replace('*', '%').replace('?', '_') + '%';
   }

   public String getSearchPattern()
   {
      return searchPattern;
   }

   public void setSearchPattern(String searchPattern)
   {
      this.searchPattern = searchPattern;
   }

}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2040"></a>1.9.3.&nbsp;Using "push"-style MVC in a RESTful application</h3></div></div><div></div></div><p> Very occasionally, it makes more sense to use push-style MVC for processing RESTful pages, and so
                Seam provides the notion of a <span class="emphasis"><em>page action</em></span>. The Blog example uses a page action for
                the blog entry page, <tt class="literal">entry.xhtml</tt>. Note that this is a little bit contrived, it would
                have been easier to use pull-style MVC here as well. </p><p> The <tt class="literal">entryAction</tt> component works much like an action class in a traditional
                push-MVC action-oriented framework like Struts: </p><div class="example"><a name="d0e2056"></a><p class="title"><b>Example&nbsp;1.34.&nbsp;</b></p><pre class="programlisting">@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry(String id) throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry(id);
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}</pre></div><p> Page actions are also declared in <tt class="literal">pages.xml</tt>: </p><div class="example"><a name="d0e2064"></a><p class="title"><b>Example&nbsp;1.35.&nbsp;</b></p><pre class="programlisting">&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry(blogEntry.id)}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;

   &lt;page view-id="/post.xhtml" action="#{loginAction.challenge}"/&gt;

   &lt;page view-id="*" action="#{blog.hitCount.hit}"/&gt;

&lt;/pages&gt;</pre></div><p> Notice that the example is using page actions for some other functionality&#8212;the login
                challenge, and the pageview counter. Also notice the use of a parameter in the page action method
                binding. This is not a standard feature of JSF EL, but Seam lets you use it, not just for page actions,
                but also in JSF method bindings. </p><p> When the <tt class="literal">entry.xhtml</tt> page is requested, Seam first binds the page parameter
                    <tt class="literal">blogEntryId</tt> to the model, then runs the page action, which retrieves the needed
                data&#8212;the <tt class="literal">blogEntry</tt>&#8212;and places it in the Seam event context.
                Finally, the following is rendered: </p><div class="example"><a name="d0e2080"></a><p class="title"><b>Example&nbsp;1.36.&nbsp;</b></p><pre class="programlisting">&lt;div class="blogEntry"&gt;
   &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
   &lt;div&gt;
      &lt;h:outputText escape="false" value="#{blogEntry.body}"/&gt;
   &lt;/div&gt;
   &lt;p&gt;
      [Posted on&amp;#160;
      &lt;h:outputText value="#{blogEntry.date}"&gt;
         &lt;f:convertDateTime timezone="#{blog.timeZone}" 
                            locale="#{blog.locale}" type="both"/&gt;
      &lt;/h:outputText&gt;]
   &lt;/p&gt;
&lt;/div&gt;</pre></div><p> If the blog entry is not found in the database, the <tt class="literal">EntryNotFoundException</tt>
                exception is thrown. We want this exception to result in a 404 error, not a 505, so we annotate the
                exception class: </p><div class="example"><a name="d0e2088"></a><p class="title"><b>Example&nbsp;1.37.&nbsp;</b></p><pre class="programlisting">@ApplicationException(rollback=true)
@HttpError(errorCode=HttpServletResponse.SC_NOT_FOUND)
public class EntryNotFoundException extends Exception
{
   EntryNotFoundException(String id)
   {
      super("entry not found: " + id);
   }
}</pre></div><p> An alternative implementation of the example does not use the parameter in the method binding: </p><div class="example"><a name="d0e2093"></a><p class="title"><b>Example&nbsp;1.38.&nbsp;</b></p><pre class="programlisting">@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @In @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry() throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry( blogEntry.getId() );
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}</pre><pre class="programlisting">&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;
   
   ...
&lt;/pages&gt;</pre></div><p> It is a matter of taste which implementation you prefer. </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="gettingstarted"></a>Chapter&nbsp;2.&nbsp;Getting started with Seam, using seam-gen</h2></div></div><div></div></div><p>The Seam distribution includes a command line utility that makes it really easy to set up an Eclipse project,
        generate some simple Seam skeleton code, and reverse engineer an application from a preexisting database.</p><p>This is the easy way to get your feet wet with Seam, and gives you some ammunition for next time you find
        yourself trapped in an elevator with one of those tedious Ruby guys ranting about how great and wonderful his
        new toy is for building totally trivial applications that put things in databases.</p><p>In this release, seam-gen works best for people with JBoss AS. You can use the generated project with other
        J2EE or Java EE 5 application servers by making a few manual changes to the project configuration.</p><p>You <span class="emphasis"><em>can</em></span> use seam-gen without Eclipse, but in this tutorial, we want to show you how to
        use it in conjunction with Eclipse for debugging and integration testing. If you don't want to install Eclipse,
        you can still follow along with this tutorial&#8212;all steps can be performed from the command line.</p><p>Seam-gen is basically just a big ugly Ant script wrapped around Hibernate Tools, together with some templates.
        That makes it easy to customize if you need to.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2116"></a>2.1.&nbsp;Before you start</h2></div></div><div></div></div><p>Make sure you have JDK 5 or JDK 6, JBoss AS 4.2 and Ant 1.6, along with recent versions of Eclipse, the
            JBoss IDE plugin for Eclipse and the TestNG plugin for Eclipse correctly installed before starting. Add your
            JBoss installation to the JBoss Server View in Eclipse. Start JBoss in debug mode. Finally, start a command
            prompt in the directory where you unzipped the Seam distribution.</p><p>JBoss has sophisticated support for hot re-deployment of WARs and EARs. Unfortunately, due to bugs in the
            JVM, repeated redeployment of an EAR&#8212;which is common during development&#8212;eventually causes the JVM to run out
            of perm gen space. For this reason, we recommend running JBoss in a JVM with a large perm gen space at
            development time. If you're running JBoss from JBoss IDE, you can configure this in the server launch
            configuration, under "VM arguments". We suggest the following values:</p><pre class="programlisting">-Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512</pre><p>If you don't have so much memory available, the following is our minimum recommendation:</p><pre class="programlisting">-Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256</pre><p>If you're running JBoss from the command line, you can configure the JVM options in
            <tt class="literal">bin/run.conf</tt>.</p><p>If you don't want to bother with this stuff now, you don't have to&#8212;come back to it later, when you get
            your first <tt class="literal">OutOfMemoryException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2139"></a>2.2.&nbsp;Setting up a new Eclipse project</h2></div></div><div></div></div><p>The first thing we need to do is configure seam-gen for your environment: JBoss AS installation directory,
            Eclipse workspace, and database connection. It's easy, just type:</p><pre class="programlisting">cd jboss-seam-2.0.x
seam setup</pre><p>And you will be prompted for the needed information:</p><pre class="programlisting">C:\Projects\jboss-seam&gt;seam setup
Buildfile: build.xml

setup:
    [echo] Welcome to seam-gen :-)
    [input] Enter your Java project workspace [C:/Projects]

    [input] Enter your JBoss home directory [C:/Program Files/jboss-4.2.0.GA]

    [input] Enter the project name [myproject]
helloworld
    [input] Is this project deployed as an EAR (with EJB components) or a WAR (with no EJB support) [ear] (ear,war,)

    [input] Enter the Java package name for your session beans [com.mydomain.helloworld]
org.jboss.helloworld
    [input] Enter the Java package name for your entity beans [org.jboss.helloworld]

    [input] Enter the Java package name for your test cases [org.jboss.helloworld.test]

    [input] What kind of database are you using? [hsql] (hsql,mysql,oracle,postgres,mssql,db2,sybase,)
mysql
    [input] Enter the Hibernate dialect for your database [org.hibernate.dialect.MySQLDialect]

    [input] Enter the filesystem path to the JDBC driver jar [lib/hsqldb.jar]
../../mysql-connector.jar
    [input] Enter JDBC driver class for your database [com.mysql.jdbc.Driver]

    [input] Enter the JDBC URL for your database [jdbc:mysql:///test]

    [input] Enter database username [sa]
gavin
    [input] Enter database password []

    [input] skipping input as property hibernate.default_schema.new has already been set.
    [input] Enter the database catalog name (it is OK to leave this blank) []

    [input] Are you working with tables that already exist in the database? [n] (y,n,)
y
    [input] Do you want to drop and recreate the database tables and data in import.sql each time you deploy? [n] (y,n,)
n
[propertyfile] Creating new property file: C:\Projects\jboss-seam\seam-gen\build.properties
     [echo] Installing JDBC driver jar to JBoss server
     [echo] Type 'seam new-project' to create the new project

BUILD SUCCESSFUL
Total time: 1 minute 17 seconds
C:\Projects\jboss-seam&gt;</pre><p>The tool provides sensible defaults, which you can accept by just pressing enter at the prompt.</p><p>The most important choice you need to make is between EAR deployment and WAR deployment of your project.
            EAR projects support EJB 3.0 and require Java EE 5. WAR projects do not support EJB 3.0, but may be deployed
            to a J2EE environment. The packaging of a WAR is also simpler to understand. If you installed an EJB3-ready
            application server like JBoss, choose <tt class="literal">ear</tt>. Otherwise, choose <tt class="literal">war</tt>.
            We'll assume that you've chosen an EAR deployment for the rest of the tutorial, but you can follow exactly
            the same steps for a WAR deployment.</p><p>If you are working with an existing data model, make sure you tell seam-gen that the tables already exist
            in the database.</p><p>The settings are stored in <tt class="literal">seam-gen/build.properties</tt>, but you can also modify them
            simply by running <tt class="literal">seam setup</tt> a second time.</p><p>Now we can create a new project in our Eclipse workspace directory, by typing:</p><pre class="programlisting">seam new-project</pre><pre class="programlisting">C:\Projects\jboss-seam&gt;seam new-project
Buildfile: build.xml

validate-workspace:

validate-project:

copy-lib:
     [echo] Copying project jars ...
     [copy] Copying 58 files to C:\Projects\helloworld\lib
     [copy] Copying 9 files to C:\Projects\helloworld\embedded-ejb

file-copy-war:

file-copy-ear:
     [echo] Copying resources needed for EAR deployment to the C:\Projects\helloworld/resources directory...

new-project:
     [echo] A new Seam project named 'helloworld' was created in the C:\Projects directory
     [echo] Type 'seam explode' and go to http://localhost:8080/helloworld
     [echo] Eclipse Users: Add the project into Eclipse using File &gt; New &gt; Project and select General &gt; Project (not Java Project)
     [echo] NetBeans Users: Open the project in NetBeans

BUILD SUCCESSFUL
Total time: 7 seconds
C:\Projects\jboss-seam&gt;</pre><p>This copies the Seam jars, dependent jars and the JDBC driver jar to a new Eclipse project, and generates
            all needed resources and configuration files, a facelets template file and stylesheet, along with Eclipse
            metadata and an Ant build script. The Eclipse project will be automatically deployed to an exploded
            directory structure in JBoss AS as soon as you add the project using <tt class="literal">New -&gt; Project...
                -&gt; General -&gt; Project -&gt; Next</tt>, typing the <tt class="literal">Project name</tt>
                (<tt class="literal">helloworld</tt> in this case), and then clicking <tt class="literal">Finish</tt>. Do not select
                <tt class="literal">Java Project</tt> from the New Project wizard.</p><p>If your default JDK in Eclipse is not a Java SE 5 or Java SE 6 JDK, you will need to select a Java SE 5
            compliant JDK using <tt class="literal">Project -&gt; Properties -&gt; Java Compiler</tt>.</p><p>Alternatively, you can deploy the project from outside Eclipse by typing <tt class="literal">seam explode</tt>.</p><p>Go to <tt class="literal">http://localhost:8080/helloworld</tt> to see a welcome page. This is a facelets page,
                <tt class="literal">view/home.xhtml</tt>, using the template <tt class="literal">view/layout/template.xhtml</tt>.
            You can edit this page, or the template, in eclipse, and see the results <span class="emphasis"><em>immediately</em></span>,
            by clicking refresh in your browser.</p><p>Don't get scared by the XML configuration documents that were generated into the project directory. They
            are mostly standard Java EE stuff, the stuff you need to create once and then never look at again, and they
            are 90% the same between all Seam projects. (They are so easy to write that even seam-gen can do it.)</p><p>The generated project includes three database and persistence configurations. The
            <tt class="literal">jboss-beans.xml</tt>, <tt class="literal">persistence-test.xml</tt> and
            <tt class="literal">import-test.sql</tt> files are used when running the TestNG unit tests against HSQLDB. The
            database schema and the test data in <tt class="literal">import-test.sql</tt> is always exported to the database
            before running tests. The <tt class="literal">myproject-dev-ds.xml</tt>, <tt class="literal">persistence-dev.xml</tt>and
                <tt class="literal">import-dev.sql</tt> files are for use when deploying the application to your development
            database. The schema might be exported automatically at deployment, depending upon whether you told seam-gen
            that you are working with an existing database. The <tt class="literal">myproject-prod-ds.xml</tt>,
                <tt class="literal">persistence-prod.xml</tt>and <tt class="literal">import-prod.sql</tt> files are for use when
            deploying the application to your production database. The schema is not exported automatically at
            deployment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2251"></a>2.3.&nbsp;Creating a new action</h2></div></div><div></div></div><p>If you're used to traditional action-style web frameworks, you're probably wondering how you can create a
            simple web page with a stateless action method in Java. If you type:</p><pre class="programlisting">seam new-action</pre><p>Seam will prompt for some information, and generate a new facelets page and Seam component for your
            project.</p><pre class="programlisting">C:\Projects\jboss-seam&gt;seam new-action
Buildfile: build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
ping
    [input] Enter the local interface name [Ping]

    [input] Enter the bean class name [PingBean]

    [input] Enter the action method name [ping]

    [input] Enter the page name [ping]


setup-filters:

new-action:
     [echo] Creating a new stateless session bean component with an action method
     [copy] Copying 1 file to C:\Projects\helloworld\src\action\org\jboss\helloworld
     [copy] Copying 1 file to C:\Projects\helloworld\src\action\org\jboss\helloworld
     [copy] Copying 1 file to C:\Projects\helloworld\src\action\org\jboss\helloworld\test
     [copy] Copying 1 file to C:\Projects\helloworld\src\action\org\jboss\helloworld\test
     [copy] Copying 1 file to C:\Projects\helloworld\view
     [echo] Type 'seam restart' and go to http://localhost:8080/helloworld/ping.seam

BUILD SUCCESSFUL
Total time: 13 seconds
C:\Projects\jboss-seam&gt;</pre><p>Because we've added a new Seam component, we need to restart the exploded directory deployment. You can do
            this by typing <tt class="literal">seam restart</tt>, or by running the <tt class="literal">restart</tt> target in the
            generated project <tt class="literal">build.xml</tt> file from inside Eclipse. Another way to force a restart is
            to edit the file <tt class="literal">resources/META-INF/application.xml</tt> in Eclipse. <span class="emphasis"><em>Note that you
                do not need to restart JBoss each time you change the application.</em></span></p><p>Now go to <tt class="literal">http://localhost:8080/helloworld/ping.seam</tt> and click the button. You can see
            the code behind this action by looking in the project <tt class="literal">src</tt> directory. Put a breakpoint in
            the <tt class="literal">ping()</tt> method, and click the button again.</p><p>Finally, locate the <tt class="literal">PingTest.xml</tt> file in the test package and run the integration tests
            using the TestNG plugin for Eclipse. Alternatively, run the tests using <tt class="literal">seam test</tt> or the
                <tt class="literal">test</tt> target of the generated build.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2300"></a>2.4.&nbsp;Creating a form with an action</h2></div></div><div></div></div><p>The next step is to create a form. Type:</p><pre class="programlisting">seam new-form</pre><pre class="programlisting">C:\Projects\jboss-seam&gt;seam new-form
Buildfile: C:\Projects\jboss-seam\seam-gen\build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
hello
    [input] Enter the local interface name [Hello]

    [input] Enter the bean class name [HelloBean]

    [input] Enter the action method name [hello]

    [input] Enter the page name [hello]


setup-filters:

new-form:
     [echo] Creating a new stateful session bean component with an action method
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\view
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [echo] Type 'seam restart' and go to http://localhost:8080/hello/hello.seam

BUILD SUCCESSFUL
Total time: 5 seconds
C:\Projects\jboss-seam&gt;</pre><p>Restart the application again, and go to <tt class="literal">http://localhost:8080/helloworld/hello.seam</tt>.
            Then take a look at the generated code. Run the test. Try adding some new fields to the form and Seam
            component (remember to restart the deployment each time you change the Java code).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2314"></a>2.5.&nbsp;Generating an application from an existing database</h2></div></div><div></div></div><p>Manually create some tables in your database. (If you need to switch to a different database, just run
                <tt class="literal">seam setup</tt> again.) Now type:</p><pre class="programlisting">seam generate-entities</pre><p>Restart the deployment, and go to <tt class="literal">http://localhost:8080/helloworld</tt>. You can browse the
            database, edit existing objects, and create new objects. If you look at the generated code, you'll probably
            be amazed how simple it is! Seam was designed so that data access code is easy to write by hand, even for
            people who don't want to cheat by using seam-gen.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2329"></a>2.6.&nbsp;Deploying the application as an EAR</h2></div></div><div></div></div><p>Finally, we want to be able to deploy the application using standard Java EE 5 packaging. First, we need
            to remove the exploded directory by running <tt class="literal">seam unexplode</tt>. To deploy the EAR, we can
            type <tt class="literal">seam deploy</tt> at the command prompt, or run the <tt class="literal">deploy</tt> target of
            the generated project build script. You can undeploy using <tt class="literal">seam undeploy</tt> or the
                <tt class="literal">undeploy</tt> target.</p><p>By default, the application will be deployed with the <span class="emphasis"><em>dev profile</em></span>. The EAR will
            include the <tt class="literal">persistence-dev.xml</tt> and <tt class="literal">import-dev.sql</tt> files, and the
                <tt class="literal">myproject-dev-ds.xml</tt> file will be deployed. You can change the profile, and use the
                <span class="emphasis"><em>prod profile</em></span>, by typing</p><pre class="programlisting">seam -Dprofile=prod deploy</pre><p>You can even define new deployment profiles for your application. Just add appropriately named files to
            your project&#8212;for example, <tt class="literal">persistence-staging.xml</tt>, <tt class="literal">import-staging.sql</tt>
            and <tt class="literal">myproject-staging-ds.xml</tt>&#8212;and select the name of the profile using
                <tt class="literal">-Dprofile=staging</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gettingstarted-hotdeployment"></a>2.7.&nbsp;Seam and incremental hot deployment</h2></div></div><div></div></div><p>When you deploy your Seam application as an exploded directory, you'll get some support for incremental
            hot deployment at development time. You need to enable debug mode in both Seam and Facelets, by adding this
            line to <tt class="literal">components.xml</tt>:</p><pre class="programlisting">&lt;core:init debug="true"/&gt;</pre><p>Now, the following files may be redeployed without requiring a full restart of the web application:</p><div class="itemizedlist"><ul type="disc"><li><p>any facelets page</p></li><li><p>any <tt class="literal">pages.xml</tt> file</p></li></ul></div><p>But if we want to change any Java code, we still need to do a full restart of the application. (In JBoss
            this may be accomplished by touching the top level deployment descriptor: <tt class="literal">application.xml</tt>
            for an EAR deployment, or <tt class="literal">web.xml</tt> for a WAR deployment.)</p><p>But if you really want a fast edit/compile/test cycle, Seam supports incremental redeployment of JavaBean
            components. To make use of this functionality, you must deploy the JavaBean components into the
                <tt class="literal">WEB-INF/dev</tt> directory, so that they will be loaded by a special Seam classloader,
            instead of by the WAR or EAR classloader.</p><p>You need to be aware of the following limitations:</p><div class="itemizedlist"><ul type="disc"><li><p>the components must be JavaBean components, they cannot be EJB3 beans (we are working on fixing
                    this limitation)</p></li><li><p>entities can never be hot-deloyed</p></li><li><p>components deployed via <tt class="literal">components.xml</tt> may not be hot-deployed</p></li><li><p>the hot-deployable components will not be visible to any classes deployed outside of
                        <tt class="literal">WEB-INF/dev</tt></p></li><li><p>Seam debug mode must be enabled</p></li></ul></div><p>If you create a WAR project using seam-gen, incremental hot deployment is available out of the box for
            classes in the <tt class="literal">src/action</tt> source directory. However, seam-gen does not support
            incremental hot deployment for EAR projects.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2445"></a>2.8.&nbsp;Using Seam with JBoss 4.0</h2></div></div><div></div></div><p> Seam 2.0 was developed for JavaServer Faces 1.2. When using JBoss AS, we recommend using JBoss 4.2, which
            bundles the JSF 1.2 reference implementation. However, it is still possible to use Seam 2.0 on the JBoss 4.0
            platform. There are two basic steps required to do this: install an EJB3-enabled version of JBoss 4.0 and
            replace MyFaces with the JSF 1.2 reference implementation.  Once you complete these steps, Seam 2.0 
            applications can be deployed to JBoss 4.0.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2450"></a>2.8.1.&nbsp;Install JBoss 4.0</h3></div></div><div></div></div><p>JBoss 4.0 does not ship a default configuration compatible with Seam. To run Seam, you must install
                JBoss 4.0.5 using the JEMS 1.2 installer with the ejb3 profile selected. Seam will not run with an
                installation that doesn't include EJB3 support. The JEMS installer can be downloaded from <a href="http://labs.jboss.com/jemsinstaller/downloads" target="_top">http://labs.jboss.com/jemsinstaller/downloads</a>. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2458"></a>2.8.2.&nbsp;Install the JSF 1.2 RI</h3></div></div><div></div></div><p> The web configuration for JBoss 4.0 can be found in the
                    <tt class="literal">server/default/deploy/jbossweb-tomcat55.sar</tt>. You'll need to delete
                    <tt class="literal">myfaces-api.jar</tt> any <tt class="literal">myfaces-impl.jar</tt> from the
                    <tt class="literal">jsf-libs </tt>directory. Then, you'll need to copy <tt class="literal">jsf-api.jar</tt>,
                    <tt class="literal">jsf-impl.jar</tt>, <tt class="literal">el-api.jar</tt>, and <tt class="literal">el-ri.jar</tt>
                to that directory. The JSF JARs can be found in the Seam <tt class="literal">lib</tt> directory. The el JARs
                can be obtained from the Seam 1.2 release. </p><p>You'll also need to edit the <tt class="literal">conf/web.xml</tt>, replacing
                <tt class="literal">myfaces-impl.jar</tt> with <tt class="literal">jsf-impl.jar</tt>. </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="concepts"></a>Chapter&nbsp;3.&nbsp;The contextual component model</h2></div></div><div></div></div><p> 
        The two core concepts in Seam are the notion of a <span class="emphasis"><em>context</em></span> and the notion of a
        <span class="emphasis"><em>component</em></span>. Components are stateful objects, usually EJBs, and an instance of a
        component is associated with a context, and given a name in that context. <span class="emphasis"><em>Bijection</em></span>
        provides a mechanism for aliasing internal component names (instance variables) to contextual names, allowing
        component trees to be dynamically assembled, and reassembled by Seam.
    </p><p>
        Let's start by describing the contexts built in to Seam.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2517"></a>3.1.&nbsp;Seam contexts</h2></div></div><div></div></div><p> Seam contexts are created and destroyed by the framework. The application does not control context
            demarcation via explicit Java API calls. Context are usually implicit. In some cases, however, contexts are
            demarcated via annotations. </p><p> The basic Seam contexts are: </p><div class="itemizedlist"><ul type="disc"><li><p> Stateless context </p></li><li><p> Event (or request) context </p></li><li><p> Page context </p></li><li><p> Conversation context </p></li><li><p> Session context </p></li><li><p> Business process context </p></li><li><p> Application context </p></li></ul></div><p> 
            You will recognize some of these contexts from servlet and related specifications. However, two of them
            might be new to you: <span class="emphasis"><em>conversation context</em></span>, and <span class="emphasis"><em>business process
            context</em></span>. One reason state management in web applications is so fragile and error-prone is that
            the three built-in contexts (request, session and application) are not especially meaningful from the point
            of view of the business logic. A user login session, for example, is a fairly arbitrary construct in terms
            of the actual application work flow. Therefore, most Seam components are scoped to the conversation or
            business process contexts, since they are the contexts which are most meaningful in terms of the
            application.
        </p><p>
            Let's look at each context in turn.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2556"></a>3.1.1.&nbsp;Stateless context</h3></div></div><div></div></div><p>
                Components which are truly stateless (stateless session beans, primarily) always live in the
                stateless context (this is really a non-context). Stateless components are not very interesting, and are
                arguably not very object-oriented. Nevertheless, they are important and often useful.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2561"></a>3.1.2.&nbsp;Event context</h3></div></div><div></div></div><p>
                The event context is the "narrowest" stateful context, and is a generalization of the notion of the
                web request context to cover other kinds of events. Nevertheless, the event context associated with the
                lifecycle of a JSF request is the most important example of an event context, and the one you will work
                with most often. Components associated with the event context are destroyed at the end of the request,
                but their state is available and well-defined for at least the lifecycle of the request.
            </p><p> 
                When you invoke a Seam component via RMI, or Seam Remoting, the event context is created and
                destroyed just for the invocation.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2568"></a>3.1.3.&nbsp;Page context</h3></div></div><div></div></div><p>
                The page context allows you to associate state with a particular instance of a rendered page. You can
                initialize state in your event listener, or while actually rendering the page, and then have access to
                it from any event that originates from that page. This is especially useful for functionality like
                clickable lists, where the list is backed by changing data on the server side. The state is actually
                serialized to the client, so this construct is extremely robust with respect to multi-window operation
                and the back button.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2573"></a>3.1.4.&nbsp;Conversation context</h3></div></div><div></div></div><p>
                The conversation context is a truly central concept in Seam. A <span class="emphasis"><em>conversation</em></span> is a
                unit of work from the point of view of the user. It might span several interactions with the user,
                several requests, and several database transactions. But to the user, a conversation solves a single
                problem. For example, "book hotel", "approve contract", "create order" are all conversations. You might
                like to think of a conversation implementing a single "use case" or "user story", but the relationship 
                is not necessarily quite exact.
            </p><p>
                A conversation holds state associated with "what the user is doing now, in this window". A single
                user may have multiple conversations in progress at any point in time, usually in multiple windows. The
                conversation context allows us to ensure that state from the different conversations does not collide
                and cause bugs.
            </p><p>
                It might take you some time to get used to thinking of applications in terms of conversations. But
                once you get used to it, we think you'll love the notion, and never be able to not think in terms of
                conversations again!
            </p><p>
                Some conversations last for just a single request. Conversations that span multiple requests must be
                demarcated using annotations provided by Seam.
            </p><p>
                Some conversations are also <span class="emphasis"><em>tasks</em></span>. A task is a conversation that is significant
                in terms of a long-running business process, and has the potential to trigger a business process state
                transition when it is successfully completed. Seam provides a special set of annotations for task
                demarcation.
            </p><p>
                Conversations may be <span class="emphasis"><em>nested</em></span>, with one conversation taking place "inside" a wider
                conversation. This is an advanced feature.
            </p><p>
                Usually, conversation state is actually held by Seam in the servlet session between requests. Seam
                implements configurable <span class="emphasis"><em>conversation timeout</em></span>, automatically destroying inactive
                conversations, and thus ensuring that the state held by a single user login session does not grow
                without bound if the user abandons conversations.
            </p><p>
                Seam serializes processing of concurrent requests that take place in the same long-running
                conversation context, in the same process.
            </p><p>
                Alternatively, Seam may be configured to keep conversational state in the client browser.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2606"></a>3.1.5.&nbsp;Session context</h3></div></div><div></div></div><p>
                A session context holds state associated with the user login session. While there are some cases
                where it is useful to share state between several conversations, we generally frown on the use of
                session context for holding components other than global information about the logged in user.
            </p><p> 
                In a JSR-168 portal environment, the session context represents the portlet session. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2613"></a>3.1.6.&nbsp;Business process context</h3></div></div><div></div></div><p> 
                The business process context holds state associated with the long running business process. This
                state is managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple
                interactions with multiple users, so this state is shared between multiple users, but in a well-defined
                manner. The current task determines the current business process instance, and the lifecycle of the
                business process is defined externally using a <span class="emphasis"><em>process definition language</em></span>, so
                there are no special annotations for business process demarcation. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2621"></a>3.1.7.&nbsp;Application context</h3></div></div><div></div></div><p> 
                The application context is the familiar servlet context from the servlet spec. Application context is
                mainly useful for holding static information such as configuration data, reference data or metamodels.
                For example, Seam stores its own configuration and metamodel in the application context. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2626"></a>3.1.8.&nbsp;Context variables</h3></div></div><div></div></div><p> 
                A context defines a namespace, a set of <span class="emphasis"><em>context variables</em></span>. These work much the
                same as session or request attributes in the servlet spec. You may bind any value you like to a context
                variable, but usually we bind Seam component instances to context variables. 
            </p><p> 
                So, within a context, a component instance is identified by the context variable name (this is
                usually, but not always, the same as the component name). You may programatically access a named
                component instance in a particular scope via the <tt class="literal">Contexts</tt> class, which provides
                access to several thread-bound instances of the <tt class="literal">Context</tt> interface: 
            </p><pre class="programlisting">User user = (User) Contexts.getSessionContext().get("user");</pre><p>
                You may also set or change the value associated with a name: 
            </p><pre class="programlisting">Contexts.getSessionContext().set("user", user);</pre><p> 
                Usually, however, we obtain components from a context via injection, and put component instances into
                a context via outjection. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2650"></a>3.1.9.&nbsp;Context search priority</h3></div></div><div></div></div><p> 
                Sometimes, as above, component instances are obtained from a particular known scope. Other times, all
                stateful scopes are searched, in <span class="emphasis"><em>priority order</em></span>. The order is as follows: 
            </p><div class="itemizedlist"><ul type="disc"><li><p> Event context </p></li><li><p> Page context </p></li><li><p> Conversation context </p></li><li><p> Session context </p></li><li><p> Business process context </p></li><li><p> Application context </p></li></ul></div><p> 
                You can perform a priority search by calling <tt class="literal">Contexts.lookupInStatefulContexts()</tt>.
                Whenever you access a component by name from a JSF page, a priority search occurs. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="concurrency"></a>3.1.10.&nbsp;Concurrency model</h3></div></div><div></div></div><p> 
                Neither the servlet nor EJB specifications define any facilities for managing concurrent requests
                originating from the same client. The servlet container simply lets all threads run concurrently and
                leaves enforcing threadsafeness to application code. The EJB container allows stateless components to be
                accessed concurrently, and throws an exception if multiple threads access a stateful session bean. 
            </p><p> 
                This behavior might have been okay in old-style web applications which were based around
                fine-grained, synchronous requests. But for modern applications which make heavy use of many
                fine-grained, asynchronous (AJAX) requests, concurrency is a fact of life, and must be supported by the
                programming model. Seam weaves a concurrency management layer into its context model. 
            </p><p> 
                The Seam session and application contexts are multithreaded. Seam will allow concurrent requests in a
                context to be processed concurrently. The event and page contexts are by nature single threaded. The
                business process context is strictly speaking multi-threaded, but in practice concurrency is
                sufficiently rare that this fact may be disregarded most of the time. Finally, Seam enforces a
                <span class="emphasis"><em>single thread per conversation per process</em></span> model for the conversation context
                by serializing concurrent requests in the same long-running conversation context. 
            </p><p> 
                Since the session context is multithreaded, and often contains volatile state, session scope
                components are always protected by Seam from concurrent access. Seam serializes requests to session
                scope session beans and JavaBeans by default (and detects and breaks any deadlocks that occur). This is
                not the default behaviour for application scoped components however, since application scoped components
                do not usually hold volatile state and because synchronization at the global level is
                <span class="emphasis"><em>extremely</em></span> expensive. However, you can force a serialized threading model on any
                session bean or JavaBean component by adding the <tt class="literal">@Synchronized</tt> annotation. 
            </p><p> 
                This concurrency model means that AJAX clients can safely use volatile session and conversational
                state, without the need for any special work on the part of the developer.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2704"></a>3.2.&nbsp;Seam components</h2></div></div><div></div></div><p> 
            Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0
            enterprise beans. While Seam does not require that components be EJBs and can even be used without an EJB
            3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration with EJB 3.0.
            Seam supports the following <span class="emphasis"><em>component types</em></span>. 
        </p><div class="itemizedlist"><ul type="disc"><li><p> EJB 3.0 stateless session beans </p></li><li><p> EJB 3.0 stateful session beans </p></li><li><p> EJB 3.0 entity beans </p></li><li><p> JavaBeans </p></li><li><p> EJB 3.0 message-driven beans </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2728"></a>3.2.1.&nbsp;Stateless session beans</h3></div></div><div></div></div><p> 
                Stateless session bean components are not able to hold state across multiple invocations. Therefore,
                they usually work by operating upon the state of other components in the various Seam contexts. They may
                be used as JSF action listeners, but cannot provide properties to JSF components for display. 
            </p><p> 
                Stateless session beans always live in the stateless context. 
            </p><p> 
                Stateless session beans can be accessed concurrently as a new instance is used for each request. 
                Assigning the instance to the request is the responsibility of the EJB3 container (normally instances
                will be allocated from a reusable pool meaning that you may find any instance variables contain data
                from previous uses of the bean). 
            </p><p> 
                Stateless session beans are the least interesting kind of Seam component. 
            </p><p>
                Seam stateless session bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated via JNDI lookup
                or the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2750"></a>3.2.2.&nbsp;Stateful session beans</h3></div></div><div></div></div><p> 
                Stateful session bean components are able to hold state not only across multiple invocations of the
                bean, but also across multiple requests. Application state that does not belong in the database should
                usually be held by stateful session beans. This is a major difference between Seam and many other web
                application frameworks. Instead of sticking information about the current conversation directly in the
                <tt class="literal">HttpSession</tt>, you should keep it in instance variables of a stateful session bean
                that is bound to the conversation context. This allows Seam to manage the lifecycle of this state for
                you, and ensure that there are no collisions between state relating to different concurrent
                conversations. 
            </p><p> 
                Stateful session beans are often used as JSF action listener, and as backing beans that provide
                properties to JSF components for display or form submission. 
            </p><p> 
                By default, stateful session beans are bound to the conversation context. They may never be bound to
                the page or stateless contexts. 
            </p><p> 
                Concurrent requests to session-scoped stateful session beans are always serialized by Seam. 
            </p><p>
                Seam stateful session bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated via JNDI lookup
                or the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2775"></a>3.2.3.&nbsp;Entity beans</h3></div></div><div></div></div><p> 
                Entity beans may be bound to a context variable and function as a seam component. Because entities
                have a persistent identity in addition to their contextual identity, entity instances are usually bound
                explicitly in Java code, rather than being instantiated implicitly by Seam. 
            </p><p> 
                Entity bean components do not support bijection or context demarcation. Nor does invocation of an
                entity bean trigger validation. 
            </p><p> 
                Entity beans are not usually used as JSF action listeners, but do often function as backing beans
                that provide properties to JSF components for display or form submission. In particular, it is common to
                use an entity as a backing bean, together with a stateless session bean action listener to implement
                create/update/delete type functionality. 
            </p><p>
                By default, entity beans are bound to the conversation context. They may never be bound to the
                stateless context. 
            </p><p> 
                Note that it in a clustered environment is somewhat less efficient to bind an entity bean directly to
                a conversation or session scoped Seam context variable than it would be to hold a reference to the
                entity bean in a stateful session bean. For this reason, not all Seam applications define entity beans
                to be Seam components. 
            </p><p>
                Seam entity bean components may be instantiated using <tt class="literal">Component.getInstance()</tt>,
                <tt class="literal">@In(create=true)</tt> or directly using the <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2799"></a>3.2.4.&nbsp;JavaBeans</h3></div></div><div></div></div><p> 
                Javabeans may be used just like a stateless or stateful session bean. However, they do not provide
                the functionality of a session bean (declarative transaction demarcation, declarative security,
                efficient clustered state replication, EJB 3.0 persistence, timeout methods, etc). 
            </p><p> 
                In a later chapter, we show you how to use Seam and Hibernate without an EJB container. In this use
                case, components are JavaBeans instead of session beans. Note, however, that in many application servers
                it is somewhat less efficient to cluster conversation or session scoped Seam JavaBean components than it
                is to cluster stateful session bean components. 
            </p><p> 
                By default, JavaBeans are bound to the event context. 
            </p><p> 
                Concurrent requests to session-scoped JavaBeans are always serialized by Seam. 
            </p><p>
                Seam JavaBean components may be instantiated using <tt class="literal">Component.getInstance()</tt>
                or <tt class="literal">@In(create=true)</tt>. They should not be directly instantiated using the 
                <tt class="literal">new</tt> operator.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2821"></a>3.2.5.&nbsp;Message-driven beans</h3></div></div><div></div></div><p> 
                Message-driven beans may function as a seam component. However, message-driven beans are called quite
                differently to other Seam components - instead of invoking them via the context variable, they listen
                for messages sent to a JMS queue or topic. 
            </p><p> 
                Message-driven beans may not be bound to a Seam context. Nor do they have access to the session or
                conversation state of their "caller". However, they do support bijection and some other Seam
                functionality. 
            </p><p>
                Message-driven beans are never instantiated by the application. They are instantiated by the EJB
                container when a message is received.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2830"></a>3.2.6.&nbsp;Interception</h3></div></div><div></div></div><p> 
                In order to perform its magic (bijection, context demarcation, validation, etc), Seam must intercept
                component invocations. For JavaBeans, Seam is in full control of instantiation of the component, and no
                special configuration is needed. For entity beans, interception is not required since bijection and
                context demarcation are not defined. For session beans, we must register an EJB interceptor for the
                session bean component. We could use an annotation, as follows: 
            </p><pre class="programlisting">@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                But a much better way is to define the interceptor in <tt class="literal">ejb-jar.xml</tt>. 
            </p><pre class="programlisting">&lt;interceptors&gt;
   &lt;interceptor&gt;
      &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
   &lt;/interceptor&gt;
&lt;/interceptors&gt;
   
&lt;assembly-descriptor&gt;
   &lt;interceptor-binding&gt;
      &lt;ejb-name&gt;*&lt;/ejb-name&gt;
      &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
   &lt;/interceptor-binding&gt;
&lt;/assembly-descriptor&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2844"></a>3.2.7.&nbsp;Component names</h3></div></div><div></div></div><p> 
                All seam components need a name. We can assign a name to a component using the
                <tt class="literal">@Name</tt> annotation: 
            </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                This name is the <span class="emphasis"><em>seam component name</em></span> and is not related to any other name
                defined by the EJB specification. However, seam component names work just like JSF managed bean names
                and you can think of the two concepts as identical. 
            </p><p>
                <tt class="literal">@Name</tt> is not the only way to define a component name, but we always need
                to specify the name <span class="emphasis"><em>somewhere</em></span>. If we don't, then none of the other
                Seam annotations will function.
            </p><p> 
                Just like in JSF, a seam component instance is usually bound to a context variable with the same name
                as the component name. So, for example, we would access the <tt class="literal">LoginAction</tt> using
                <tt class="literal">Contexts.getStatelessContext().get("loginAction")</tt>. In particular, whenever Seam
                itself instantiates a component, it binds the new instance to a variable with the component name.
                However, again like JSF, it is possible for the application to bind a component to some other context
                variable by programmatic API call. This is only useful if a particular component serves more than one
                role in the system. For example, the currently logged in <tt class="literal">User</tt> might be bound to the
                <tt class="literal">currentUser</tt> session context variable, while a <tt class="literal">User</tt> that is the
                subject of some administration functionality might be bound to the <tt class="literal">user</tt> conversation
                context variable. 
            </p><p> 
                For very large applications, and for built-in seam components, qualified names are often used. 
            </p><pre class="programlisting">@Name("com.jboss.myapp.loginAction")
@Stateless
public class LoginAction implements Login { 
    ... 
}</pre><p> 
                We may use the qualified component name both in Java code and in JSF's expression language: 
            </p><pre class="programlisting">&lt;h:commandButton type="submit" value="Login"
                 action="#{com.jboss.myapp.loginAction.login}"/&gt;</pre><p> 
                Since this is noisy, Seam also provides a means of aliasing a qualified name to a simple name. Add a
                line like this to the <tt class="literal">components.xml</tt> file: 
            </p><pre class="programlisting">&lt;factory name="loginAction" scope="STATELESS" value="#{com.jboss.myapp.loginAction}"/&gt;</pre><p> 
                All of the built-in Seam components have qualified names, but most of them are aliased to a simple
                name by the <tt class="literal">components.xml</tt> file included in the Seam jar. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2907"></a>3.2.8.&nbsp;Defining the component scope</h3></div></div><div></div></div><p> 
                We can override the default scope (context) of a component using the <tt class="literal">@Scope</tt>
                annotation. This lets us define what context a component instance is bound to, when it is instantiated
                by Seam. 
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(SESSION)
public class User { 
    ... 
}</pre><p>
                <tt class="literal">org.jboss.seam.ScopeType</tt> defines an enumeration of possible scopes.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2922"></a>3.2.9.&nbsp;Components with multiple roles</h3></div></div><div></div></div><p> 
                Some Seam component classes can fulfill more than one role in the system. For example, we often have
                a <tt class="literal">User</tt> class which is usually used as a session-scoped component representing the
                current user but is used in user administration screens as a conversation-scoped component. The
                <tt class="literal">@Role</tt> annotation lets us define an additional named role for a component, with a
                different scope&#8212;it lets us bind the same component class to different context variables. (Any
                Seam component <span class="emphasis"><em>instance</em></span> may be bound to multiple context variables, but this lets
                us do it at the class level, and take advantage of auto-instantiation.) 
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(CONVERSATION)
@Role(name="currentUser", scope=SESSION)
public class User { 
    ... 
}</pre><p>
                The <tt class="literal">@Roles</tt> annotation lets us specify as many additional roles as we like.
            </p><pre class="programlisting">@Name("user")
@Entity
@Scope(CONVERSATION)
@Roles({@Role(name="currentUser", scope=SESSION),
        @Role(name="tempUser", scope=EVENT)})
public class User { 
    ... 
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2945"></a>3.2.10.&nbsp;Built-in components</h3></div></div><div></div></div><p>
                Like many good frameworks, Seam eats its own dogfood and is implemented mostly as a set of built-in
                Seam interceptors (see later) and Seam components. This makes it easy for applications to interact with
                built-in components at runtime or even customize the basic functionality of Seam by replacing the
                built-in components with custom implementations. The built-in components are defined in the Seam
                namespace <tt class="literal">org.jboss.seam.core</tt> and the Java package of the same name.
            </p><p> 
                The built-in components may be injected, just like any Seam components, but they also provide
                convenient static <tt class="literal">instance()</tt> methods: 
            </p><pre class="programlisting">FacesMessages.instance().add("Welcome back, #{user.name}!");</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2960"></a>3.3.&nbsp;Bijection</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Dependency injection</em></span> or <span class="emphasis"><em>inversion of control</em></span> is by now a familiar
            concept to most Java developers. Dependency injection allows a component to obtain a reference to another
            component by having the container "inject" the other component to a setter method or instance variable. In
            all dependency injection implementations that we have seen, injection occurs when the component is
            constructed, and the reference does not subsequently change for the lifetime of the component instance. For
            stateless components, this is reasonable. From the point of view of a client, all instances of a particular
            stateless component are interchangeable. On the other hand, Seam emphasizes the use of stateful components.
            So traditional dependency injection is no longer a very useful construct. Seam introduces the notion of
            <span class="emphasis"><em>bijection</em></span> as a generalization of injection. In contrast to injection, bijection is: 
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>contextual</em></span> - bijection is used to assemble stateful components from various
                    different contexts (a component from a "wider" context may even have a reference to a component from
                    a "narrower" context)
                </p></li><li><p>
                    <span class="emphasis"><em>bidirectional</em></span> - values are injected from context variables into attributes of
                    the component being invoked, and also <span class="emphasis"><em>outjected</em></span> from the component attributes
                    back out to the context, allowing the component being invoked to manipulate the values of contextual
                    variables simply by setting its own instance variables 
                </p></li><li><p>
                    <span class="emphasis"><em>dynamic</em></span> - since the value of contextual variables changes over time, and since
                    Seam components are stateful, bijection takes place every time a component is invoked 
                </p></li></ul></div><p> 
            In essence, bijection lets you alias a context variable to a component instance variable, by specifying
            that the value of the instance variable is injected, outjected, or both. Of course, we use annotations to
            enable bijection.
        </p><p> 
            The <tt class="literal">@In</tt> annotation specifies that a value should be injected, either into an instance
            variable: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In User user;
    ... 
}</pre><p> 
            or into a setter method: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    ... 
}</pre><p> 
            By default, Seam will do a priority search of all contexts, using the name of the property or instance
            variable that is being injected. You may wish to specify the context variable name explicitly, using, for
            example, <tt class="literal">@In("currentUser")</tt>. 
        </p><p> 
            If you want Seam to create an instance of the component when there is no existing component instance
            bound to the named context variable, you should specify <tt class="literal">@In(create=true)</tt>. If the value is
            optional (it can be null), specify <tt class="literal">@In(required=false)</tt>. 
        </p><p>
            For some components, it can be repetitive to have to specify <tt class="literal">@In(create=true)</tt> everywhere
            they are used. In such cases, you can annotate the component <tt class="literal">@AutoCreate</tt>, and then it
            will always be created, whenever needed, even without the explicit use of <tt class="literal">create=true</tt>.
        </p><p> 
            You can even inject the value of an expression: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In("#{user.username}") String username;
    ... 
}</pre><p>
            Injected values are disinjected (i.e, set to <tt class="literal">null</tt>) immediately after method 
            completion and outjection.
        </p><p> 
            (There is much more information about component lifecycle and injection in the next chapter.) 
        </p><p> 
            The <tt class="literal">@Out</tt> annotation specifies that an attribute should be outjected, either from an
            instance variable: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @Out User user;
    ... 
}</pre><p> 
            or from a getter method: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}</pre><p> 
            An attribute may be both injected and outjected: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    @In @Out User user;
    ... 
}</pre><p> 
            or: 
        </p><pre class="programlisting">@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3063"></a>3.4.&nbsp;Lifecycle methods</h2></div></div><div></div></div><p> 
            Session bean and entity bean Seam components support all the usual EJB 3.0 lifecycle callback
            (<tt class="literal">@PostConstruct</tt>, <tt class="literal">@PreDestroy</tt>, etc). But Seam also supports 
            the use of any of these callbacks with JavaBean components. However, since these annotations are
            not available in a J2EE environment, Seam defines two additional component lifecycle callbacks,
            equivalent to <tt class="literal">@PostConstruct</tt> and <tt class="literal">@PreDestroy</tt>.
        </p><p> 
            The <tt class="literal">@Create</tt> method is called after Seam instantiates a component. 
            Components may define only one <tt class="literal">@Create</tt> method. 
        </p><p> 
            The <tt class="literal">@Destroy</tt> method is called when the context that the Seam component is bound to
            ends. Components may define only one <tt class="literal">@Destroy</tt> method.
        </p><p>
            In addition, stateful session bean components <span class="emphasis"><em>must</em></span> define a method with no parameters 
            annotated <tt class="literal">@Remove</tt>. This method is called by Seam when the context ends.
        </p><p> 
            Finally, a related annotation is the <tt class="literal">@Startup</tt> annotation, which may be applied to any
            application or session scoped component. The <tt class="literal">@Startup</tt> annotation tells Seam to
            instantiate the component immediately, when the context begins, instead of waiting until it is first
            referenced by a client. It is possible to control the order of instantiation of startup components by
            specifying <tt class="literal">@Startup(depends={....})</tt>. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3115"></a>3.5.&nbsp;Conditional installation</h2></div></div><div></div></div><p>
            The <tt class="literal">@Install</tt> annotation lets you control conditional installation of components that
            are required in some deployment scenarios and not in others. This is useful if:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
        		    You want to mock out some infrastructural component in tests.
        		</p></li><li><p>
        		    You want change the implementation of a component in certain
        		    deployment scenarios.
        		</p></li><li><p>
        		    You want to install some components only if their dependencies are
        		    available (useful for framework authors).
        		</p></li></ul></div><p>
            <tt class="literal">@Install</tt> works by letting you specify <span class="emphasis"><em>precedence</em></span>
            and <span class="emphasis"><em>dependencies</em></span>. 
        </p><p>
            The precedence of a component is a number that Seam uses to decide which component to
            install when there are multiple classes with the same component name in the classpath.
            Seam will choose the component with the higher precendence. There are some predefined
            precedence values (in ascending order):
        </p><div class="orderedlist"><ol type="1"><li><p>
        		    <tt class="literal">BUILT_IN</tt> &#8212; the lowest precedece components are
        		    the components built in to Seam. 
        		</p></li><li><p>
        		    <tt class="literal">FRAMEWORK</tt> &#8212; components defined by third-party 
        		    frameworks may override built-in components, but are overridden by
        		    application components. 
        		</p></li><li><p>
        		    <tt class="literal">APPLICATION</tt> &#8212; the default precedence. This is 
                    appropriate for most application components.
        		</p></li><li><p>
        		    <tt class="literal">DEPLOYMENT</tt> &#8212; for application components which
        		    are deployment-specific. 
        		</p></li><li><p>
        		    <tt class="literal">MOCK</tt> &#8212; for mock objects used in testing. 
        		</p></li></ol></div><p>
            Suppose we have a component named <tt class="literal">messageSender</tt> that talks to
            a JMS queue. 
        </p><pre class="programlisting">@Name("messageSender") 
public class MessageSender {
    public void sendMessage() {
        //do something with JMS
    }
}</pre><p>
            In our unit tests, we don't have a JMS queue available, so we would like to stub
            out this method. We'll create a <span class="emphasis"><em>mock</em></span> component that exists
            in the classpath when unit tests are running, but is never deployed with the
            application:
        </p><pre class="programlisting">@Name("messageSender") 
@Install(precedence=MOCK)
public class MockMessageSender extends MessageSender {
    public void sendMessage() {
        //do nothing!
    }
}</pre><p>
            The <tt class="literal">precedence</tt> helps Seam decide which version to use when it finds
            both components in the classpath.
        </p><p>
            This is nice if we are able to control exactly which classes are in the classpath. But
            if I'm writing a reusable framework with many dependecies, I don't want to have to 
            break that framework across many jars. I want to be able to decide which components
            to install depending upon what other components are installed, and upon what classes
            are available in the classpath. The <tt class="literal">@Install</tt> annotation also 
            controls this functionality. Seam uses this mechanism internally to enable conditional 
            installation of many of the built-in components. However, you probably won't need to
            use it in your application.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3201"></a>3.6.&nbsp;Logging</h2></div></div><div></div></div><p> 
            Who is not totally fed up with seeing noisy code like this? 
         </p><pre class="programlisting">private static final Log log = LogFactory.getLog(CreateOrderAction.class);
        
public Order createOrder(User user, Product product, int quantity) {
    if ( log.isDebugEnabled() ) {
        log.debug("Creating new order for user: " + user.username() + 
            " product: " + product.name() 
            + " quantity: " + quantity);
    }
    return new Order(user, product, quantity);
}</pre><p> 
            It is difficult to imagine how the code for a simple log message could possibly be more verbose. There is
            more lines of code tied up in logging than in the actual business logic! I remain totally astonished that
            the Java community has not come up with anything better in 10 years. 
        </p><p> 
            Seam provides a logging API that simplifies this code significantly: 
        </p><pre class="programlisting">@Logger private Log log;
        
public Order createOrder(User user, Product product, int quantity) {
    log.debug("Creating new order for user: #0 product: #1 quantity: #2", user.username(), product.name(), quantity);
    return new Order(user, product, quantity);
}</pre><p>
            It doesn't matter if you declare the <tt class="literal">log</tt> variable static or not&#8212;it will work 
            either way, except for entity bean components which require the <tt class="literal">log</tt> variable to be
            static.
        </p><p> 
            Note that we don't need the noisy <tt class="literal">if ( log.isDebugEnabled() )</tt> guard, since string
            concatenation happens <span class="emphasis"><em>inside</em></span> the <tt class="literal">debug()</tt> method. Note also that we
            don't usually need to specify the log category explicitly, since Seam knows what component it is injecting
            the <tt class="literal">Log</tt> into. 
        </p><p> 
            If <tt class="literal">User</tt> and <tt class="literal">Product</tt> are Seam components available in the current
            contexts, it gets even better: 
        </p><pre class="programlisting">@Logger private Log log;
        
public Order createOrder(User user, Product product, int quantity) {
    log.debug("Creating new order for user: #{user.username} product: #{product.name} quantity: #0", quantity);
    return new Order(user, product, quantity);
}</pre><p>
            Seam logging automagically chooses whether to send output to log4j or JDK logging. If log4j is in the
            classpath, Seam with use it. If it is not, Seam will use JDK logging.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3249"></a>3.7.&nbsp;The <tt class="literal">Mutable</tt> interface and <tt class="literal">@ReadOnly</tt></h2></div></div><div></div></div><p> 
            Many application servers feature an amazingly broken implementation of <tt class="literal">HttpSession</tt>
            clustering, where changes to the state of mutable objects bound to the session are only replicated when the
            application calls <tt class="literal">setAttribute()</tt> explicitly. This is a source of bugs that can not
            effectively be tested for at development time, since they will only manifest when failover occurs.
            Furthermore, the actual replication message contains the entire serialized object graph bound to the session
            attribute, which is inefficient. 
        </p><p> 
            Of course, EJB stateful session beans must perform automatic dirty checking and replication of mutable
            state and a sophisticated EJB container can introduce optimizations such as attribute-level replication.
            Unfortunately, not all Seam users have the good fortune to be working in an environment that supports EJB
            3.0. So, for session and conversation scoped JavaBean and entity bean components, Seam provides an extra
            layer of cluster-safe state management over the top of the web container session clustering. 
        </p><p> 
            For session or conversation scoped JavaBean components, Seam automatically forces replication to occur by
            calling <tt class="literal">setAttribute()</tt> once in every request that the component was invoked by the
            application. Of course, this strategy is inefficient for read-mostly components. You can control this
            behavior by implementing the <tt class="literal">org.jboss.seam.core.Mutable</tt> interface, or by extending
            <tt class="literal">org.jboss.seam.core.AbstractMutable</tt>, and writing your own dirty-checking logic inside
            the component. For example, 
        </p><pre class="programlisting">@Name("account")
public class Account extends AbstractMutable
{
    private BigDecimal balance;
    
    public void setBalance(BigDecimal balance)
    {
        setDirty(this.balance, balance);
        this.balance = balance;
    }
    
    public BigDecimal getBalance()
    {
        return balance;
    }
    
    ...
    
}</pre><p> 
            Or, you can use the <tt class="literal">@ReadOnly</tt> annotation to achieve a similar effect: 
        </p><pre class="programlisting">@Name("account")
public class Account
{
    private BigDecimal balance;
    
    public void setBalance(BigDecimal balance)
    {
        this.balance = balance;
    }
    
    @ReadOnly
    public BigDecimal getBalance()
    {
        return balance;
    }
    
    ...
    
}</pre><p> 
            For session or conversation scoped entity bean components, Seam automatically forces replication to occur
            by calling <tt class="literal">setAttribute()</tt> once in every request, <span class="emphasis"><em>unless the (conversation-scoped) 
            entity is currently associated with a Seam-managed persistence context, in which case no replication is 
            needed</em></span>. This strategy is not necessarily efficient, so session or conversation scope entity beans 
            should be used with care. You can always write a stateful session bean or JavaBean component to "manage" the 
            entity bean instance. For example, 
        </p><pre class="programlisting">@Stateful
@Name("account")
public class AccountManager extends AbstractMutable
{
    private Account account; // an entity bean
    
    @Unwrap
    public void getAccount()
    {
        return account;
    }
    
    ...
    
}</pre><p> 
            Note that the <tt class="literal">EntityHome</tt> class in the Seam Application Framework provides a great example 
            of managing an entity bean instance using a Seam component. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3302"></a>3.8.&nbsp;Factory and manager components</h2></div></div><div></div></div><p> 
            We often need to work with objects that are not Seam components. But we still want to be able to inject
            them into our components using <tt class="literal">@In</tt> and use them in value and method binding expressions,
            etc. Sometimes, we even need to tie them into the Seam context lifecycle (<tt class="literal">@Destroy</tt>, for
            example). So the Seam contexts can contain objects which are not Seam components, and Seam provides a couple
            of nice features that make it easier to work with non-component objects bound to contexts. 
        </p><p> 
            The <span class="emphasis"><em>factory component pattern</em></span> lets a Seam component act as the instantiator for a
            non-component object. A <span class="emphasis"><em>factory method</em></span> will be called when a context variable is
            referenced but has no value bound to it. We define factory methods using the <tt class="literal">@Factory</tt>
            annotation. The factory method binds a value to the context variable, and determines the scope of the bound
            value. There are two styles of factory method. The first style returns a value, which is bound to the
            context by Seam:
        </p><pre class="programlisting">@Factory(scope=CONVERSATION)
public List&lt;Customer&gt; getCustomerList() { 
    return ... ;
} </pre><p> 
            The second style is a method of type <tt class="literal">void</tt> which binds the value to the context
            variable itself: 
        </p><pre class="programlisting">@DataModel List&lt;Customer&gt; customerList;

@Factory("customerList")
public void initCustomerList() { 
    customerList = ...  ;
} </pre><p> 
            In both cases, the factory method is called when we reference the <tt class="literal">customerList</tt> context
            variable and its value is null, and then has no further part to play in the lifecycle of the value. An even
            more powerful pattern is the <span class="emphasis"><em>manager component pattern</em></span>. In this case, we have a Seam
            component that is bound to a context variable, that manages the value of the context variable, while
            remaining invisible to clients. 
        </p><p> 
            A manager component is any component with an <tt class="literal">@Unwrap</tt> method. This method returns the
            value that will be visable to clients, and is called <span class="emphasis"><em>every time</em></span> a context variable is
            referenced. 
        </p><pre class="programlisting">@Name("customerList")
@Scope(CONVERSATION)
public class CustomerListManager
{
    ...
    
    @Unwrap
    public List&lt;Customer&gt; getCustomerList() { 
        return ... ;
    }
}</pre><p> 
            The manager component pattern is especially useful if we have an object where you need more control over the 
            lifecycle of the component.  For example, if you have a heavyweight object that needs a cleanup operation when 
            the context ends you could <tt class="literal">@Unwrap</tt> the object, and perform cleanup in the 
            <tt class="literal">@Destroy</tt> method of the manager component.
        </p><pre class="programlisting">@Name("hens")
@Scope(APPLICATION) 
public class HenHouse {
    
    Set&lt;Hen&gt; hens;
    
    @In(required=false) Hen hen;
    
    @Unwrap
    public List&lt;Hen&gt; getHens() {
        if (hens == null) {
            // Setup our hens
        }
        return hens;
    }
    
    @Observer({"chickBorn", "chickenBoughtAtMarket"})
    public addHen() {
        hens.add(hen);
    }
    
    @Observer("chickenSoldAtMarket")
    public removeHen() {
        hens.remove(hen);
    }
    
    @Observer("foxGetsIn")
    public removeAllHens() {
        hens.clear();
    }
    ...
} </pre><p>
		Here the managed component observes many events which change the underlying object. 
		The component manages these actions itself, and because the object is unwrapped
		on every access, a consistent view is provided.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;4.&nbsp;Configuring Seam components</h2></div></div><div></div></div><p> 
            The philosophy of minimizing XML-based configuration is extremely strong in Seam. Nevertheless,
            there are various reasons why we might want to configure a Seam component using XML: to isolate
            deployment-specific information from the Java code, to enable the creation of re-usable frameworks,
            to configure Seam's built-in functionality, etc.
            Seam provides two basic approaches to configuring components: configuration via property settings in a
            properties file or in <tt class="literal">web.xml</tt>, and configuration via <tt class="literal">components.xml</tt>. 
        </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3374"></a>4.1.&nbsp;Configuring components via property settings</h2></div></div><div></div></div><p> 
                Seam components may be provided with configuration properties either via servlet context parameters,
                or via a properties file named <tt class="literal">seam.properties</tt> in the root of the classpath. 
            </p><p> 
                The configurable Seam component must expose JavaBeans-style property setter methods for the
                configurable attributes. If a Seam component named <tt class="literal">com.jboss.myapp.settings</tt> has a
                setter method named <tt class="literal">setLocale()</tt>, we can provide a property named
                <tt class="literal">com.jboss.myapp.settings.locale</tt> in the <tt class="literal">seam.properties</tt> file or
                as a servlet context parameter, and Seam will set the value of the <tt class="literal">locale</tt> attribute
                whenever it instantiates the component. 
            </p><p> 
                The same mechanism is used to configure Seam itself. For example, to set the conversation timeout, we
                provide a value for <tt class="literal">org.jboss.seam.core.manager.conversationTimeout</tt> in
                <tt class="literal">web.xml</tt> or <tt class="literal">seam.properties</tt>. (There is a built-in Seam
                component named <tt class="literal">org.jboss.seam.core.manager</tt> with a setter method named
                <tt class="literal">setConversationTimeout()</tt>.) 
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3416"></a>4.2.&nbsp;Configuring components via <tt class="literal">components.xml</tt></h2></div></div><div></div></div><p> 
                The <tt class="literal">components.xml</tt> file is a bit more powerful than property settings. It lets
                you: 
            </p><div class="itemizedlist"><ul type="disc"><li><p> Configure components that have been installed automatically&#8212;including both built-in
                        components, and application components that have been annotated with the
                        <tt class="literal">@Name</tt> annotation and picked up by Seam's deployment scanner. </p></li><li><p> Install classes with no <tt class="literal">@Name</tt> annotation as Seam components&#8212;this
                        is most useful for certain kinds of infrastructural components which can be installed multiple
                        times different names (for example Seam-managed persistence contexts). </p></li><li><p> Install components that <span class="emphasis"><em>do</em></span> have a <tt class="literal">@Name</tt> annotation
                        but are not installed by default because of an <tt class="literal">@Install</tt> annotation that
                        indicates the component should not be installed. </p></li><li><p> Override the scope of a component. </p></li></ul></div><p> 
                A <tt class="literal">components.xml</tt> file may appear in one of three different places: 
            </p><div class="itemizedlist"><ul type="disc"><li><p>The <tt class="literal">WEB-INF</tt> directory of a <tt class="literal">war</tt>.</p></li><li><p>The <tt class="literal">META-INF</tt> directory of a <tt class="literal">jar</tt>.</p></li><li><p>
                        Any directory of a <tt class="literal">jar</tt> that contains classes with an
                        <tt class="literal">@Name</tt> annotation.
                    </p></li></ul></div><p> 
                Usually, Seam components are installed when the deployment scanner discovers a class with a
                <tt class="literal">@Name</tt> annotation sitting in an archive with a <tt class="literal">seam.properties</tt>
                file or a <tt class="literal">META-INF/components.xml</tt> file. (Unless the component has an 
                <tt class="literal">@Install</tt> annotation indicating it should not be installed by default.) 
                The <tt class="literal">components.xml</tt> file lets us handle special cases where we need
                to override the annotations. 
            </p><p>
                For example, the following <tt class="literal">components.xml</tt> file installs jBPM: 
            </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:bpm="http://jboss.com/products/seam/bpm"&gt;
    &lt;bpm:jbpm/&gt;
&lt;/components&gt;</pre><p>
                This example does the same thing:
            </p><pre class="programlisting">&lt;components&gt;
    &lt;component class="org.jboss.seam.bpm.Jbpm"/&gt;
&lt;/components&gt;</pre><p>
                This one installs and configures two different Seam-managed persistence contexts:
            </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components" 
            xmlns:persistence="http://jboss.com/products/seam/persistence"

    &lt;persistence:managed-persistence-context name="customerDatabase"
                       persistence-unit-jndi-name="java:/customerEntityManagerFactory"/&gt;
        
    &lt;persistence:managed-persistence-context name="accountingDatabase"
                       persistence-unit-jndi-name="java:/accountingEntityManagerFactory"/&gt;            

&lt;/components&gt;</pre><p>
                As does this one:
            </p><pre class="programlisting">&lt;components&gt;
    &lt;component name="customerDatabase" 
              class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
        &lt;property name="persistenceUnitJndiName"&gt;java:/customerEntityManagerFactory&lt;/property&gt;
    &lt;/component&gt;
    
    &lt;component name="accountingDatabase"
              class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
        &lt;property name="persistenceUnitJndiName"&gt;java:/accountingEntityManagerFactory&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;</pre><p>
                This example creates a session-scoped Seam-managed persistence context (this is not recommended in
                practice):
            </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components" 
            xmlns:persistence="http://jboss.com/products/seam/persistence"

  &lt;persistence:managed-persistence-context name="productDatabase" 
                                          scope="session"
                     persistence-unit-jndi-name="java:/productEntityManagerFactory"/&gt;        

&lt;/components&gt;</pre><pre class="programlisting">&lt;components&gt;
            
    &lt;component name="productDatabase"
              scope="session"
              class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
        &lt;property name="persistenceUnitJndiName"&gt;java:/productEntityManagerFactory&lt;/property&gt;
    &lt;/component&gt;

&lt;/components&gt;</pre><p>
                It is common to use the <tt class="literal">auto-create</tt> option for infrastructural
                objects like persistence contexts, which saves you from having to explicitly
                specify <tt class="literal">create=true</tt> when you use the <tt class="literal">@In</tt>
                annotation.
            </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components" 
            xmlns:persistence="http://jboss.com/products/seam/persistence"

  &lt;persistence:managed-persistence-context name="productDatabase" 
                                    auto-create="true"
                     persistence-unit-jndi-name="java:/productEntityManagerFactory"/&gt;        

&lt;/components&gt;</pre><pre class="programlisting">&lt;components&gt;
            
    &lt;component name="productDatabase"
        auto-create="true"
              class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
        &lt;property name="persistenceUnitJndiName"&gt;java:/productEntityManagerFactory&lt;/property&gt;
    &lt;/component&gt;

&lt;/components&gt;</pre><p>
                The <tt class="literal">&lt;factory&gt;</tt> declaration lets you specify a value or method binding
                expression that will be evaluated to initialize the value of a context variable when it is first
                referenced.
            </p><pre class="programlisting">&lt;components&gt;

    &lt;factory name="contact" method="#{contactManager.loadContact}" scope="CONVERSATION"/&gt;

&lt;/components&gt;</pre><p> 
                You can create an "alias" (a second name) for a Seam component like so: 
            </p><pre class="programlisting">&lt;components&gt;

    &lt;factory name="user" value="#{actor}" scope="STATELESS"/&gt;

&lt;/components&gt;</pre><p> 
                You can even create an "alias" for a commonly used expression: 
            </p><pre class="programlisting">&lt;components&gt;

    &lt;factory name="contact" value="#{contactManager.contact}" scope="STATELESS"/&gt;

&lt;/components&gt;</pre><p>
                It is especially common to see the use of <tt class="literal">auto-create="true"</tt> with the
                <tt class="literal">&lt;factory&gt;</tt> declaration:
            </p><pre class="programlisting">&lt;components&gt;

    &lt;factory name="session" value="#{entityManager.delegate}" scope="STATELESS" auto-create="true"/&gt;

&lt;/components&gt;</pre><p> 
                Sometimes we want to reuse the same <tt class="literal">components.xml</tt> file with minor changes during
                both deployment and testing. Seam lets you place wildcards of the form <tt class="literal">@wildcard@</tt> in
                the <tt class="literal">components.xml</tt> file which can be replaced either by your Ant build script (at
                deployment time) or by providing a file named <tt class="literal">components.properties</tt> in the classpath
                (at development time). You'll see this approach used in the Seam examples. 
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3583"></a>4.3.&nbsp;Fine-grained configuration files</h2></div></div><div></div></div><p> 
                If you have a large number of components that need to be configured in XML, it makes much more sense
                to split up the information in <tt class="literal">components.xml</tt> into many small files. Seam lets
                you put configuration for a class named, for example, <tt class="literal">com.helloworld.Hello</tt> in a
                resource named <tt class="literal">com/helloworld/Hello.component.xml</tt>. (You might be familiar with this
                pattern, since it is the same one we use in Hibernate.) The root element of the file may be either a
                <tt class="literal">&lt;components&gt;</tt> or <tt class="literal">&lt;component&gt;</tt>
                element. </p><p> 
                The first option lets you define multiple components in the file: 
            </p><pre class="programlisting">&lt;components&gt;
    &lt;component class="com.helloworld.Hello" name="hello"&gt;
        &lt;property name="name"&gt;#{user.name}&lt;/property&gt;
    &lt;/component&gt;
    &lt;factory name="message" value="#{hello.message}"/&gt;
&lt;/components&gt;</pre><p> 
                The second option only lets you define or configure one component, but is less noisy: 
            </p><pre class="programlisting">&lt;component name="hello"&gt;
    &lt;property name="name"&gt;#{user.name}&lt;/property&gt;
&lt;/component&gt;</pre><p> 
                In the second option, the class name is implied by the file in which the component definition
                appears. 
            </p><p> 
                Alternatively, you may put configuration for all classes in the <tt class="literal">com.helloworld</tt>
                package in <tt class="literal">com/helloworld/components.xml</tt>. 
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3621"></a>4.4.&nbsp;Configurable property types</h2></div></div><div></div></div><p> 
                Properties of string, primitive or primitive wrapper type may be configured just as you would expect: 
            </p><pre class="programlisting">org.jboss.seam.core.manager.conversationTimeout 60000</pre><pre class="programlisting">&lt;core:manager conversation-timeout="60000"/&gt;</pre><pre class="programlisting">&lt;component name="org.jboss.seam.core.manager"&gt;
    &lt;property name="conversationTimeout"&gt;60000&lt;/property&gt;
&lt;/component&gt;</pre><p> 
                Arrays, sets and lists of strings or primitives are also supported: 
            </p><pre class="programlisting">org.jboss.seam.bpm.jbpm.processDefinitions order.jpdl.xml, return.jpdl.xml, inventory.jpdl.xml</pre><pre class="programlisting">&lt;bpm:jbpm&gt;
    &lt;bpm:process-definitions&gt;
        &lt;value&gt;order.jpdl.xml&lt;/value&gt;
        &lt;value&gt;return.jpdl.xml&lt;/value&gt;
        &lt;value&gt;inventory.jpdl.xml&lt;/value&gt;
    &lt;/bpm:process-definitions&gt;
&lt;/bpm:jbpm&gt;</pre><pre class="programlisting">&lt;component name="org.jboss.seam.bpm.jbpm"&gt;
    &lt;property name="processDefinitions"&gt;
        &lt;value&gt;order.jpdl.xml&lt;/value&gt;
        &lt;value&gt;return.jpdl.xml&lt;/value&gt;
        &lt;value&gt;inventory.jpdl.xml&lt;/value&gt;
    &lt;/property&gt;
&lt;/component&gt;</pre><p> 
                Even maps with String-valued keys and string or primitive values are supported: 
            </p><pre class="programlisting">&lt;component name="issueEditor"&gt;
    &lt;property name="issueStatuses"&gt;
        &lt;key&gt;open&lt;/key&gt; &lt;value&gt;open issue&lt;/value&gt;
        &lt;key&gt;resolved&lt;/key&gt; &lt;value&gt;issue resolved by developer&lt;/value&gt;
        &lt;key&gt;closed&lt;/key&gt; &lt;value&gt;resolution accepted by user&lt;/value&gt;
    &lt;/property&gt;
&lt;/component&gt;</pre><p> 
                Finally, you may wire together components using a value-binding expression. Note that this is quite
                different to injection using <tt class="literal">@In</tt>, since it happens at component instantiation time
                instead of invocation time. It is therefore much more similar to the dependency injection facilities
                offered by traditional IoC containers like JSF or Spring. 
            </p><pre class="programlisting">&lt;drools:managed-working-memory name="policyPricingWorkingMemory" rule-base="#{policyPricingRules}"/&gt;</pre><pre class="programlisting">&lt;component name="policyPricingWorkingMemory"
          class="org.jboss.seam.drools.ManagedWorkingMemory"&gt;
    &lt;property name="ruleBase"&gt;#{policyPricingRules}&lt;/property&gt;
&lt;/component&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3653"></a>4.5.&nbsp;Using XML Namespaces</h2></div></div><div></div></div><p> 
                Throughout the examples, there have been two competing ways of declaring components: with and without
                the use of XML namespaces. The following shows a typical <tt class="literal">components.xml</tt> file 
                without namespaces:
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;components xmlns="http://jboss.com/products/seam/components"
            xsi:schemaLocation="http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd"&gt;

    &lt;component class="org.jboss.seam.core.init"&gt;
        &lt;property name="debug"&gt;true&lt;/property&gt;
        &lt;property name="jndiPattern"&gt;@jndiPattern@&lt;/property&gt;
    &lt;/component&gt;
    
&lt;/components&gt;</pre><p>
                As you can see, this is somewhat verbose. Even worse, the component and attribute names cannot be 
                validated at development time.
            </p><p>The namespaced version looks like this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/core http://jboss.com/products/seam/core-2.0.xsd 
                 http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd"&gt;

    &lt;core:init debug="true" jndi-pattern="@jndiPattern@"/&gt;

&lt;/components&gt;</pre><p>
                Even though the schema declarations are verbose, the actual XML content is lean and easy to understand.
                The schemas provide detailed information about each component and the attributes available, allowing XML
                editors to offer intelligent autocomplete. The use of namespaced elements makes generating and
                maintaining correct <tt class="literal">components.xml</tt> files much simpler.
            </p><p> 
                Now, this works great for the built-in Seam components, but what about user components? There are two options. 
                First, Seam supports mixing the two models, allowing the use of the generic <tt class="literal">&lt;component&gt;</tt> 
                declarations for user components, along with namespaced declarations for built-in components. But even better,
                Seam allows you to quickly declare namespaces for your own components.
            </p><p>
                Any Java package can be associated with an XML namespace by annotating the package with the 
                <tt class="literal">@Namespace</tt> annotation. (Package-level annotations are declared in a file named
                <tt class="literal">package-info.java</tt> in the package directory.) Here is an example from the seampay demo:
            </p><pre class="programlisting">@Namespace(value="http://jboss.com/products/seam/examples/seampay")
package org.jboss.seam.example.seampay;

import org.jboss.seam.annotations.Namespace;</pre><p>
                That is all you need to do to use the namespaced style in <tt class="literal">components.xml</tt>!
                Now we can write:
            </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:pay="http://jboss.com/products/seam/examples/seampay"
            ... &gt;

    &lt;pay:payment-home new-instance="#{newPayment}"
                      created-message="Created a new payment to #{newPayment.payee}" /&gt;

    &lt;pay:payment name="newPayment"
                 payee="Somebody"
                 account="#{selectedAccount}"
                 payment-date="#{currentDatetime}"
                 created-date="#{currentDatetime}" /&gt;
     ...
&lt;/components&gt;</pre><p>Or:</p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:pay="http://jboss.com/products/seam/examples/seampay"
            ... &gt;

    &lt;pay:payment-home&gt;
        &lt;pay:new-instance&gt;"#{newPayment}"&lt;/pay:new-instance&gt;
        &lt;pay:created-message&gt;Created a new payment to #{newPayment.payee}&lt;/pay:created-message&gt;
    &lt;/pay:payment-home&gt;
    
    &lt;pay:payment name="newPayment"&gt;
        &lt;pay:payee&gt;Somebody"&lt;/pay:payee&gt;
        &lt;pay:account&gt;#{selectedAccount}&lt;/pay:account&gt;
        &lt;pay:payment-date&gt;#{currentDatetime}&lt;/pay:payment-date&gt;
        &lt;pay:created-date&gt;#{currentDatetime}&lt;/pay:created-date&gt;
     &lt;/pay:payment&gt;
     ...
&lt;/components&gt;</pre><p>
                These examples illustrate the two usage models of a namespaced element. In the first declaration, 
                the <tt class="literal">&lt;pay:payment-home&gt;</tt> references the <tt class="literal">paymentHome</tt>
                component:
            </p><pre class="programlisting">package org.jboss.seam.example.seampay;
...
@Name("paymentHome")
public class PaymentController
    extends EntityHome&lt;Payment&gt;
{
    ... 
}</pre><p>
                The element name is the hyphenated form of the component name. The attributes of the element are
                the hyphenated form of the property names.
            </p><p>
                In the second declaration, the <tt class="literal">&lt;pay:payment&gt;</tt> element refers to the 
                <tt class="literal">Payment</tt> class in the <tt class="literal">org.jboss.seam.example.seampay</tt> package. 
                In this case <tt class="literal">Payment</tt> is an entity that is being declared as a Seam component:
            </p><pre class="programlisting">package org.jboss.seam.example.seampay;
...
@Entity
public class Payment
    implements Serializable
{
    ...
}</pre><p>
                If we want validation and autocompletion to work for user-defined components, we will need a schema.
                Seam does not yet provide a mechanism to automatically generate a schema for a set of components, so
                it is necessary to generate one manually. The schema definitions for the standard Seam packages can 
                be used for guidance.   
            </p><p>The following are the the namespaces used by Seam:</p><div class="itemizedlist"><ul type="disc"><li><p>components &#8212; <tt class="literal">http://jboss.com/products/seam/components</tt></p></li><li><p>core &#8212; <tt class="literal">http://jboss.com/products/seam/core</tt></p></li><li><p>drools &#8212; <tt class="literal">http://jboss.com/products/seam/drools</tt></p></li><li><p>framework &#8212; <tt class="literal">http://jboss.com/products/seam/framework</tt></p></li><li><p>jms &#8212; <tt class="literal">http://jboss.com/products/seam/jms</tt></p></li><li><p>remoting &#8212; <tt class="literal">http://jboss.com/products/seam/remoting</tt></p></li><li><p>theme &#8212; <tt class="literal">http://jboss.com/products/seam/theme</tt></p></li><li><p>security &#8212; <tt class="literal">http://jboss.com/products/seam/security</tt></p></li><li><p>mail &#8212; <tt class="literal">http://jboss.com/products/seam/mail</tt></p></li><li><p>web &#8212; <tt class="literal">http://jboss.com/products/seam/web</tt></p></li><li><p>pdf &#8212; <tt class="literal">http://jboss.com/products/seam/pdf</tt></p></li><li><p> spring &#8212; <tt class="literal">http://jboss.com/products/seam/spring</tt></p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;5.&nbsp;Events, interceptors and exception handling</h2></div></div><div></div></div><p>
        Complementing the contextual component model, there are two further basic concepts
        that facilitate the extreme loose-coupling that is the distinctive feature of Seam 
        applications. The first is a strong event model where events may be mapped to event 
        listeners via JSF-like method binding expressions. The second is the pervasive use 
        of annotations and interceptors to apply cross-cutting concerns to components which 
        implement business logic.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3798"></a>5.1.&nbsp;Seam events</h2></div></div><div></div></div><p>
            The Seam component model was developed for use with <span class="emphasis"><em>event-driven 
            applications</em></span>, specifically to enable the development of fine-grained, 
            loosely-coupled components in a fine-grained eventing model. Events in Seam come
            in several types, most of which we have already seen:
        </p><div class="itemizedlist"><ul type="disc"><li><p>JSF events</p></li><li><p>jBPM transition events</p></li><li><p>Seam page actions</p></li><li><p>Seam component-driven events</p></li><li><p>Seam contextual events</p></li></ul></div><p>
            All of these various kinds of events are mapped to Seam components via JSF EL
            method binding expressions. For a JSF event, this is defined in the JSF template:
        </p><pre class="programlisting">&lt;h:commandButton value="Click me!" action="#{helloWorld.sayHello}"/&gt;</pre><p>
            For a jBPM transition event, it is specified in the jBPM process definition or
            pageflow definition:
        </p><pre class="programlisting">&lt;start-page name="hello" view-id="/hello.jsp"&gt;
    &lt;transition to="hello"&gt;
        &lt;action expression="#{helloWorld.sayHello}"/&gt;
    &lt;/transition&gt;
&lt;/start-page&gt;</pre><p>
            You can find out more information about JSF events and jBPM events elsewhere. 
            Lets concentrate for now upon the two additional kinds of events defined by Seam.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3832"></a>5.1.1.&nbsp;Page actions</h3></div></div><div></div></div><p>
            A Seam page action is an event that occurs just before we render a page. 
            We declare page actions in <tt class="literal">WEB-INF/pages.xml</tt>. We
            can define a page action for either a particular JSF view id:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/hello.jsp" action="#{helloWorld.sayHello}"/&gt;
&lt;/pages&gt;</pre><p>
            Or we can use a <tt class="literal">*</tt> wildcard as a suffix to the
            <tt class="literal">view-id</tt> to specify an action that applies to all 
            view ids that match the pattern:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/hello/*" action="#{helloWorld.sayHello}"/&gt;
&lt;/pages&gt;</pre><p>
            If multiple wildcarded page actions match the current view-id, Seam
            will call all the actions, in order of least-specific to most-specific.
        </p><p>
            The page action method can return a JSF outcome. If the outcome is
            non-null, Seam will use the defined navigation rules to navigate to a view.
        </p><p>
            Furthermore, the view id mentioned in the <tt class="literal">&lt;page&gt;</tt>
            element need not correspond to a real JSP or Facelets page! So, we can
            reproduce the functionality of a traditional action-oriented framework
            like Struts or WebWork using page actions. For example:
        </p><pre class="programlisting">TODO: translate struts action into page action</pre><p>
            This is quite useful if you want to do complex things in response to non-faces
            requests (for example, HTTP GET requests).
        </p><p>
            Multiple or conditional page actions my be specified using the <tt class="literal">&lt;action&gt;</tt>
            tag:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/hello.jsp"&gt;
        &lt;action execute="#{helloWorld.sayHello}" if="#{not validation.failed}"/&gt;
        &lt;action execute="#{hitCount.increment}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3872"></a>5.1.1.1.&nbsp;Page parameters</h4></div></div><div></div></div><p>
                A JSF faces request (a form submission) encapsulates both an "action"
                (a method binding) and "parameters" (input value bindings). A page 
                action might also needs parameters!
            </p><p>
                Since GET requests are bookmarkable, page parameters are passed as 
                human-readable request parameters. (Unlike JSF form inputs, which are
                anything but!) 
            </p><p>
                You can use page parameters with or without an action method.
            </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3881"></a>5.1.1.1.1.&nbsp;Mapping request parameters to the model</h5></div></div><div></div></div><p>
                  Seam lets us provide a value binding that maps a named request parameter 
                  to an attribute of a model object.
              </p><pre class="programlisting">&lt;pages&gt;
      &lt;page view-id="/hello.jsp" action="#{helloWorld.sayHello}"&gt;
          &lt;param name="firstName" value="#{person.firstName}"/&gt;
          &lt;param name="lastName" value="#{person.lastName}"/&gt;
      &lt;/page&gt;
  &lt;/pages&gt;</pre><p>
                  The <tt class="literal">&lt;param&gt;</tt> declaration is bidirectional, just
                  like a value binding for a JSF input:
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                          When a non-faces (GET) request for the view id occurs, Seam sets 
                          the value of the named request parameter onto the model object, 
                          after performing appropriate type conversions.
                      </p></li><li><p>
                          Any <tt class="literal">&lt;s:link&gt;</tt> or <tt class="literal">&lt;s:button&gt;</tt> 
                          transparently includes the request parameter. The value of the parameter is 
                          determined by evaluating the value binding during the render phase (when the 
                          <tt class="literal">&lt;s:link&gt;</tt> is rendered).
                      </p></li><li><p>
                          Any navigation rule with a <tt class="literal">&lt;redirect/&gt;</tt> to
                          the view id transparently includes the request parameter. The value 
                          of the parameter is determined by evaluating the value binding at
                          the end of the invoke application phase.
                      </p></li><li><p>
                          The value is transparently propagated with any JSF form submission
                          for the page with the given view id. This means that view parameters
                          behave like <tt class="literal">PAGE</tt>-scoped context variables for
                          faces requests.
                      </p></li></ul></div><p>
                  The essential idea behind all this is that <span class="emphasis"><em>however</em></span>
                  we get from any other page to <tt class="literal">/hello.jsp</tt> (or from 
                  <tt class="literal">/hello.jsp</tt> back to <tt class="literal">/hello.jsp</tt>), 
                  the value of the model attribute referred to in the value binding is
                  "remembered", without the need for a conversation (or other server-side
                  state).
              </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3935"></a>5.1.1.1.2.&nbsp;Propagating request parameters</h5></div></div><div></div></div><p>
                    If just the <tt class="literal">name</tt> attribute is specified then the
                    request parameter is propagated using the <tt class="literal">PAGE</tt> context
                    (it isn't mapped to model property).
                </p><pre class="programlisting">&lt;pages&gt;
      &lt;page view-id="/hello.jsp" action="#{helloWorld.sayHello}"&gt;
          &lt;param name="firstName" /&gt;
          &lt;param name="lastName" /&gt;
      &lt;/page&gt;
  &lt;/pages&gt;</pre><p>
                  Propagation of page parameters is especially useful if you want to build multi-layer 
                  master-detail CRUD pages.  You can use it to "remember" which view you were previously
                  on (e.g. when pressing the Save button), and which entity you were editing.
               </p><div class="itemizedlist"><ul type="disc"><li><p>
                          Any <tt class="literal">&lt;s:link&gt;</tt> or <tt class="literal">&lt;s:button&gt;</tt> 
                          transparently propagates the request parameter if that parameter is listed
                          as a page parameter for the view.
                      </p></li><li><p>
                          The value is transparently propagated with any JSF form submission
                          for the page with the given view id. (This means that view parameters
                          behave like <tt class="literal">PAGE</tt>-scoped context variables for
                          faces requests.
                      </p></li></ul></div></div><p>
                  This all sounds pretty complex, and you're probably wondering if such an
                  exotic construct is really worth the effort. Actually, the idea is very
                  natural once you "get it". It is definitely worth taking the time to 
                  understand this stuff. Page parameters are the most elegant way to 
                  propagate state across a non-faces request. They are especially cool for 
                  problems like search screens with bookmarkable results pages, where we 
                  would like to be able to write our application code to handle both POST 
                  and GET requests with the same code. Page parameters eliminate repetitive 
                  listing of request parameters in the view definition and make redirects
                  much easier to code.
              </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3968"></a>5.1.1.1.3.&nbsp;Conversion and Validation</h5></div></div><div></div></div><p>
                You can specify a JSF converter for complex model propreties:
            </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/calculator.jsp" action="#{calculator.calculate}"&gt;
        &lt;param name="x" value="#{calculator.lhs}"/&gt;
        &lt;param name="y" value="#{calculator.rhs}"/&gt;
        &lt;param name="op" converterId="com.my.calculator.OperatorConverter" value="#{calculator.op}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
                Alternatively:
            </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/calculator.jsp" action="#{calculator.calculate}"&gt;
        &lt;param name="x" value="#{calculator.lhs}"/&gt;
        &lt;param name="y" value="#{calculator.rhs}"/&gt;
        &lt;param name="op" converter="#{operatorConverter}" value="#{calculator.op}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
                JSF validators, and <tt class="literal">required="true"</tt> may
                also be used:
            </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/blog.xhtml"&gt;
        &lt;param name="date" 
               value="#{blog.date}" 
               validatorId="com.my.blog.PastDate" 
               required="true"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
                Alternatively:
            </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/blog.xhtml"&gt;
        &lt;param name="date" 
               value="#{blog.date}" 
               validator="#{pastDateValidator}" 
               required="true"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
                Even better, model-based Hibernate validator annotations are automatically
                recognized and validated.
            </p><p>
                When type conversion or validation fails, a global <tt class="literal">FacesMessage</tt>
                is added to the <tt class="literal">FacesContext</tt>.
            </p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4000"></a>5.1.1.2.&nbsp;Navigation</h4></div></div><div></div></div><p>
                You can use standard JSF navigation rules defined in <tt class="literal">faces-config.xml</tt>
                in a Seam application. However, JSF navigation rules have a number of annoying
                limitations:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        It is not possible to specify request parameters to be used when redirecting.
                    </p></li><li><p>
                        It is not possible to begin or end conversations from a rule.
                    </p></li><li><p>
                        Rules work by evaluating the return value of the action method; it is not
                        possible to evaluate an arbitrary EL expression.
                    </p></li></ul></div><p>
                A further problem is that "orchestration" logic gets scattered between <tt class="literal">pages.xml</tt>
                and <tt class="literal">faces-config.xml</tt>. It's better to unify this logic into <tt class="literal">pages.xml</tt>.
            </p><p>
                This JSF navigation rule:
            </p><pre class="programlisting">&lt;navigation-rule&gt;
    &lt;from-view-id&gt;/editDocument.xhtml&lt;/from-view-id&gt;
    
    &lt;navigation-case&gt;
        &lt;from-action&gt;#{documentEditor.update}&lt;/from-action&gt;
        &lt;from-outcome&gt;success&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/viewDocument.xhtml&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;
    
&lt;/navigation-rule&gt;</pre><p>
                Can be rewritten as follows:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;rule if-outcome="success"&gt;
            &lt;redirect view-id="/viewDocument.xhtml"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                But it would be even nicer if we didn't have to pollute our <tt class="literal">DocumentEditor</tt> 
                component with string-valued return values (the JSF outcomes). So Seam lets us write:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}" 
                   evaluate="#{documentEditor.errors.size}"&gt;
        &lt;rule if-outcome="0"&gt;
            &lt;redirect view-id="/viewDocument.xhtml"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                Or even:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;rule if="#{documentEditor.errors.empty}"&gt;
            &lt;redirect view-id="/viewDocument.xhtml"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                The first form evaluates a value binding to determine the outcome value
                to be used by the subsequent rules.
                The second approach ignores the outcome and evaluates a value binding
                for each possible rule.
            </p><p>
                Of course, when an update succeeds, we probably want to end the current
                conversation. We can do that like this:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;rule if="#{documentEditor.errors.empty}"&gt;
            &lt;end-conversation/&gt;
            &lt;redirect view-id="/viewDocument.xhtml"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                As we've ended conversation any subsequent requests won't know
                which document we are interested in.  We can pass the document 
                id as a request parameter which also makes the view bookmarkable:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;rule if="#{documentEditor.errors.empty}"&gt;
            &lt;end-conversation/&gt;
            &lt;redirect view-id="/viewDocument.xhtml"&gt;
                &lt;param name="documentId" value="#{documentEditor.documentId}"/&gt;
            &lt;/redirect&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                Null outcomes are a special case in JSF. The null outcome is interpreted to
                mean "redisplay the page". The following navigation rule matches any non-null
                outcome, but <span class="emphasis"><em>not</em></span> the null outcome:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;rule&gt;
            &lt;render view-id="/viewDocument.xhtml"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                If you want to perform navigation when a null outcome occurs, use the
                following form instead:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;
    
    &lt;navigation from-action="#{documentEditor.update}"&gt;
        &lt;render view-id="/viewDocument.xhtml"/&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre><p>
                The view-id may be given as a JSF EL expression:
            </p><pre class="programlisting">&lt;page view-id="/editDocument.xhtml"&gt;

    &lt;navigation if-outcome="success"&gt;
        &lt;redirect view-id="/#{userAgent}/displayDocument.xhtml"/&gt;
    &lt;/navigation&gt;
    
&lt;/page&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4073"></a>5.1.1.3.&nbsp;Fine-grained files for definition of navigation, page actions and parameters</h4></div></div><div></div></div><p>
                If you have a lot of different page actions and page parameters,
                or even just a lot of navigation rules,
                you will almost certainly want to split the declarations up over
                multiple files. You can define actions and parameters for a page
                with the view id <tt class="literal">/calc/calculator.jsp</tt> in a 
                resource named <tt class="literal">calc/calculator.page.xml</tt>. The
                root element in this case is the <tt class="literal">&lt;page&gt;</tt>
                element, and the view id is implied:
            </p><pre class="programlisting">&lt;page action="#{calculator.calculate}"&gt;
    &lt;param name="x" value="#{calculator.lhs}"/&gt;
    &lt;param name="y" value="#{calculator.rhs}"/&gt;
    &lt;param name="op" converter="#{operatorConverter}" value="#{calculator.op}"/&gt;
&lt;/page&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4089"></a>5.1.2.&nbsp;Component-driven events</h3></div></div><div></div></div><p>
                Seam components can interact by simply calling each others methods.
                Stateful components may even implement the observer/observable pattern.
                But to enable components to interact in a more loosely-coupled fashion
                than is possible when the components call each others methods directly,
                Seam provides <span class="emphasis"><em>component-driven events</em></span>.
            </p><p>
                We specify event listeners (observers) in <tt class="literal">components.xml</tt>.
            </p><pre class="programlisting">&lt;components&gt;
    &lt;event type="hello"&gt;
        &lt;action execute="#{helloListener.sayHelloBack}"/&gt;
        &lt;action execute="#{logger.logHello}"/&gt;
    &lt;/event&gt;
&lt;/components&gt;</pre><p>
                Where the <span class="emphasis"><em>event type</em></span> is just an arbitrary string.
            </p><p>
                When an event occurs, the actions registered for that event will be called
                in the order they appear in <tt class="literal">components.xml</tt>. How does a
                component raise an event? Seam provides a built-in component for this.
            </p><pre class="programlisting">@Name("helloWorld")
public class HelloWorld {
    public void sayHello() {
        FacesMessages.instance().add("Hello World!");
        Events.instance().raiseEvent("hello");
    }
}</pre><p>
                Or you can use an annotation.
            </p><pre class="programlisting">@Name("helloWorld")
public class HelloWorld {
    @RaiseEvent("hello")
    public void sayHello() {
        FacesMessages.instance().add("Hello World!");
    }
}</pre><p>
                Notice that this event producer has no dependency upon event consumers.
                The event listener may now be implemented with absolutely no dependency
                upon the producer:
            </p><pre class="programlisting">@Name("helloListener")
public class HelloListener {
    public void sayHelloBack() {
        FacesMessages.instance().add("Hello to you too!");
    }
}</pre><p>
                The method binding defined in <tt class="literal">components.xml</tt> above 
                takes care of mapping the event to the consumer.
                If you don't like futzing about in the <tt class="literal">components.xml</tt> 
                file, you can use an annotation instead:
            </p><pre class="programlisting">@Name("helloListener")
public class HelloListener {
    @Observer("hello")
    public void sayHelloBack() {
        FacesMessages.instance().add("Hello to you too!");
    }
}</pre><p>
                You might wonder why I've not mentioned anything about event objects in
                this discussion. In Seam, there is no need for an event object to propagate
                state between event producer and listener. State is held in the Seam
                contexts, and is shared between components. However, if you really want
                to pass an event object, you can:
            </p><pre class="programlisting">@Name("helloWorld")
public class HelloWorld {
    private String name;
    public void sayHello() {
        FacesMessages.instance().add("Hello World, my name is #0.", name);
        Events.instance().raiseEvent("hello", name);
    }
}</pre><pre class="programlisting">@Name("helloListener")
public class HelloListener {
    @Observer("hello")
    public void sayHelloBack(String name) {
        FacesMessages.instance().add("Hello #0!", name);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4140"></a>5.1.3.&nbsp;Contextual events</h3></div></div><div></div></div><p>
                Seam defines a number of built-in events that the application can use to
                perform special kinds of framework integration. The events are:
            </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">org.jboss.seam.validationFailed</tt> &#8212; called when JSF validation fails</p></li><li><p><tt class="literal">org.jboss.seam.noConversation</tt> &#8212; called when there is no long running conversation and a long running conversation is required</p></li><li><p><tt class="literal">org.jboss.seam.preSetVariable.&lt;name&gt;</tt> &#8212; called when the context variable &lt;name&gt; is set</p></li><li><p><tt class="literal">org.jboss.seam.postSetVariable.&lt;name&gt;</tt> &#8212; called when the context variable &lt;name&gt; is set</p></li><li><p><tt class="literal">org.jboss.seam.preRemoveVariable.&lt;name&gt;</tt> &#8212; called when the context variable &lt;name&gt; is unset</p></li><li><p><tt class="literal">org.jboss.seam.postRemoveVariable.&lt;name&gt;</tt> &#8212; called when the context variable &lt;name&gt; is unset</p></li><li><p><tt class="literal">org.jboss.seam.preDestroyContext.&lt;SCOPE&gt;</tt> &#8212; called before the &lt;SCOPE&gt; context is destroyed</p></li><li><p><tt class="literal">org.jboss.seam.postDestroyContext.&lt;SCOPE&gt;</tt> &#8212; called after the &lt;SCOPE&gt; context is destroyed</p></li><li><p><tt class="literal">org.jboss.seam.beginConversation </tt>&#8212; called whenever a long-running conversation begins</p></li><li><p><tt class="literal">org.jboss.seam.endConversation </tt>&#8212; called whenever a long-running conversation ends</p></li><li><p><tt class="literal">org.jboss.seam.beginPageflow.&lt;name&gt; </tt>&#8212; called when the pageflow &lt;name&gt; begins</p></li><li><p><tt class="literal">org.jboss.seam.endPageflow.&lt;name&gt; </tt>&#8212; called when the pageflow &lt;name&gt; ends</p></li><li><p><tt class="literal">org.jboss.seam.createProcess.&lt;name&gt; </tt>&#8212; called when the process &lt;name&gt; is created</p></li><li><p><tt class="literal">org.jboss.seam.endProcess.&lt;name&gt; </tt>&#8212; called when the process &lt;name&gt; ends</p></li><li><p><tt class="literal">org.jboss.seam.initProcess.&lt;name&gt; </tt>&#8212; called when the process &lt;name&gt; is associated with the conversation</p></li><li><p><tt class="literal">org.jboss.seam.initTask.&lt;name&gt; </tt>&#8212; called when the task &lt;name&gt; is associated with the conversation</p></li><li><p><tt class="literal">org.jboss.seam.startTask.&lt;name&gt; </tt>&#8212; called when the task &lt;name&gt; is started</p></li><li><p><tt class="literal">org.jboss.seam.endTask.&lt;name&gt; </tt>&#8212; called when the task &lt;name&gt; is ended</p></li><li><p><tt class="literal">org.jboss.seam.postCreate.&lt;name&gt; </tt>&#8212; called when the component &lt;name&gt; is created</p></li><li><p><tt class="literal">org.jboss.seam.preDestroy.&lt;name&gt; </tt>&#8212; called when the component &lt;name&gt; is destroyed</p></li><li><p><tt class="literal">org.jboss.seam.beforePhase </tt>&#8212; called before the start of a JSF phase</p></li><li><p><tt class="literal">org.jboss.seam.afterPhase </tt>&#8212; called after the end of a JSF phase</p></li><li><p><tt class="literal">org.jboss.seam.postInitialization </tt>&#8212; called when Seam has initialized and started up all components</p></li><li><p><tt class="literal">org.jboss.seam.postAuthenticate.&lt;name&gt; </tt>&#8212; called after a user is authenticated</p></li><li><p><tt class="literal">org.jboss.seam.preAuthenticate.&lt;name&gt; </tt>&#8212; called before attempting to authenticate a user</p></li><li><p><tt class="literal">org.jboss.seam.notLoggedIn</tt> &#8212; called there is no authenticated user and authentication is required</p></li><li><p><tt class="literal">org.jboss.seam.rememberMe</tt> &#8212; occurs when Seam security detects the username in a cookie</p></li><li><p><tt class="literal">org.jboss.seam.exceptionHandled.&lt;type&gt;</tt> &#8212; called when an uncaught exception is handled by Seam</p></li><li><p><tt class="literal">org.jboss.seam.exceptionHandled</tt> &#8212; called when an uncaught exception is handled by Seam</p></li><li><p><tt class="literal">org.jboss.seam.exceptionNotHandled</tt> &#8212; called when there was no handler for an uncaught exception</p></li><li><p><tt class="literal">org.jboss.seam.afterTransactionSuccess</tt> &#8212; called when a transaction succeeds in the Seam Application Framework</p></li><li><p><tt class="literal">org.jboss.seam.afterTransactionSuccess.&lt;name&gt;</tt> &#8212; called when a transaction succeeds in the Seam Application Framework which manages an entity called <tt class="literal">&lt;name&gt;</tt></p></li></ul></div><p>
                 Seam components may observe any of these events in just the same way they
                 observe any other component-driven events.
             </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4310"></a>5.2.&nbsp;Seam interceptors</h2></div></div><div></div></div><p>
        EJB 3.0 introduced a standard interceptor model for session bean components. To add an
        interceptor to a bean, you need to write a class with a method annotated 
        <tt class="literal">@AroundInvoke</tt> and annotate the bean with an
        <tt class="literal">@Interceptors</tt> annotation that specifies the name of the interceptor
        class. For example, the following interceptor checks that the user is logged in before
        allowing invoking an action listener method:
      </p><pre class="programlisting">public class LoggedInInterceptor {

   @AroundInvoke
   public Object checkLoggedIn(InvocationContext invocation) throws Exception {
   
      boolean isLoggedIn = Contexts.getSessionContext().get("loggedIn")!=null;
      if (isLoggedIn) {
         //the user is already logged in
         return invocation.proceed();
      }
      else {
         //the user is not logged in, fwd to login page
         return "login";
      }
   }

}</pre><p>
        To apply this interceptor to a session bean which acts as an action listener, we must
        annotate the session bean <tt class="literal">@Interceptors(LoggedInInterceptor.class)</tt>.
        This is a somewhat ugly annotation. Seam builds upon the interceptor framework in
        EJB3 by allowing you to use <tt class="literal">@Interceptors</tt> as a meta-annotation. In
        our example, we would create an <tt class="literal">@LoggedIn</tt> annotation, as follows:
    </p><pre class="programlisting">@Target(TYPE)
@Retention(RUNTIME)
@Interceptors(LoggedInInterceptor.class)
public @interface LoggedIn {}</pre><p>
            We can now simply annotate our action listener bean with <tt class="literal">@LoggedIn</tt>
            to apply the interceptor.
        </p><pre class="programlisting">@Stateless
@Name("changePasswordAction")
@LoggedIn
@Interceptors(SeamInterceptor.class)
public class ChangePasswordAction implements ChangePassword { 
    
    ...
    
    public String changePassword() { ... }
    
}</pre><p>
            If interceptor ordering is important (it usually is), you can add
            <tt class="literal">@Interceptor</tt> annotations to your interceptor 
            classes to specify a partial order of interceptors.
        </p><pre class="programlisting">@Interceptor(around={BijectionInterceptor.class,
                     ValidationInterceptor.class,
                     ConversationInterceptor.class},
             within=RemoveInterceptor.class)
public class LoggedInInterceptor
{
    ...
}</pre><p>
            You can even have a "client-side" interceptor, that runs around any of the built-in
            functionality of EJB3:
        </p><pre class="programlisting">@Interceptor(type=CLIENT)
public class LoggedInInterceptor
{
    ...
}</pre><p>
            EJB interceptors are stateful, with a lifecycle that is the same as the component
            they intercept. For interceptors which do not need to maintain state, Seam lets
            you get a performance optimization by specifying 
            <tt class="literal">@Interceptor(stateless=true)</tt>.
        </p><p>
            Much of the functionality of Seam is implemented as a set of built-in Seam interceptors,
            including the interceptors named in the previous example. You don't have to explicitly 
            specify these interceptors by annotating your components; they exist for all interceptable 
            Seam components.
        </p><p>
            You can even use Seam interceptors with JavaBean components, not just EJB3 beans!
        </p><p>
            EJB defines interception not only for business methods (using <tt class="literal">@AroundInvoke</tt>),
            but also for the lifecycle methods <tt class="literal">@PostConstruct</tt>, <tt class="literal">@PreDestroy</tt>,
            <tt class="literal">@PrePassivate</tt> and <tt class="literal">@PostActive</tt>. Seam supports all these
            lifecycle methods on both component and interceptor not only for EJB3 beans, but also for
            JavaBean components (except <tt class="literal">@PreDestroy</tt> which is not meaningful for JavaBean
            components).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4383"></a>5.3.&nbsp;Managing exceptions</h2></div></div><div></div></div><p>
            JSF is surprisingly limited when it comes to exception handling. As a partial 
            workaround for this problem, Seam lets you define how a particular class of 
            exception is to be treated by annotating the exception class, or declaring
            the exception class in an XML file. This facility is meant to be combined with 
            the EJB 3.0-standard <tt class="literal">@ApplicationException</tt> annotation which 
            specifies whether the exception should cause a transaction rollback.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4391"></a>5.3.1.&nbsp;Exceptions and transactions</h3></div></div><div></div></div><p>
                EJB specifies well-defined rules that let us control whether an exception 
                immediately marks the current transaction for rollback when it is thrown by 
                a business method of the bean: <span class="emphasis"><em>system exceptions</em></span> always 
                cause a transaction rollback, <span class="emphasis"><em>application exceptions</em></span> do 
                not cause a rollback by default, but they do if 
                <tt class="literal">@ApplicationException(rollback=true)</tt>
                is specified. (An application exception is any checked exception, or any
                unchecked exception annotated <tt class="literal">@ApplicationException</tt>.
                A system exception is any unchecked exception without an 
                <tt class="literal">@ApplicationException</tt> annotation.)
            </p><p>
                Note that there is a difference between marking a transaction for rollback,
                and actually rolling it back. The exception rules say that the transaction
                should be marked rollback only, but it may still be active after the 
                exception is thrown.
            </p><p>
                Seam applies the EJB 3.0 exception rollback rules also to Seam JavaBean 
                components.
            </p><p>
                But these rules only apply in the Seam component layer. What about an exception 
                that is uncaught and propagates out of the Seam component layer, and out of the JSF 
                layer? Well, it is always wrong to leave a dangling transaction open, so Seam
                rolls back any active transaction when an exception occurs and is uncaught
                in the Seam component layer.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4417"></a>5.3.2.&nbsp;Enabling Seam exception handling</h3></div></div><div></div></div><p>
            To enable Seam's exception handling, we need to make sure we have the master servlet 
            filter declared in <tt class="literal">web.xml</tt>:
        </p><pre class="programlisting">&lt;filter&gt;
    &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.jboss.seam.servlet.SeamFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre><p>
            You may also need to disable Facelets development mode in <tt class="literal">web.xml</tt> and
            Seam debug mode in <tt class="literal">components.xml</tt> if you want your exception handlers
            to fire.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4435"></a>5.3.3.&nbsp;Using annotations for exception handling</h3></div></div><div></div></div><p>
            The following exception results in a HTTP 404 error whenever it propagates out of the
            Seam component layer. It does not roll back the current transaction immediately when 
            thrown, but the transaction will be rolled back if it the exception is not caught by
            another Seam component.
        </p><pre class="programlisting">@HttpError(errorCode=404)
public class ApplicationException extends Exception { ... }</pre><p>
            This exception results in a browser redirect whenever it propagates out of the
            Seam component layer. It also ends the current conversation. It causes an immediate 
            rollback of the current transaction.
        </p><pre class="programlisting">@Redirect(viewId="/failure.xhtml", end=true)
@ApplicationException(rollback=true)
public class UnrecoverableApplicationException extends RuntimeException { ... }</pre><p>
            Note that <tt class="literal">@Redirect</tt> does not work for exceptions
            which occur during the render phase of the JSF lifecycle.
        </p><p>
            You can also use EL to specify the <tt class="literal">viewId</tt> to redirect to.
        </p><p>
            This exception results in a redirect, along with a message to the user, when it 
            propagates out of the Seam component layer. It also immediately rolls back the 
            current transaction.
        </p><pre class="programlisting">@Redirect(viewId="/error.xhtml", message="Unexpected error")
public class SystemException extends RuntimeException { ... }</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4460"></a>5.3.4.&nbsp;Using XML for exception handling</h3></div></div><div></div></div><p>
            Since we can't add annotations to all the exception classes we are interested in,
            Seam also lets us specify this functionality in <tt class="literal">pages.xml</tt>.
        </p><pre class="programlisting">&lt;pages&gt;
   
   &lt;exception class="javax.persistence.EntityNotFoundException"&gt;
      &lt;http-error error-code="404"/&gt;
   &lt;/exception&gt;
   
   &lt;exception class="javax.persistence.PersistenceException"&gt;
      &lt;end-conversation/&gt;
      &lt;redirect view-id="/error.xhtml"&gt;
          &lt;message&gt;Database access failed&lt;/message&gt;
      &lt;/redirect&gt;
   &lt;/exception&gt;
   
   &lt;exception&gt;
      &lt;end-conversation/&gt;
      &lt;redirect view-id="/error.xhtml"&gt;
          &lt;message&gt;Unexpected failure&lt;/message&gt;
      &lt;/redirect&gt;
   &lt;/exception&gt;
   
&lt;/pages&gt;</pre><p>
            The last <tt class="literal">&lt;exception&gt;</tt> declaration does not specify a class,
            and is a catch-all for any exception for which handling is not otherwise specified
            via annotations or in <tt class="literal">pages.xml</tt>.
        </p><p>
            You can also use EL to specify the <tt class="literal">view-id</tt> to redirect to.
        </p><p>
           You can also access the handled exception instance through EL, Seam places it in the
           conversation context, e.g. to access the message of the exception:
        </p><pre class="programlisting">...
throw new AuthorizationException("You are not allowed to do this!");

&lt;pages&gt;

    &lt;exception class="org.jboss.seam.security.AuthorizationException"&gt;
        &lt;end-conversation/&gt;
        &lt;redirect view-id="/error.xhtml"&gt;
            &lt;message severity="WARN"&gt;#{org.jboss.seam.handledException.message}&lt;/message&gt;
        &lt;/redirect&gt;
    &lt;/exception&gt;

&lt;/pages&gt;</pre><p>
           <tt class="literal">org.jboss.seam.handledException</tt> holds the nested exception that
           was actually handled by an exception handler. The outermost (wrapper) exception is 
           also available, as <tt class="literal">org.jboss.seam.exception</tt>.
         </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4495"></a>5.3.5.&nbsp;Some common exceptions</h3></div></div><div></div></div><p>
                If you are using JPA:
            </p><pre class="programlisting">&lt;exception class="javax.persistence.EntityNotFoundException"&gt;
   &lt;redirect view-id="/error.xhtml"&gt;
      &lt;message&gt;Not found&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;

&lt;exception class="javax.persistence.OptimisticLockException"&gt;
   &lt;end-conversation/&gt;
   &lt;redirect view-id="/error.xhtml"&gt;
      &lt;message&gt;Another user changed the same data, please try again&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;</pre><p>
                If you are using the Seam Application Framework:
            </p><pre class="programlisting">&lt;exception class="org.jboss.seam.framework.EntityNotFoundException"&gt;
   &lt;redirect view-id="/error.xhtml"&gt;
      &lt;message&gt;Not found&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;</pre><p>
                If you are using Seam Security:
            </p><pre class="programlisting">&lt;exception class="org.jboss.seam.security.AuthorizationException"&gt;
   &lt;redirect&gt;
      &lt;message&gt;You don't have permission to do this&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;
    
&lt;exception class="org.jboss.seam.security.NotLoggedInException"&gt;
   &lt;redirect view-id="/login.xhtml"&gt;
      &lt;message&gt;Please log in first&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;</pre><p>
               And, for JSF:
            </p><pre class="programlisting">&lt;exception class="javax.faces.application.ViewExpiredException"&gt;
   &lt;redirect view-id="/error.xhtml"&gt;
      &lt;message&gt;Your session has timed out, please try again&lt;/message&gt;
   &lt;/redirect&gt;
&lt;/exception&gt;</pre><p>
                A <tt class="literal">ViewExpiredException</tt> occurs if the user posts back
                to a page once their session has expired.  <tt class="literal">no-conversation-view-id</tt>
                and <tt class="literal">conversation-required</tt> give you finer grained control over
                session expiration if you are inside a conversation.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="conversations"></a>Chapter&nbsp;6.&nbsp;Conversations and workspace management</h2></div></div><div></div></div><p>
        It's time to understand Seam's conversation model in more detail.
    </p><p>
        Historically, the notion of a Seam "conversation" came about as
        a merger of three different ideas:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            The idea of a <span class="emphasis"><em>workspace</em></span>, which I 
            encountered in a project for the Victorian government in 
            2002. In this project I was forced to implement workspace 
            management on top of Struts, an experience I pray never
            to repeat.
        </p></li><li><p>
            The idea of an <span class="emphasis"><em>application transaction</em></span>
            with optimistic semantics, and the realization that existing
            frameworks based around a stateless architecture could not
            provide effective management of extended persistence contexts.
            (The Hibernate team is truly fed up with copping the blame for
            <tt class="literal">LazyInitializationException</tt>s, which are
            not really Hibernate's fault, but rather the fault of the 
            extremely limiting persistence context model supported by 
            stateless architectures such as the Spring framework or the 
            traditional <span class="emphasis"><em>stateless session facade</em></span> 
            (anti)pattern in J2EE.)
        </p></li><li><p>
            The idea of a workflow <span class="emphasis"><em>task</em></span>.
        </p></li></ul></div><p>
        By unifying these ideas and providing deep support in the framework, 
        we have a powerful construct that lets us build richer and more efficient 
        applications with less code than before.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4559"></a>6.1.&nbsp;Seam's conversation model</h2></div></div><div></div></div><p>
        The examples we have seen so far make use of a very simple
        conversation model that follows these rules:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            There is always a conversation context active during the
            apply request values, process validations, update model values, 
            invoke application and render response phases of the JSF request 
            lifecycle.
        </p></li><li><p>
            At the end of the restore view phase of the JSF request 
            lifecycle, Seam attempts to restore any previous long-running
            conversation context. If none exists, Seam creates a new
            temporary conversation context.
        </p></li><li><p>
            When an <tt class="literal">@Begin</tt> method is encountered, 
            the temporary conversation context is promoted to a long
            running conversation.
        </p></li><li><p>
            When an <tt class="literal">@End</tt> method is encountered, 
            any long-running conversation context is demoted to a 
            temporary conversation.
        </p></li><li><p>
            At the end of the render response phase of the JSF request
            lifecycle, Seam stores the contents of a long running
            conversation context or destroys the contents of a temporary
            conversation context.
        </p></li><li><p>
            Any faces request (a JSF postback) will propagate the 
            conversation context. By default, non-faces requests (GET 
            requests, for example) do not propagate the conversation 
            context, but see below for more information on this.
        </p></li><li><p>
            If the JSF request lifecycle is foreshortened by a redirect,
            Seam transparently stores and restores the current conversation 
            context&#8212;unless the conversation was already ended via
            <tt class="literal">@End(beforeRedirect=true)</tt>.
        </p></li></ul></div><p>
            Seam transparently propagates the conversation context (including
            the temporary conversation context) across JSF postbacks and 
            redirects. If you don't do anything special, a <span class="emphasis"><em>non-faces request</em></span>
            (a GET request for example) will not propagate the conversation context and
            will be processed in a new temporary conversation. This is usually - but not
            always - the desired behavior.
        </p><p>
            If you want to propagate a Seam conversation across a non-faces request, you
            need to explicitly code the Seam <span class="emphasis"><em>conversation id</em></span> as a 
            request parameter:
        </p><pre class="programlisting">&lt;a href="main.jsf?conversationId=#{conversation.id}"&gt;Continue&lt;/a&gt;</pre><p>
            Or, the more JSF-ish:
        </p><pre class="programlisting">&lt;h:outputLink value="main.jsf"&gt;
    &lt;f:param name="conversationId" value="#{conversation.id}"/&gt;
    &lt;h:outputText value="Continue"/&gt;
&lt;/h:outputLink&gt;</pre><p>
            If you use the Seam tag library, this is equivalent:
        </p><pre class="programlisting">&lt;h:outputLink value="main.jsf"&gt;
    &lt;s:conversationId/&gt;
    &lt;h:outputText value="Continue"/&gt;
&lt;/h:outputLink&gt;</pre><p>
            If you wish to disable propagation of the conversation context for a
            postback, a similar trick is used:
        </p><pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;f:param name="conversationPropagation" value="none"/&gt;
&lt;/h:commandLink&gt;</pre><p>
            If you use the Seam tag library, this is equivalent:
        </p><pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;s:conversationPropagation type="none"/&gt;
&lt;/h:commandLink&gt;</pre><p>
            Note that disabling conversation context propagation is absolutely not the
            same thing as ending the conversation.
        </p><p>
            The <tt class="literal">conversationPropagation</tt> request parameter, or 
            the <tt class="literal">&lt;s:conversationPropagation&gt;</tt> tag may even
            be used to begin and end conversation, or begin a nested 
            conversation.
        </p><pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;s:conversationPropagation type="end"/&gt;
&lt;/h:commandLink&gt;</pre><pre class="programlisting">&lt;h:commandLink action="main" value="Select Child"&gt;
    &lt;s:conversationPropagation type="nested"/&gt;
&lt;/h:commandLink&gt;</pre><pre class="programlisting">&lt;h:commandLink action="main" value="Select Hotel"&gt;
    &lt;s:conversationPropagation type="begin"/&gt;
&lt;/h:commandLink&gt;</pre><pre class="programlisting">&lt;h:commandLink action="main" value="Select Hotel"&gt;
    &lt;s:conversationPropagation type="join"/&gt;
&lt;/h:commandLink&gt;</pre><p>
        This conversation model makes it easy to build applications which
        behave correctly with respect to multi-window operation. For many
        applications, this is all that is needed. Some complex applications
        have either or both of the following additional requirements:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            A conversation spans many smaller units of user interaction,
            which execute serially or even concurrently. The smaller
            <span class="emphasis"><em>nested conversations</em></span> have their own
            isolated set of conversation state, and also have access to
            the state of the outer conversation.
        </p></li><li><p>
            The user is able to switch between many conversations
            within the same browser window. This feature is called
            <span class="emphasis"><em>workspace management</em></span>.
        </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4656"></a>6.2.&nbsp;Nested conversations</h2></div></div><div></div></div><p>
            A nested conversation is created by invoking a method marked
            <tt class="literal">@Begin(nested=true)</tt> inside the scope of an
            existing conversation. A nested conversation has its own
            conversation context, and also has read-only access to the
            context of the outer conversation. (It can read the outer
            conversation's context variables, but not write to them.)
            When an <tt class="literal">@End</tt> is subsequently encountered,
            the nested conversation will be destroyed, and the outer
            conversation will resume, by "popping" the conversation stack.
            Conversations may be nested to any arbitrary depth.
        </p><p>
            Certain user activity (workspace management, or the back button)
            can cause the outer conversation to be resumed before the inner
            conversation is ended. In this case it is possible to have 
            multiple concurrent nested conversations belonging to the
            same outer conversation. If the outer conversation ends before
            a nested conversation ends, Seam destroys all nested conversation
            contexts along with the outer context.
        </p><p>
            A conversation may be thought of as a <span class="emphasis"><em>continuable state</em></span>.
            Nested conversations allow the application to capture a consistent
            continuable state at various points in a user interaction, thus
            insuring truly correct behavior in the face of backbuttoning and
            workspace management.
        </p><p>
            TODO: an example to show how a nested conversation prevents bad 
            stuff happening when you backbutton.
        </p><p>
            Usually, if a component exists in a parent conversation of the 
            current nested conversation, the nested conversation will use
            the same instance. Occasionally, it is useful to have a different
            instance in each nested conversation, so that the component 
            instance that exists in the parent conversation is invisible to
            its child conversations. You can achieve this behavior by 
            annotating the component <tt class="literal">@PerNestedConversation</tt>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4681"></a>6.3.&nbsp;Starting conversations with GET requests</h2></div></div><div></div></div><p>
            JSF does not define any kind of action listener that is triggered
            when a page is accessed via a non-faces request (for example, a
            HTTP GET request). This can occur if the user bookmarks the page,
            or if we navigate to the page via an <tt class="literal">&lt;h:outputLink&gt;</tt>.
        </p><p>
            Sometimes we want to begin a conversation immediately the page is
            accessed. Since there is no JSF action method, we can't solve the problem
            in the usual way, by annotating the action with <tt class="literal">@Begin</tt>.
        </p><p>
            A further problem arises if the page needs some state to be fetched
            into a context variable. We've already seen two ways to solve this 
            problem. If that state is held in a Seam component, we can fetch the 
            state in a <tt class="literal">@Create</tt> method. If not, we can define a
            <tt class="literal">@Factory</tt> method for the context variable.
        </p><p>
            If none of these options works for you, Seam lets you define a
            <span class="emphasis"><em>page action</em></span> in the <tt class="literal">pages.xml</tt>
            file.
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/messageList.jsp" action="#{messageManager.list}"/&gt;
    ...
&lt;/pages&gt;</pre><p>
            This action method is called at the beginning of the render response
            phase, any time the page is about to be rendered. If a page action
            returns a non-null outcome, Seam will process any appropriate JSF and
            Seam navigation rules, possibly resulting in a completely different page 
            being rendered.
        </p><p>
            If <span class="emphasis"><em>all</em></span> you want to do before rendering the page
            is begin a conversation, you could use a built-in action method that
            does just that:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/messageList.jsp" action="#{conversation.begin}"/&gt;
    ...
&lt;/pages&gt;</pre><p>
            Note that you can also call this built-in action from a JSF
            control, and, similarly, you can use 
            <tt class="literal">#{conversation.end}</tt> to end conversations.
        </p><p>
            If you want more control, to join existing conversations or
            begin a nested conversion, to begin a pageflow or an atomic
            conversation, you should use the 
            <tt class="literal">&lt;begin-conversation&gt;</tt> element.
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/messageList.jsp"&gt;
       &lt;begin-conversation nested="true" pageflow="AddItem"/&gt;
    &lt;page&gt;
    ...
&lt;/pages&gt;</pre><p>
            There is also an <tt class="literal">&lt;end-conversation&gt;</tt> 
            element.
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/home.jsp"&gt;
       &lt;end-conversation/&gt;
    &lt;page&gt;
    ...
&lt;/pages&gt;</pre><p>
            To solve the first problem, we now have five options:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                Annotate the <tt class="literal">@Create</tt> method with
                <tt class="literal">@Begin</tt>
            </p></li><li><p>
                Annotate the <tt class="literal">@Factory</tt> method with
                <tt class="literal">@Begin</tt>
            </p></li><li><p>
                Annotate the Seam page action method with
                <tt class="literal">@Begin</tt>
            </p></li><li><p>
                Use <tt class="literal">&lt;begin-conversation&gt;</tt> in
                <tt class="literal">pages.xml</tt>.
            </p></li><li><p>
                Use <tt class="literal">#{conversation.begin}</tt> as
                the Seam page action method
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4782"></a>6.4.&nbsp;Using <tt class="literal">&lt;s:link&gt;</tt> and <tt class="literal">&lt;s:button&gt;</tt></h2></div></div><div></div></div><p>
            JSF command links always perform a form submission via JavaScript, 
            which breaks the web browser's "open in new window" or "open in new tab"
            feature. In plain JSF, you need to use an <tt class="literal">&lt;h:outputLink&gt;</tt>
            if you need this functionality. But there are two major limitations to 
            <tt class="literal">&lt;h:outputLink&gt;</tt>.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            JSF provides no way to attach an action listener to an 
            <tt class="literal">&lt;h:outputLink&gt;</tt>.
        </p></li><li><p>
            JSF does not propagate the selected row of a <tt class="literal">DataModel</tt> 
            since there is no actual form submission.
        </p></li></ul></div><p>
            Seam provides the notion of a <span class="emphasis"><em>page action</em></span> to help 
            solve the first problem, but this does nothing to help us with the second 
            problem. We <span class="emphasis"><em>could</em></span> work around this by using the
            RESTful approach of passing a request parameter and requerying
            for the selected object on the server side. In some cases&#8212;such as the 
            Seam blog example application&#8212;this is indeed the best approach. The 
            RESTful style supports bookmarking, since it does not require server-side state. 
            In other cases, where we don't care about bookmarks, the use of 
            <tt class="literal">@DataModel</tt> and <tt class="literal">@DataModelSelection</tt> is 
            just so convenient and transparent!
        </p><p>
            To fill in this missing functionality, and to make conversation propagation
            even simpler to manage, Seam provides the <tt class="literal">&lt;s:link&gt;</tt>
            JSF tag.
        </p><p>
            The link may specify just the JSF view id:
        </p><pre class="programlisting">&lt;s:link view="/login.xhtml" value="Login"/&gt;</pre><p>
            Or, it may specify an action method (in which case the action outcome determines
            the page that results):
        </p><pre class="programlisting">&lt;s:link action="#{login.logout}" value="Logout"/&gt;</pre><p>
            If you specify <span class="emphasis"><em>both</em></span> a JSF view id and an action method, the
            'view' will be used <span class="emphasis"><em>unless</em></span> the action method returns a
            non-null outcome:
        </p><pre class="programlisting">&lt;s:link view="/loggedOut.xhtml"  action="#{login.logout}" value="Logout"/&gt;</pre><p>
            The link automatically propagates the selected row of a <tt class="literal">DataModel</tt>
            using inside <tt class="literal">&lt;h:dataTable&gt;</tt>:
        </p><pre class="programlisting">&lt;s:link view="/hotel.xhtml" action="#{hotelSearch.selectHotel}" value="#{hotel.name}"/&gt;</pre><p>
            You can leave the scope of an existing conversation:
        </p><pre class="programlisting">&lt;s:link view="/main.xhtml" propagation="none"/&gt;</pre><p>
            You can begin, end, or nest conversations:
        </p><pre class="programlisting">&lt;s:link action="#{issueEditor.viewComment}" propagation="nest"/&gt;</pre><p>
            If the link begins a conversation, you can even specify a pageflow to be used:
        </p><pre class="programlisting">&lt;s:link action="#{documentEditor.getDocument}" propagation="begin"
        pageflow="EditDocument"/&gt;</pre><p>
            The <tt class="literal">taskInstance</tt> attribute if for use in jBPM task lists:
        </p><pre class="programlisting">&lt;s:link action="#{documentApproval.approveOrReject}" taskInstance="#{task}"/&gt;</pre><p>
            (See the DVD Store demo application for examples of this.)
        </p><p>
            Finally, if you need the "link" to be rendered as a button, use <tt class="literal">&lt;s:button&gt;</tt>:
        </p><pre class="programlisting">&lt;s:button action="#{login.logout}" value="Logout"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4886"></a>6.5.&nbsp;Success messages</h2></div></div><div></div></div><p>
            It is quite common to display a message to the user indicating 
            success or failure of an action. It is convenient to use a JSF
            <tt class="literal">FacesMessage</tt> for this. Unfortunately, a
            successful action often requires a browser redirect, and JSF 
            does not propagate faces messages across redirects. This makes
            it quite difficult to display success messages in plain JSF.
        </p><p>
            The built in conversation-scoped Seam component named 
            <tt class="literal">facesMessages</tt> solves this problem.
            (You must have the Seam redirect filter installed.)
        </p><pre class="programlisting">@Name("editDocumentAction")
@Stateless
public class EditDocumentBean implements EditDocument {
    @In EntityManager em;
    @In Document document;
    @In FacesMessages facesMessages;
    
    public String update() {
        em.merge(document);
        facesMessages.add("Document updated");
    }
}</pre><p>
            Any message added to <tt class="literal">facesMessages</tt> is
            used in the very next render response phase for the current
            conversation. This even works when there is no long-running
            conversation since Seam preserves even temporary conversation
            contexts across redirects.
        </p><p>
            You can even include JSF EL expressions in a faces message summary:
        </p><pre class="programlisting">facesMessages.add("Document #{document.title} was updated");</pre><p>
            You may display the messages in the usual way, for example:
        </p><pre class="programlisting">&lt;h:messages globalOnly="true"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4914"></a>6.6.&nbsp;Using an "explicit" conversation id</h2></div></div><div></div></div><p>
            Ordinarily, Seam generates a meaningless unique id for each conversation
            in each session. You can customize the id value when you begin the 
            conversation.
        </p><p>
            This feature can be used to customize the conversation id generation
            algorithm like so:
        </p><pre class="programlisting">@Begin(id="#{myConversationIdGenerator.nextId}") 
public void editHotel() { ... }</pre><p>
            Or it can be used to assign a meaningful conversation id:
        </p><pre class="programlisting">@Begin(id="hotel#{hotel.id}") 
public String editHotel() { ... }</pre><pre class="programlisting">@Begin(id="hotel#{hotelsDataModel.rowData.id}") 
public String selectHotel() { ... }</pre><pre class="programlisting">@Begin(id="entry#{params['blogId']}")
public String viewBlogEntry() { ... }</pre><pre class="programlisting">@BeginTask(id="task#{taskInstance.id}") 
public String approveDocument() { ... }</pre><p>
            Clearly, these example result in the same conversation id every time
            a particular hotel, blog or task is selected. So what happens if a conversation
            with the same conversation id already exists when the new conversation
            begins? Well, Seam detects the existing conversation and redirects
            to that conversation without running the <tt class="literal">@Begin</tt> 
            method again. This feature helps control the number of workspaces
            that are created when using workspace management.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4938"></a>6.7.&nbsp;Workspace management</h2></div></div><div></div></div><p>
            Workspace management is the ability to "switch" conversations in
            a single window. Seam makes workspace management completely 
            transparent at the level of the Java code. To enable workspace
            management, all you need to do is:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                Provide <span class="emphasis"><em>description</em></span> text for each view id 
                (when using JSF or Seam navigation rules) or page node (when using 
                jPDL pageflows). This description text is displayed to the user 
                by the workspace switchers.
            </p></li><li><p>
                Include one or more of the standard workspace switcher JSP
                or facelets fragments in your pages. The standard fragments
                support workspace management via a drop down menu, a list
                of conversations, or breadcrumbs.
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4953"></a>6.7.1.&nbsp;Workspace management and JSF navigation</h3></div></div><div></div></div><p>
                When you use JSF or Seam navigation rules, Seam switches to a
                conversation by restoring the current <tt class="literal">view-id</tt>
                for that conversation. The descriptive text for the
                workspace is defined in a file called <tt class="literal">pages.xml</tt>
                that Seam expects to find in the <tt class="literal">WEB-INF</tt>
                directory, right next to <tt class="literal">faces-config.xml</tt>:
            </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/main.xhtml"&gt;Search hotels: #{hotelBooking.searchString}&lt;/page&gt;
    &lt;page view-id="/hotel.xhtml"&gt;View hotel: #{hotel.name}&lt;/page&gt;
    &lt;page view-id="/book.xhtml"&gt;Book hotel: #{hotel.name}&lt;/page&gt;
    &lt;page view-id="/confirm.xhtml"&gt;Confirm: #{booking.description}&lt;/page&gt;
&lt;/pages&gt;</pre><p>
               Note that if this file is missing, the Seam application will
               continue to work perfectly! The only missing functionality
               will be the ability to switch workspaces.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4974"></a>6.7.2.&nbsp;Workspace management and jPDL pageflow</h3></div></div><div></div></div><p>
                When you use a jPDL pageflow definition, Seam switches
                to a conversation by restoring the current jBPM process
                state. This is a more flexible model since it allows the
                same <tt class="literal">view-id</tt> to have different
                descriptions depending upon the current 
                <tt class="literal">&lt;page&gt;</tt> node. The description
                text is defined by the <tt class="literal">&lt;page&gt;</tt> 
                node:
            </p><pre class="programlisting">&lt;pageflow-definition name="shopping"&gt;

   &lt;start-state name="start"&gt;
      &lt;transition to="browse"/&gt;
   &lt;/start-state&gt;
   
   &lt;page name="browse" view-id="/browse.xhtml"&gt;
      &lt;description&gt;DVD Search: #{search.searchPattern}&lt;/description&gt;
      &lt;transition to="browse"/&gt;
      &lt;transition name="checkout" to="checkout"/&gt;
   &lt;/page&gt;
   
   &lt;page name="checkout" view-id="/checkout.xhtml"&gt;
      &lt;description&gt;Purchase: $#{cart.total}&lt;/description&gt;
      &lt;transition to="checkout"/&gt;
      &lt;transition name="complete" to="complete"/&gt;
   &lt;/page&gt;
   
   &lt;page name="complete" view-id="/complete.xhtml"&gt;
      &lt;end-conversation /&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4990"></a>6.7.3.&nbsp;The conversation switcher</h3></div></div><div></div></div><p>
                Include the following fragment in your JSP or facelets page
                to get a drop-down menu that lets you switch to any
                current conversation, or to any other page of the application:
            </p><pre class="programlisting">&lt;h:selectOneMenu value="#{switcher.conversationIdOrOutcome}"&gt;
    &lt;f:selectItem itemLabel="Find Issues" itemValue="findIssue"/&gt;
    &lt;f:selectItem itemLabel="Create Issue" itemValue="editIssue"/&gt;
    &lt;f:selectItems value="#{switcher.selectItems}"/&gt;
&lt;/h:selectOneMenu&gt;
&lt;h:commandButton action="#{switcher.select}" value="Switch"/&gt;</pre><p>
                In this example, we have a menu that includes an item for each
                conversation, together with two additional items that let the
                user begin a new conversation.
            </p><p>
                Only conversations with a description will be included in the
                drop-down menu.
            </p><div class="mediaobject" align="center"><img src="../shared/images/switcher.png" align="middle"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5006"></a>6.7.4.&nbsp;The conversation list</h3></div></div><div></div></div><p>
                The conversation list is very similar to the conversation switcher,
                except that it is displayed as a table:
            </p><pre class="programlisting">&lt;h:dataTable value="#{conversationList}" var="entry"
        rendered="#{not empty conversationList}"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Workspace&lt;/f:facet&gt;
        &lt;h:commandLink action="#{entry.select}" value="#{entry.description}"/&gt;
        &lt;h:outputText value="[current]" rendered="#{entry.current}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Activity&lt;/f:facet&gt;
        &lt;h:outputText value="#{entry.startDatetime}"&gt;
            &lt;f:convertDateTime type="time" pattern="hh:mm a"/&gt;
        &lt;/h:outputText&gt;
        &lt;h:outputText value=" - "/&gt;
        &lt;h:outputText value="#{entry.lastDatetime}"&gt;
            &lt;f:convertDateTime type="time" pattern="hh:mm a"/&gt;
        &lt;/h:outputText&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
        &lt;h:commandButton action="#{entry.select}" value="#{msg.Switch}"/&gt;
        &lt;h:commandButton action="#{entry.destroy}" value="#{msg.Destroy}"/&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre><p>
                We imagine that you will want to customize this for your own application.
            </p><div class="mediaobject" align="center"><img src="../shared/images/list.png" align="middle"></div><p>
                Only conversations with a description will be included in the
                list.
            </p><p>
                Notice that the conversation list lets the user destroy workspaces.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5024"></a>6.7.5.&nbsp;Breadcrumbs</h3></div></div><div></div></div><p>
                Breadcrumbs are useful in applications which use a nested conversation
                model. The breadcrumbs are a list of links to conversations in the
                current conversation stack:
            </p><pre class="programlisting">&lt;ui:repeat value="#{conversationStack}" var="entry"&gt;
    &lt;h:outputText value=" | "/&gt; 
    &lt;h:commandLink value="#{entry.description}" action="#{entry.select}"/&gt;
&lt;/ui:repeat</pre><div class="mediaobject" align="center"><img src="../shared/images/breadcrumbs.png" align="middle"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5036"></a>6.8.&nbsp;Conversational components and JSF component bindings</h2></div></div><div></div></div><p>
            Conversational components have one minor limitation: they cannot be used to hold bindings 
            to JSF components. (We generally prefer not to use this feature of JSF unless absolutely
            necessary, since it creates a hard dependency from application logic to the view.) On a 
            postback request, component bindings are updated during the Restore View phase, 
            before the Seam conversation context has been restored.
        </p><p>
            To work around this use an event scoped component to store the component bindings and inject 
            it into the conversation scoped component that requires it.
        </p><pre class="programlisting">@Name("grid")
@Scope(ScopeType.EVENT)
public class Grid
{
    private HtmlPanelGrid htmlPanelGrid;

    // getters and setters
    ...
}</pre><pre class="programlisting">@Name("gridEditor")
@Scope(ScopeType.CONVERSATION)
public class GridEditor
{
    @In(required=false)
    private Grid grid;
    
    ...
}</pre><p>
          Alternatively, you can access the JSF component tree through the implicit <tt class="literal">uiComponent</tt>
          handle. The following example accesses <tt class="literal">getRowIndex()</tt>of the
          <tt class="literal">UIData</tt> component which backs the data table during iteration, it prints
          the current row number:
       </p><pre class="programlisting">
&lt;h:dataTable id="lineItemTable" var="lineItem" value="#{orderHome.lineItems}"&gt;
   &lt;h:column&gt;
      Row: #{uiComponent['lineItemTable'].rowIndex}
   &lt;/h:column&gt;
   ...
&lt;/h:dataTable&gt;</pre><p>
          JSF UI components are available with their client identifier in this map.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5062"></a>6.9.&nbsp;Concurrent calls to conversational components</h2></div></div><div></div></div><p>
        A general discussion of concurrent calls to Seam components can be 
        found in <a href="#concurrency" title="3.1.10.&nbsp;Concurrency model">Section&nbsp;3.1.10, &#8220;Concurrency model&#8221;</a>. Here we will discuss 
        the most common situation in which you will encounter concurrency 
        &#8212; accessing conversational components from AJAX requests.
        We're going to discuss the options that a Ajax client library should
        provide to control events originating at the client &#8212; and we'll
        look at the options RichFaces gives you.
      </p><p>
        Conversational components don't allow real concurrent access therefore
        Seam queues each request to process them serially.  This allows each
        request to be executed in a deterministic fashion. However, a simple
        queue isn't that great &#8212; firstly, if a method is, for some
        reason, taking a very long time to complete, running it over and over
        again whenever the client generates a request is bad idea (potential
        for Denial of Service attacks), and, secondly, AJAX is often to used
        to provide a quick status update to the user, so continuing to run the
        action after a long time isn't useful. 
      </p><p>
        Therefore Seam queues the action event for a period of time (the 
        concurrent request timeout); if it can't process the event in time, it 
        creates a temporary conversation and prints out a message to the user to
        let them know what's going on.  It's therefore very important not to
        flood the server with AJAX events!
      </p><p>
        We can set a sensible default for the concurrent request timeout (in 
        ms) in components.xml:
      </p><pre class="programlisting">&lt;core:manager concurrent-request-timeout="500" /&gt;</pre><p>
      So far we've discussed "synchronous" AJAX requests - the client tells the
      server that an event has occur, and then rerenders part of the page based
      on the result.  This approach is great when the AJAX request is
      lightweight (the methods called are simple e.g. calculating the sum of a
      column of numbers).  But what if we need to do a complex computation? 
    </p><p>
      For heavy computation we should use a truly asynchronous (poll based) 
      approach &#8212; the client sends an AJAX request to the server, which
      causes action to be executed asynchronously on the server (so the the
      response to the client is immediate); the client then polls the server 
      for updates.  This is useful when you have a long-running action for
      which it is important that every action executes (you don't want some to
      be dropped as duplicates, or to timeout).
    </p><p>
      <span class="emphasis"><em>How should we design our conversational AJAX application?</em></span>
    </p><p>
      Well first, you need to decide whether you want to use the simpler 
      "synchronous" request or whether you want to add using a poll-style
      approach.
    </p><p>
      If you go for a "synchronous" approach, then you need to make an
      estimate of how long your AJAX request will take to complete - is it much
      shorter than the concurrent request timeout? If not, you probably want to
      alter the concurrent request timeout for this method (as discussed 
      above). Next you probably want a queue on the client side to prevent 
      flooding the server with requests.  If the event occurs often (e.g. a 
      keypress, onblur of input fields) and immediate update of the client is
      not a priority you should set a request delay on the client side. When
      working out your request delay, factor in that the event may also be
      queued on the server side.
    </p><p>
      Finally, the client library may provide an option to abort unfinished
      duplicate requests in favor of the most recent.  You need to be careful
      with this option as it can lead to flooding of the server with requests
      if the server is not able to abort the unfinished request.
    </p><p>
      Using a poll-style design requires less fine-tuning.  You just mark your
      action method <tt class="literal">@Asynchronous</tt> and decide on a polling
      interval:
    </p><pre class="programlisting">int total;

// This method is called when an event occurs on the client
// It takes a really long time to execute
@Asynchronous      
public void calculateTotal() {
   total = someReallyComplicatedCalculation();
}

// This method is called as the result of the poll
// It's very quick to execute
public int getTotal() {
   return total;
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5101"></a>6.9.1.&nbsp;RichFaces Ajax</h3></div></div><div></div></div><p>
        RichFaces Ajax is the AJAX library most commonly used with Seam, and
        provides all the controls discussed above:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">eventsQueue</tt> &#8212; provide a queue in which 
            events are placed.  All events are queued and requests are sent to
            the server serially.  This is useful if the request can to the
            server can take some time to execute (e.g. heavy computation,
            retrieving information from a slow source) as the server isn't
            flooded.
          </p></li><li><p>
            <tt class="literal">ignoreDupResponses</tt> &#8212; ignore the response 
            produced by the request if a more recent 'similar' request is
            already in the queue. ignoreDupResponses="true" does <span class="emphasis"><em>not 
            cancel</em></span> the the processing of the request on the server
            side &#8212; just prevents unnecessary updates on the client side.
          </p><p>
            This option should be used with care with Seam's conversations as
            it allows multiple concurrent requests to be made.
          </p></li><li><p>
            <tt class="literal">requestDelay</tt> &#8212; defines the time (in ms.)
            that the request will be remain on the queue. If the request has
            not been processed by after this time the request will be sent 
            (regardless of whether a response has been received) or discarded
            (if there is a more recent similar event on the queue).
          </p><p>
            This option should be used with care with Seam's conversations as
            it allows multiple concurrent requests to be made.  You need to be
            sure that the delay you set (in combination with the concurrent
            request timeout) is longer than the action will take to execute.
          </p></li><li><p>
            <tt class="literal">&lt;a:poll reRender="total" interval="1000" /&gt;</tt> &#8212;
            Polls the server, and rerenders an area as needed
          </p></li></ul></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jbpm"></a>Chapter&nbsp;7.&nbsp;Pageflows and business processes</h2></div></div><div></div></div><p>
        JBoss jBPM is a business process management engine for any Java SE or EE
        environment. jBPM lets you represent a business process or user 
        interaction as a graph of nodes representing wait states, decisions,
        tasks, web pages, etc. The graph is defined using a simple, very readable, 
        XML dialect called jPDL, and may be edited and visualised graphically using
        an eclipse plugin. jPDL is an extensible language, and is suitable for 
        a range of problems, from defining web application page flow, to traditional
        workflow management, all the way up to orchestration of services in a SOA
        environment.
    </p><p>
        Seam applications use jBPM for two different problems:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Defining the pageflow involved in complex user interactions. A jPDL
            process definition defines the page flow for a single conversation.
            A Seam conversation is considered to be a relatively short-running
            interaction with a single user.
        </p></li><li><p>
            Defining the overarching business process. The business process may span
            multiple conversations with multiple users. Its state is persistent in
            the jBPM database, so it is considered long-running. Coordination of
            the activities of multiple users is a much more complex problem than
            scripting an interaction with a single user, so jBPM offers sophisticated
            facilities for task management and dealing with multiple concurrent paths 
            of execution.
        </p></li></ul></div><p>
        Don't get these two things confused ! They operate at very different levels
        or granularity. <span class="emphasis"><em>Pageflow</em></span>, <span class="emphasis"><em>conversation</em></span>
        and <span class="emphasis"><em>task</em></span> all refer to a single
        interaction with a single user. A business process spans many tasks.
        Futhermore, the two applications of jBPM are totally orthogonal. You can
        use them together or independently or not at all.
    </p><p>
        You don't have to know jDPL to use Seam. If you're perfectly happy defining
        pageflow using JSF or Seam navigation rules, and if your application is more 
        data-driven that process-driven, you probably don't need jBPM. But we're
        finding that thinking of user interaction in terms of a well-defined graphical 
        representation is helping us build more robust applications.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5165"></a>7.1.&nbsp;Pageflow in Seam</h2></div></div><div></div></div><p>
            There are two ways to define pageflow in Seam:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
	            Using JSF or Seam navigation rules - the <span class="emphasis"><em>stateless navigation 
	            model</em></span>
	        </p></li><li><p>
	            Using jPDL - the <span class="emphasis"><em>stateful navigation model</em></span>
	        </p></li></ul></div><p>
            Very simple applications will only need the stateless navigation 
            model. Very complex applications will use both models in different 
            places. Each model has its strengths and weaknesses!
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5185"></a>7.1.1.&nbsp;The two navigation models</h3></div></div><div></div></div><p>
            The stateless model defines a mapping from a set of named, logical
            outcomes of an event directly to the resulting page of the view.
            The navigation rules are entirely oblivious to any state held by
            the application other than what page was the source of the event.
            This means that your action listener methods must sometimes make 
            decisions about the page flow, since only they have access to the 
            current state of the application. 
        </p><p>
            Here is an example page flow definition using JSF navigation 
            rules:
        </p><pre class="programlisting">&lt;navigation-rule&gt;
    &lt;from-view-id&gt;/numberGuess.jsp&lt;/from-view-id&gt;
        
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;guess&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/numberGuess.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;

    &lt;navigation-case&gt;
        &lt;from-outcome&gt;win&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/win.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;
        
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;lose&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/lose.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;

&lt;/navigation-rule&gt;</pre><p>
            Here is the same example page flow definition using Seam navigation 
            rules:
        </p><pre class="programlisting">&lt;page view-id="/numberGuess.jsp"&gt;
        
    &lt;navigation&gt;
        &lt;rule if-outcome="guess"&gt;
            &lt;redirect view-id="/numberGuess.jsp"/&gt;
        &lt;/rule&gt;
        &lt;rule if-outcome="win"&gt;
            &lt;redirect view-id="/win.jsp"/&gt;
        &lt;/rule&gt;
        &lt;rule if-outcome="lose"&gt;
            &lt;redirect view-id="/lose.jsp"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;

&lt;/page&gt;</pre><p>
            If you find navigation rules overly verbose, you can return view ids
            directly from your action listener methods:
        </p><pre class="programlisting">public String guess() {
    if (guess==randomNumber) return "/win.jsp";
    if (++guessCount==maxGuesses) return "/lose.jsp";
    return null;
}</pre><p>
            Note that this results in a redirect. You can even specify parameters 
            to be used in the redirect:
        </p><pre class="programlisting">public String search() {
    return "/searchResults.jsp?searchPattern=#{searchAction.searchPattern}";
}</pre><p>
            The stateful model defines a set of transitions between a set of
            named, logical application states. In this model, it is possible
            to express the flow of any user interaction entirely in the jPDL
            pageflow definition, and write action listener methods that are
            completely unaware of the flow of the interaction.
        </p><p>
            Here is an example page flow definition using jPDL:
        </p><pre class="programlisting">&lt;pageflow-definition name="numberGuess"&gt;
    
   &lt;start-page name="displayGuess" view-id="/numberGuess.jsp"&gt;
      &lt;redirect/&gt;
      &lt;transition name="guess" to="evaluateGuess"&gt;
      	&lt;action expression="#{numberGuess.guess}" /&gt;
      &lt;/transition&gt;
   &lt;/start-page&gt;
   
   &lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;
      &lt;transition name="true" to="win"/&gt;
      &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
   &lt;/decision&gt;
   
   &lt;decision name="evaluateRemainingGuesses" expression="#{numberGuess.lastGuess}"&gt;
      &lt;transition name="true" to="lose"/&gt;
      &lt;transition name="false" to="displayGuess"/&gt;
   &lt;/decision&gt;
   
   &lt;page name="win" view-id="/win.jsp"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation /&gt;
   &lt;/page&gt;
   
   &lt;page name="lose" view-id="/lose.jsp"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation /&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;</pre><div class="mediaobject" align="center"><img src="../shared/images/plugin-jbpm-numguess.png" align="middle"></div><p>
            There are two things we notice immediately here:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
	            The JSF/Seam navigation rules are <span class="emphasis"><em>much</em></span> simpler.
	            (However, this obscures the fact that the underlying Java code
	            is more complex.)
	        </p></li><li><p>
	            The jPDL makes the user interaction immediately understandable,
	            without us needing to even look at the JSP or Java code.
	        </p></li></ul></div><p>
	        In addition, the stateful model is more <span class="emphasis"><em>constrained</em></span>.
	        For each logical state (each step in the page flow), there are a 
	        constrained set of possible transitions to other states. The stateless
	        model is an <span class="emphasis"><em>ad hoc</em></span> model which is suitable to 
	        relatively unconstrained, freeform navigation where the user decides
	        where he/she wants to go next, not the application.
	    </p><p>
	        The stateful/stateless navigation distinction is quite similar to
	        the traditional view of modal/modeless interaction. Now, Seam 
	        applications are not usually modal in the simple sense of the 
	        word - indeed, avoiding application modal behavior is one of the
	        main reasons for having conversations! However, Seam applications
	        can be, and often are, modal at the level of a particular 
	        conversation. It is well-known that modal behavior is something
	        to avoid as much as possible; it is very difficult to predict the
	        order in which your users are going to want to do things! However,
	        there is no doubt that the stateful model has its place.
	    </p><p>
	        The biggest contrast between the two models is the back-button
	        behavior.
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5241"></a>7.1.2.&nbsp;Seam and the back button</h3></div></div><div></div></div><p>
	        When JSF or Seam navigation rules are used, Seam lets the user freely 
	        navigate via the back, forward and refresh buttons. It is the
	        responsibility of the application to ensure that conversational
	        state remains internally consistent when this occurs. Experience
	        with the combination of web application frameworks like Struts 
	        or WebWork - that do not support a conversational model - and 
	        stateless component models like EJB stateless session beans 
	        or the Spring framework has taught many developers that this is
	        close to impossible to do! However, our experience is that in 
	        the context of Seam, where there is a well-defined conversational
	        model, backed by stateful session beans, it is actually quite 
	        straightforward. Usually it is as simple as combining the use 
	        of <tt class="literal">no-conversation-view-id</tt> with null 
	        checks at the beginning of action listener methods. We consider
	        support for freeform navigation to be almost always desirable.
	    </p><p>
	        In this case, the <tt class="literal">no-conversation-view-id</tt> 
	        declaration goes in <tt class="literal">pages.xml</tt>. It tells
	        Seam to redirect to a different page if a request originates
	        from a page rendered during a conversation, and that conversation
	        no longer exists:
	    </p><pre class="programlisting">&lt;page view-id="/checkout.xhtml" 
        no-conversation-view-id="/main.xhtml"/&gt;</pre><p>
	        On the other hand, in the stateful model, backbuttoning is 
	        interpreted as an undefined transition back to a previous state.
	        Since the stateful model enforces a defined set of transitions
	        from the current state, back buttoning is by default disallowed 
	        in the stateful model! Seam transparently detects the use of the
	        back button, and blocks any attempt to perform an action from
	        a previous, "stale" page, and simply redirects the user to 
	        the "current" page (and displays a faces message). Whether you 
	        consider this a feature or a limitation of the stateful model 
	        depends upon your point of view: as an application developer, 
	        it is a feature; as a user, it might be frustrating! You can
	        enable backbutton navigation from a particular page node by
	        setting <tt class="literal">back="enabled"</tt>.
	    </p><pre class="programlisting">&lt;page name="checkout" 
        view-id="/checkout.xhtml" 
        back="enabled"&gt;
    &lt;redirect/&gt;
    &lt;transition to="checkout"/&gt;
    &lt;transition name="complete" to="complete"/&gt;
&lt;/page&gt;</pre><p>
            This allows backbuttoning <span class="emphasis"><em>from</em></span> the
            <tt class="literal">checkout</tt> state to <span class="emphasis"><em>any previous
            state!</em></span>
        </p><p>
            Of course, we still need to define what happens if a request 
            originates from a page rendered during a pageflow, and the
            conversation with the pageflow no longer exists. In this case,
            the <tt class="literal">no-conversation-view-id</tt> declaration
            goes into the pageflow definition:
        </p><pre class="programlisting">&lt;page name="checkout" 
        view-id="/checkout.xhtml" 
        back="enabled" 
        no-conversation-view-id="/main.xhtml"&gt;
    &lt;redirect/&gt;
    &lt;transition to="checkout"/&gt;
    &lt;transition name="complete" to="complete"/&gt;
&lt;/page&gt;</pre><p>
	        In practice, both navigation models have their place, and you'll 
	        quickly learn to recognize when to prefer one model over the other.
	        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5286"></a>7.2.&nbsp;Using jPDL pageflows</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5289"></a>7.2.1.&nbsp;Installing pageflows</h3></div></div><div></div></div><p>
            We need to install the Seam jBPM-related components, and tell them
            where to find our pageflow definition. We can specify this
            Seam configuration in <tt class="literal">components.xml</tt>.
        </p><pre class="programlisting">&lt;bpm:jbpm&gt;
    &lt;bpm:pageflow-definitions&gt;
        &lt;value&gt;pageflow.jpdl.xml&lt;/value&gt;
    &lt;/bpm:pageflow-definitions&gt;
&lt;/bpm:jbpm&gt;</pre><p>
            The first line installs jBPM, the second points to a jPDL-based
            pageflow definition.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5301"></a>7.2.2.&nbsp;Starting pageflows</h3></div></div><div></div></div><p>
            We "start" a jPDL-based pageflow by specifying the name of the
            process definition using a <tt class="literal">@Begin</tt>,
            <tt class="literal">@BeginTask</tt> or <tt class="literal">@StartTask</tt> 
            annotation:
        </p><pre class="programlisting">@Begin(pageflow="numberguess")
public void begin() { ... }</pre><p>Alternatively we can start a pageflow using pages.xml:</p><pre class="programlisting">&lt;page&gt;
        &lt;begin-conversation pageflow="numberguess"/&gt;
    &lt;/page&gt;</pre><p>
            If we are beginning the pageflow during the <tt class="literal">RENDER_RESPONSE</tt>
            phase&#8212;during a <tt class="literal">@Factory</tt> or <tt class="literal">@Create</tt>
            method, for example&#8212;we consider ourselves to be already at the page being 
            rendered, and use  a <tt class="literal">&lt;start-page&gt;</tt> node as the first node 
            in the pageflow, as in the example above.
        </p><p>
            But if the pageflow is begun as the result of an action listener invocation,
            the outcome of the action listener determines which is the first page to be
            rendered. In this case, we use a <tt class="literal">&lt;start-state&gt;</tt> as
            the first node in the pageflow, and declare a transition for each possible
            outcome:
        </p><pre class="programlisting">&lt;pageflow-definition name="viewEditDocument"&gt;

    &lt;start-state name="start"&gt;
        &lt;transition name="documentFound" to="displayDocument"/&gt;
        &lt;transition name="documentNotFound" to="notFound"/&gt;
    &lt;/start-state&gt;
    
    &lt;page name="displayDocument" view-id="/document.jsp"&gt;
        &lt;transition name="edit" to="editDocument"/&gt;
        &lt;transition name="done" to="main"/&gt;
    &lt;/page&gt;
    
    ...
    
    &lt;page name="notFound" view-id="/404.jsp"&gt;
        &lt;end-conversation/&gt;
    &lt;/page&gt;
    
&lt;/pageflow-definition&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5342"></a>7.2.3.&nbsp;Page nodes and transitions</h3></div></div><div></div></div><p>
            Each <tt class="literal">&lt;page&gt;</tt> node represents a state where
            the system is waiting for user input:
        </p><pre class="programlisting">&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;redirect/&gt;
    &lt;transition name="guess" to="evaluateGuess"&gt;
        &lt;action expression="#{numberGuess.guess}" /&gt;
    &lt;/transition&gt;
&lt;/page&gt;</pre><p>
            The <tt class="literal">view-id</tt> is the JSF view id. The <tt class="literal">&lt;redirect/&gt;</tt>
            element has the same effect as <tt class="literal">&lt;redirect/&gt;</tt> in a 
            JSF navigation rule: namely, a post-then-redirect behavior, to overcome problems
            with the browser's refresh button. (Note that Seam propagates conversation contexts
            over these browser redirects. So there is no need for a Ruby on Rails style "flash"
            construct in Seam!)
        </p><p>
            The transition name is the name of a JSF outcome triggered by clicking
            a command button or command link in <tt class="literal">numberGuess.jsp</tt>. 
        </p><pre class="programlisting">&lt;h:commandButton type="submit" value="Guess" action="guess"/&gt;</pre><p>
            When the transition is triggered by clicking this button, jBPM will activate the
            transition action by calling the <tt class="literal">guess()</tt> method of the
            <tt class="literal">numberGuess</tt> component. Notice that the syntax used for
            specifying actions in the jPDL is just a familiar JSF EL expression, and that 
            the transition action handler is just a method of a Seam component in the
            current Seam contexts. So we have exactly the same event model for jBPM events 
            that we already have for JSF events! (The <span class="emphasis"><em>One Kind of Stuff</em></span> 
            principle.)
        </p><p>
            In the case of a null outcome (for example, a command button with no 
            <tt class="literal">action</tt> defined), Seam will signal the transition with no
            name if one exists, or else simply redisplay the page if all transitions
            have names. So we could slightly simplify our example pageflow and this button:
        </p><pre class="programlisting">&lt;h:commandButton type="submit" value="Guess"/&gt;</pre><p>
            Would fire the following un-named transition:
        </p><pre class="programlisting">&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;redirect/&gt;
    &lt;transition to="evaluateGuess"&gt;
        &lt;action expression="#{numberGuess.guess}" /&gt;
    &lt;/transition&gt;
&lt;/page&gt;</pre><p>
            It is even possible to have the button call an action method, in which case the
            action outcome will determine the transition to be taken:
        </p><pre class="programlisting">&lt;h:commandButton type="submit" value="Guess" action="#{numberGuess.guess}"/&gt;</pre><pre class="programlisting">&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;transition name="correctGuess" to="win"/&gt;
    &lt;transition name="incorrectGuess" to="evaluateGuess"/&gt;
&lt;/page&gt;</pre><p>
            However, this is considered an inferior style, since it moves responsibility for
            controlling the flow out of the pageflow definition and back into the other
            components. It is much better to centralize this concern in the pageflow itself.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5400"></a>7.2.4.&nbsp;Controlling the flow</h3></div></div><div></div></div><p>
            Usually, we don't need the more powerful features of jPDL when defining pageflows. 
            We do need the <tt class="literal">&lt;decision&gt;</tt> node, however:
        </p><pre class="programlisting">&lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;
    &lt;transition name="true" to="win"/&gt;
    &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
&lt;/decision&gt;</pre><p>
            A decision is made by evaluating a JSF EL expression in the Seam contexts.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5412"></a>7.2.5.&nbsp;Ending the flow</h3></div></div><div></div></div><p>
            We end the conversation using <tt class="literal">&lt;end-conversation&gt;</tt>
            or <tt class="literal">@End</tt>. (In fact, for readability, use of 
            <span class="emphasis"><em>both</em></span> is encouraged.)
        </p><pre class="programlisting">&lt;page name="win" view-id="/win.jsp"&gt;
    &lt;redirect/&gt;
    &lt;end-conversation/&gt;
&lt;/page&gt;</pre><p>
            Optionally, we can end a task, specify a jBPM <tt class="literal">transition</tt> 
            name. In this case, Seam will signal the end of the current task in the 
            overarching business process.
        </p><pre class="programlisting">&lt;page name="win" view-id="/win.jsp"&gt;
    &lt;redirect/&gt;
    &lt;end-task transition="success"/&gt;
&lt;/page&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5435"></a>7.2.6.&nbsp;Pageflow composition</h3></div></div><div></div></div><p>
                It is possible to compose pageflows and have one pageflow pause 
                pause while another pageflow executes. The <tt class="literal">&lt;process-state&gt;</tt>
                node pauses the outer pageflow, and begins execution of a named 
                pageflow:
            </p><pre class="programlisting">&lt;process-state name="cheat"&gt;
    &lt;sub-process name="cheat"/&gt;
    &lt;transition to="displayGuess"/&gt;
&lt;/process-state&gt;</pre><p>
                The inner flow begins executing at a <tt class="literal">&lt;start-state&gt;</tt>
                node. When it reaches an <tt class="literal">&lt;end-state&gt;</tt> node, 
                execution of the inner flow ends, and execution of the outer flow
                resumes with the transition defined by the <tt class="literal">&lt;process-state&gt;</tt>
                element.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5456"></a>7.3.&nbsp;Business process management in Seam</h2></div></div><div></div></div><p>
            A business process is a well-defined set of tasks that must
            be performed by users or software systems according to 
            well-defined rules about <span class="emphasis"><em>who</em></span> can perform 
            a task, and <span class="emphasis"><em>when</em></span> it should be performed.
            Seam's jBPM integration makes it easy to display lists of
            tasks to users and let them manage their tasks. Seam also
            lets the application store state associated with the business
            process in the <tt class="literal">BUSINESS_PROCESS</tt> context,
            and have that state made persistent via jBPM variables.
        </p><p>
            A simple business process definition looks much the same as a 
            page flow definition (<span class="emphasis"><em>One Kind of Stuff</em></span>), 
            except that instead of <tt class="literal">&lt;page&gt;</tt> nodes,
            we have <tt class="literal">&lt;task-node&gt;</tt> nodes. In a 
            long-running business process, the wait states are where the
            system is waiting for some user to log in and perform a task.
        </p><pre class="programlisting">&lt;process-definition name="todo"&gt;
   
   &lt;start-state name="start"&gt;
      &lt;transition to="todo"/&gt;
   &lt;/start-state&gt;
   
   &lt;task-node name="todo"&gt;
      &lt;task name="todo" description="#{todoList.description}"&gt;
         &lt;assignment actor-id="#{actor.id}"/&gt;
      &lt;/task&gt;
      &lt;transition to="done"/&gt;
   &lt;/task-node&gt;
   
   &lt;end-state name="done"/&gt;
   
&lt;/process-definition&gt;</pre><div class="mediaobject" align="center"><img src="../shared/images/plugin-jbpm-todo.png" align="middle"></div><p>
            It is perfectly possible that we might have both jPDL business 
            process definitions and jPDL pageflow definitions in the
            same project. If so, the relationship between the two is that
            a single <tt class="literal">&lt;task&gt;</tt> in a business process
            corresponds to a whole pageflow 
            <tt class="literal">&lt;pageflow-definition&gt;</tt>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5496"></a>7.4.&nbsp;Using jPDL business process definitions</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5499"></a>7.4.1.&nbsp;Installing process definitions</h3></div></div><div></div></div><p>
            We need to install jBPM, and tell it where to find the
            business process definitions:
        </p><pre class="programlisting">&lt;bpm:jbpm&gt;
    &lt;bpm:process-definitions&gt;
        &lt;value&gt;todo.jpdl.xml&lt;/value&gt;
    &lt;/bpm:process-definitions&gt;
&lt;/bpm:jbpm&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5506"></a>7.4.2.&nbsp;Initializing actor ids</h3></div></div><div></div></div><p>
            We always need to know what user is currently logged in.
            jBPM "knows" users by their <span class="emphasis"><em>actor id</em></span>
            and <span class="emphasis"><em>group actor ids</em></span>. We specify the
            current actor ids using the built in Seam component named
            <tt class="literal">actor</tt>:
        </p><pre class="programlisting">@In Actor actor;

public String login() {
    ...
    actor.setId( user.getUserName() );
    actor.getGroupActorIds().addAll( user.getGroupNames() );
    ...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5522"></a>7.4.3.&nbsp;Initiating a business process</h3></div></div><div></div></div><p>
            To initiate a business process instance, we use the 
            <tt class="literal">@CreateProcess</tt> annotation:
        </p><pre class="programlisting">@CreateProcess(definition="todo")
public void createTodo() { ... }</pre><p>Alternatively we can initiate a business process using pages.xml:</p><pre class="programlisting">&lt;page&gt;
    &lt;create-process definition="todo" /&gt;
&lt;/page&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5536"></a>7.4.4.&nbsp;Task assignment</h3></div></div><div></div></div><p>
            When a process reaches a task node, task instances are created. These must be 
            assigned to users or user groups. We can either hardcode our actor ids, or 
            delegate to a Seam component:
        </p><pre class="programlisting">&lt;task name="todo" description="#{todoList.description}"&gt;
    &lt;assignment actor-id="#{actor.id}"/&gt;
&lt;/task&gt;</pre><p>
            In this case, we have simply assigned the task to the current user. 
            We can also assign tasks to a pool:
        </p><pre class="programlisting">&lt;task name="todo" description="#{todoList.description}"&gt;
    &lt;assignment pooled-actors="employees"/&gt;
&lt;/task&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5547"></a>7.4.5.&nbsp;Task lists</h3></div></div><div></div></div><p>
            Several built-in Seam components make it easy to display task lists. 
            The <tt class="literal">pooledTaskInstanceList</tt> is a list of pooled tasks 
            that users may assign to themselves:
        </p><pre class="programlisting">&lt;h:dataTable value="#{pooledTaskInstanceList}" var="task"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Description&lt;/f:facet&gt;
        &lt;h:outputText value="#{task.description}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;s:link action="#{pooledTask.assignToCurrentActor}" value="Assign" taskInstance="#{task}"/&gt;
    &lt;/h:column&gt;            	
&lt;/h:dataTable&gt;</pre><p>
            Note that instead of <tt class="literal">&lt;s:link&gt;</tt> we could have used
            a plain JSF <tt class="literal">&lt;h:commandLink&gt;</tt>:
        </p><pre class="programlisting">&lt;h:commandLink action="#{pooledTask.assignToCurrentActor}"&gt; 
    &lt;f:param name="taskId" value="#{task.id}"/&gt;
&lt;/h:commandLink&gt;</pre><p>
            The <tt class="literal">pooledTask</tt> component is a built-in component that
            simply assigns the task to the current user.
        </p><p>
            The <tt class="literal">taskInstanceListForType</tt> component includes tasks of 
            a particular type that are assigned to the current user:
        </p><pre class="programlisting">&lt;h:dataTable value="#{taskInstanceListForType['todo']}" var="task"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Description&lt;/f:facet&gt;
        &lt;h:outputText value="#{task.description}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;s:link action="#{todoList.start}" value="Start Work" taskInstance="#{task}"/&gt;
    &lt;/h:column&gt;            	
&lt;/h:dataTable&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5579"></a>7.4.6.&nbsp;Performing a task</h3></div></div><div></div></div><p>
            To begin work on a task, we use either <tt class="literal">@StartTask</tt>
            or <tt class="literal">@BeginTask</tt> on the listener method:
        </p><pre class="programlisting">@StartTask
public String start() { ... }</pre><p>Alternatively we can begin work on a task using pages.xml:</p><pre class="programlisting">&lt;page&gt;
    &lt;start-task /&gt;
&lt;/page&gt;</pre><p>    
            These annotations begin a special kind of conversation that has 
            significance in terms of the overarching business process. Work done 
            by this conversation has access to state held in the business
            process context.
        </p><p>
            If we end the conversation using <tt class="literal">@EndTask</tt>, Seam
            will signal the completion of the task:
        </p><pre class="programlisting">@EndTask(transition="completed")
public String completed() { ... }</pre><p>Alternatively we can use pages.xml:</p><pre class="programlisting">&lt;page&gt;
    &lt;end-task transition="completed" /&gt;
&lt;/page&gt;</pre><p>
            You can also use EL to specify the transition in pages.xml.
        </p><p>
            At this point, jBPM takes over and continues executing the business process
            definition. (In more complex processes, several tasks might need to be
            completed before process execution can resume.)
        </p><p>
            Please refer to the jBPM documentation for a more thorough overview of 
            the sophisticated features that jBPM provides for managing complex
            business processes.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistence"></a>Chapter&nbsp;8.&nbsp;Seam and Object/Relational Mapping</h2></div></div><div></div></div><p>
        Seam provides extensive support for the two most popular persistence
        architectures for Java: Hibernate3, and the Java Persistence API
        introduced with EJB 3.0. Seam's unique state-management architecture
        allows the most sophisticated ORM integration of any web application 
        framework.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5620"></a>8.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
        Seam grew out of the frustration of the Hibernate team with the 
        statelessness typical of the previous generation of Java application 
        architectures. The state management architecture of Seam was originally
        designed to solve problems relating to persistence&#8212;in particular
        problems associated with <span class="emphasis"><em>optimistic transaction processing</em></span>.
        Scalable online applications always use optimistic transactions. An atomic 
        (database/JTA) level transaction should not span a user interaction unless
        the application is designed to support only a very small number of concurrent
        clients. But almost all interesting work involves first displaying data
        to a user, and then, slightly later, updating the same data. So Hibernate was
        designed to support the idea of a persistence context which spanned an
        optimistic transaction. 
    </p><p>
        Unfortunately, the so-called "stateless" architectures that preceded Seam and 
        EJB 3.0 had no construct for representing an optimistic transaction. So, instead,
        these architectures provided persistence contexts scoped to the atomic
        transaction. Of course, this resulted in many problems for users, and is the
        cause of the number one user complaint about Hibernate: the dreaded 
        <tt class="literal">LazyInitializationException</tt>. What we need is a construct
        for representing an optimistic transaction in the application tier.
    </p><p>
        EJB 3.0 recognizes this problem, and introduces the idea of a stateful
        component (a stateful session bean) with an <span class="emphasis"><em>extended persistence 
        context</em></span> scoped to the lifetime of the component. This is a
        partial solution to the problem (and is a useful construct in and of 
        itself) however there are two problems:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
                The lifecycle of the stateful session bean must be managed manually
                via code in the web tier (it turns out that this is a subtle problem
                and much more difficult in practice than it sounds).
            </p></li><li><p>
                Propagation of the persistence context between stateful components
                in the same optimistic transaction is possible, but tricky.
            </p></li></ul></div><p>
        Seam solves the first problem by providing conversations, and stateful
        session bean components scoped to the conversation. (Most conversations 
        actually represent optimistic transactions in the data layer.) This is
        sufficient for many simple applications (such as the Seam booking
        demo) where persistence context propagation is not needed. For more
        complex applications, with many loosly-interacting components in each
        conversation, propagation of the persistence context across components
        becomes an important issue. So Seam extends the persistence context
        management model of EJB 3.0, to provide conversation-scoped extended
        persistence contexts.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistence.seam-managed-transactions"></a>8.2.&nbsp;Seam managed transactions</h2></div></div><div></div></div><p>
            EJB session beans feature declarative transaction management. The EJB container is able
            to start a transaction transparently when the bean is invoked, and end it when the
            invocation ends. If we write a session bean method that acts as a JSF action listener, 
            we can do all the work associated with that action in one transaction, and be sure that
            it is committed or rolled back when we finish processing the action. This is a great feature, 
            and all that is needed by some Seam applications.
    	</p><p>
            However, there is a problem with this approach. A Seam application may not perform all data
            access for a request from a single method call to a session bean.
    	</p><div class="itemizedlist"><ul type="disc"><li><p>
                    The request might require processing by several loosly-coupled components, each
                    of which is called independently from the web layer. It is common to see several
                    or even many calls per request from the web layer to EJB components in Seam.
    			</p></li><li><p>
                    Rendering of the view might require lazy fetching of associations.
                </p></li></ul></div><p>
            The more transactions per request, the more likely we are to encounter atomicity
            and isolation problems when our application is processing many concurrent requests.
            Certainly, all write operations should occur in the same transaction!
    	</p><p>
            Hibernate users developed the <span class="emphasis"><em>"open session in view"</em></span> pattern to work 
            around this problem. In the Hibernate community, "open session in view" was historically 
            even more important because frameworks like Spring use transaction-scoped persistence contexts. 
            So rendering the view would cause <tt class="literal">LazyInitializationException</tt>s when 
            unfetched associations were accessed.
    	</p><p>
            This pattern is usually implemented as a single transaction which spans the entire request. 
            There are several problems with this implementation, the most serious being that we 
            can never be sure that a transaction is successful until we commit it&#8212;but by the 
            time the "open session in view" transaction is committed, the view is fully rendered, and 
            the rendered response may already have been flushed to the client. How can we notify the 
            user that their transaction was unsuccessful? 
    	</p><p>
            Seam solves both the transaction isolation problem and the association fetching problem, 
            while working around the problems with "open session in view". The solution comes in two 
            parts:
    	</p><div class="itemizedlist"><ul type="disc"><li><p>
                    use an extended persistence context that is scoped to the conversation, 
                    instead of to the transaction
    			</p></li><li><p>
                    use two transactions per request; the first spans the beginning of the update model
                    values phase until the end of the invoke application phase; the second spans the
                    render response phase
    			</p></li></ul></div><p>
            In the next section, we'll tell you how to set up a conversation-scope persistence
            context. But first we need to tell you how to enable Seam transaction management.
            Note that you can use conversation-scoped persistence contexts without Seam
            transaction management, and there are good reasons to use Seam transaction management
            even when you're not using Seam-managed persistence contexts. However, the two
            facilities were designed to work together, and work best when used together.
    	</p><p>
            Seam transaction management is useful even if you're using EJB 3.0 
            container-managed persistence contexts. But it is especially useful
            if you use Seam outside a Java EE 5 environment, or in any other
            case where you would use a Seam-managed persistence context.
    	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5686"></a>8.2.1.&nbsp;Disabling Seam-managed transactions</h3></div></div><div></div></div><p>
                Seam transaction management is enabled by default for all JSF requests.
                If you want to <span class="emphasis"><em>disable</em></span> this feature, you can do it
                in <tt class="literal">components.xml</tt>:
    		</p><pre class="programlisting">&lt;core:init transaction-management-enabled="false"/&gt;
        
&lt;transaction:no-transaction /&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5699"></a>8.2.2.&nbsp;Configuring a Seam transaction manager</h3></div></div><div></div></div><p>
    			Seam provides a transaction management abstraction for beginning, committing, rolling back, and
    			synchronizing with a transaction. By default Seam uses a JTA transaction component that integrates with
    			Container Managed and programmatic EJB transactions.
    		</p><p>
    			Out of the box Seam provides transaction components for the following additional transaction APIs:
    		</p><div class="itemizedlist"><ul type="disc"><li>
    				JPA RESOURCE_LOCAL transactions with the
    				<tt class="literal">javax.persistence.EntityTransaction</tt>
    				interface.
    			</li><li>
    				Hibernate managed transactions with the
    				<tt class="literal">org.hibernate.Transaction</tt>
    				interface.
    			</li><li>
    				Spring managed transactions with the
    				<tt class="literal">org.springframework.transaction.PlatformTransactionManager</tt>
    				interface.
    			</li><li>
                    Explicitly disable Seam managed transactions
                </li></ul></div><p>
    			Configure JPA RESOURCE_LOCAL transaction management by adding the following to your components.xml where
    			<tt class="literal">#{entityManager}</tt>
    			is the name of the
    			<tt class="literal">persistence:managed-persistence-context</tt>
    			component. (see
    			<a href="#persistence.seam-managed-persistence-contexts" title="8.3.&nbsp;Seam-managed persistence contexts">Seam-managed persistence contexts</a>
    			)
    		</p><pre class="programlisting">&lt;transaction:entity-transaction entity-manager="#{entityManager}"/&gt;</pre><p>
    			To configure Hibernate managed transactions declare the following in your components.xml where
    			<tt class="literal">#{hiberanteSession}</tt>
    			is the name of the project's
    			<tt class="literal">persistence:managed-hibernate-session</tt>
    			component. (see
    			<a href="#persistence.seam-managed-persistence-contexts" title="8.3.&nbsp;Seam-managed persistence contexts">Seam-managed persistence contexts</a>
    			)
    		</p><pre class="programlisting">&lt;transaction:hibernate-transaction session="#{hiberanteSession}"/&gt;</pre><p>
                To explicitly disable Seam managed transactions declare the following in your components.xml:
              </p><pre class="programlisting">&lt;transaction:no-transaction /&gt;</pre><p>
    			For configuring Spring managed transactions see
    			<a href="#spring-transactions" title="23.5.&nbsp;Using Spring PlatformTransactionManagement">using Spring PlatformTransactionManagement</a>
    			.
    		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5759"></a>8.2.3.&nbsp;Transaction synchronization</h3></div></div><div></div></div><p>
    			Transaction synchronization is the ability to provide callbacks for various transaction related events
    			such as
    			<tt class="literal">beforeCompletion()</tt>
    			and
    			<tt class="literal">afterCompletion()</tt>
    			. By default Seam uses it's own transaction synchronization component which requires explicit use of the
    			Seam transaction component when committing a transaction to ensure synchronization callbacks are
    			correctly executed. If in a Java EE 5 environment the
    			<tt class="literal">&lt;transaction:ejb-transaction/&gt;</tt>
    			component should be be declared in the components.xml to ensure that Seam synchronization callbacks are
    			correctly called if the container commits a transaction outside of Seam's knowledge.
    		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistence.seam-managed-persistence-contexts"></a>8.3.&nbsp;Seam-managed persistence contexts</h2></div></div><div></div></div><p>
            If you're using Seam outside of a Java EE 5 environment, you can't rely upon the
            container to manage the persistence context lifecycle for you. Even if you are
            in an EE 5 environment, you might have a complex application with many loosly
            coupled components that collaborate together in the scope of a single conversation,
            and in this case you might find that propagation of the persistence context between
            component is tricky and error-prone.
        </p><p>
            In either case, you'll need to use a <span class="emphasis"><em>managed persistence context</em></span> 
            (for JPA) or a <span class="emphasis"><em>managed session</em></span> (for Hibernate) in your components.
            A Seam-managed persistence context is just a built-in Seam component that manages an
            instance of <tt class="literal">EntityManager</tt> or <tt class="literal">Session</tt> in the
            conversation context. You can inject it with <tt class="literal">@In</tt>.
        </p><p>
            Seam-managed persistence contexts are extremely efficient in a clustered environment.
            Seam is able to perform an optimization that EJB 3.0 specification does not allow 
            containers to use for container-managed extended persistence contexts. Seam supports
            transparent failover of extended persisence contexts, without the need to replicate
            any persistence context state between nodes. (We hope to fix this oversight in the
            next revision of the EJB spec.)
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5797"></a>8.3.1.&nbsp;Using a Seam-managed persistence context with JPA</h3></div></div><div></div></div><p>
            Configuring a managed persistence context is easy. In <tt class="literal">components.xml</tt>, 
            we can write:
        </p><pre class="programlisting">&lt;persistence:managed-persistence-context name="bookingDatabase" 
                                  auto-create="true"
                   persistence-unit-jndi-name="java:/EntityManagerFactories/bookingData"/&gt;</pre><p>
            This configuration creates a conversation-scoped Seam component named 
            <tt class="literal">bookingDatabase</tt> that manages the lifecycle of <tt class="literal">EntityManager</tt> 
            instances for the persistence unit (<tt class="literal">EntityManagerFactory</tt> instance) 
            with JNDI name <tt class="literal">java:/EntityManagerFactories/bookingData</tt>.
        </p><p>
            Of course, you need to make sure that you have bound the <tt class="literal">EntityManagerFactory</tt> 
            into JNDI. In JBoss, you can do this by adding the following property setting to 
            <tt class="literal">persistence.xml</tt>.
        </p><pre class="programlisting">&lt;property name="jboss.entity.manager.factory.jndi.name" 
          value="java:/EntityManagerFactories/bookingData"/&gt;</pre><p>
            Now we can have our <tt class="literal">EntityManager</tt> injected using:
        </p><pre class="programlisting">@In EntityManager bookingDatabase;</pre><p>
            If you are using EJB3 and mark your class or method 
            <tt class="literal">@TransactionAttribute(REQUIRES_NEW)</tt> then the 
            transaction and persistence context shouldn't be propagated to method
            calls on this object.  However as the Seam-managed persistence
            context is propagated to any component within the conversation, it
            will be propagated to methods marked <tt class="literal">REQUIRES_NEW</tt>.
            Therefore, if you mark a method <tt class="literal">REQUIRES_NEW</tt> then
            you should access the entity manager using @PersistenceContext.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5849"></a>8.3.2.&nbsp;Using a Seam-managed Hibernate session</h3></div></div><div></div></div><p>
            Seam-managed Hibernate sessions are similar. In <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;persistence:hibernate-session-factory name="hibernateSessionFactory"/&gt;

&lt;persistence:managed-hibernate-session name="bookingDatabase" 
                                auto-create="true"
                  session-factory-jndi-name="java:/bookingSessionFactory"/&gt;</pre><p>
            Where <tt class="literal">java:/bookingSessionFactory</tt> is the name of the session factory 
            specified in <tt class="literal">hibernate.cfg.xml</tt>. 
        </p><pre class="programlisting">&lt;session-factory name="java:/bookingSessionFactory"&gt;
    &lt;property name="transaction.flush_before_completion"&gt;true&lt;/property&gt;
    &lt;property name="connection.release_mode"&gt;after_statement&lt;/property&gt;
    &lt;property name="transaction.manager_lookup_class"&gt;org.hibernate.transaction.JBossTransactionManagerLookup&lt;/property&gt;
    &lt;property name="transaction.factory_class"&gt;org.hibernate.transaction.JTATransactionFactory&lt;/property&gt;
    &lt;property name="connection.datasource"&gt;java:/bookingDatasource&lt;/property&gt;
    ...
&lt;/session-factory&gt;</pre><p>
            Note that Seam does not flush the session, so you should always enable
            <tt class="literal">hibernate.transaction.flush_before_completion</tt> to 
            ensure that the session is automatically flushed before the JTA transaction
            commits.
        </p><p>
            We can now have a managed Hibernate <tt class="literal">Session</tt> injected into our
            JavaBean components using the following code:
        </p><pre class="programlisting">@In Session bookingDatabase;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5881"></a>8.3.3.&nbsp;Seam-managed persistence contexts and atomic conversations</h3></div></div><div></div></div><p>
            Persistence contexts scoped to the conversation allows you to program optimistic 
            transactions that span multiple requests to the server without the need to use the 
            <tt class="literal">merge()</tt> operation , without the need to re-load 
            data at the beginning of each request, and without the need to wrestle with the 
            <tt class="literal">LazyInitializationException</tt> or 
            <tt class="literal">NonUniqueObjectException</tt>.
        </p><p>
            As with any optimistic transaction management, transaction isolation and consistency
            can be achieved via use of optimistic locking. Fortunately, both Hibernate and EJB 
            3.0 make it very easy to use optimistic locking, by providing the 
            <tt class="literal">@Version</tt> annotation.
        </p><p>
            By default, the persistence context is flushed (synchronized with the database)
            at the end of each transaction. This is sometimes the desired behavior. But very 
            often, we would prefer that all changes are held in memory and only written to
            the database when the conversation ends successfully. This allows for truly
            atomic conversations. As the result of a truly stupid and shortsighted decision
            by certain non-JBoss, non-Sun and non-Sybase members of the EJB 3.0 expert group, 
            there is currently no simple, usable and portable way to implement atomic 
            conversations using EJB 3.0 persistence. However, Hibernate provides this feature
            as a vendor extension to the <tt class="literal">FlushModeType</tt>s defined by the 
            specification, and it is our expectation that other vendors will soon provide
            a similar extension.
        </p><p>
            Seam lets you specify <tt class="literal">FlushModeType.MANUAL</tt> when beginning a
            conversation. Currently, this works only when Hibernate is the underlying 
            persistence provider, but we plan to support other equivalent vendor extensions.
        </p><pre class="programlisting">@In EntityManager em; //a Seam-managed persistence context

@Begin(flushMode=MANUAL)
public void beginClaimWizard() {
    claim = em.find(Claim.class, claimId);
}</pre><p>
            Now, the <tt class="literal">claim</tt> object remains managed by the persistence context
            for the rest ot the conversation. We can make changes to the claim:
        </p><pre class="programlisting">public void addPartyToClaim() {
    Party party = ....;
    claim.addParty(party);
}</pre><p>
            But these changes will not be flushed to the database until we explicitly force
            the flush to occur:
        </p><pre class="programlisting">@End
public void commitClaim() {
    em.flush();
}</pre><p>
            Of course, you could set the <tt class="literal">flushMode</tt> to <tt class="literal">MANUAL</tt>
            from pages.xml, for example in a navigation rule:
        </p><pre class="programlisting">&lt;begin-conversation flush-mode="MANUAL" /&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5933"></a>8.4.&nbsp;Using the JPA "delegate"</h2></div></div><div></div></div><p>
            The <tt class="literal">EntityManager</tt> interface lets you access a vendor-specific
            API via the <tt class="literal">getDelegate()</tt> method. Naturally, the most interesting
            vendor is Hibernate, and the most powerful delegate interface is
            <tt class="literal">org.hibernate.Session</tt>. You'd be nuts to use anything else. Trust
            me, I'm not biased at all.
        </p><p>
            But regardless of whether you're using Hibernate (genius!) or something else
            (masochist, or just not very bright), you'll almost certainly want to use the
            delegate in your Seam components from time to time. One approach would be the
            following:
        </p><pre class="programlisting">@In EntityManager entityManager;

@Create
public void init() {
    ( (Session) entityManager.getDelegate() ).enableFilter("currentVersions");
}</pre><p>
             But typecasts are unquestionably the ugliest syntax in the Java language, so most
             people avoid them whenever possible. Here's a different way to get at the 
             delegate. First, add the following line to <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;factory name="session" 
         scope="STATELESS" 
         auto-create="true" 
         value="#{entityManager.delegate}"/&gt;</pre><p>
            Now we can inject the session directly:
        </p><pre class="programlisting">@In Session session;

@Create
public void init() {
    session.enableFilter("currentVersions");
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5962"></a>8.5.&nbsp;Using EL in EJB-QL/HQL</h2></div></div><div></div></div><p>
            Seam proxies the <tt class="literal">EntityManager</tt> or <tt class="literal">Session</tt>
            object whenever you use a Seam-managed persistence context or inject a container
            managed persistence context using <tt class="literal">@PersistenceContext</tt>. This
            lets you use EL expressions in your query strings, safely and efficiently. For
            example, this:
        </p><pre class="programlisting">User user = em.createQuery("from User where username=#{user.username}")
         .getSingleResult();</pre><p>is equivalent to:</p><pre class="programlisting">User user = em.createQuery("from User where username=:username")
         .setParameter("username", user.getUsername())
         .getSingleResult();</pre><p>
            Of course, you should never, ever write it like this:
        </p><pre class="programlisting">User user = em.createQuery("from User where username=" + user.getUsername()) //BAD!
         .getSingleResult();</pre><p>
            (It is inefficient and vulnerable to SQL injection attacks.)
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5988"></a>8.6.&nbsp;Using Hibernate filters</h2></div></div><div></div></div><p>
            The coolest, and most unique, feature of Hibernate is <span class="emphasis"><em>filters</em></span>.
            Filters let you provide a restricted view of the data in the database. You can find 
            out more about filters in the Hibernate documentation. But we thought we'd mention
            an easy way to incorporate filters into a Seam application, one that works especially
            well with the Seam Application Framework.
        </p><p>
            Seam-managed persistence contexts may have a list of filters defined, which will be
            enabled whenever an <tt class="literal">EntityManager</tt> or Hibernate <tt class="literal">Session</tt>
            is first created. (Of course, they may only be used when Hibernate is the underlying
            persistence provider.)
        </p><pre class="programlisting">&lt;persistence:filter name="regionFilter"&gt;
    &lt;persistence:name&gt;region&lt;/persistence:name&gt;
    &lt;persistence:parameters&gt;
        &lt;key&gt;regionCode&lt;/key&gt;
        &lt;value&gt;#{region.code}&lt;/value&gt;
    &lt;/persistence:parameters&gt;
&lt;/persistence:filter&gt;

&lt;persistence:filter name="currentFilter"&gt;
    &lt;persistence:name&gt;current&lt;/persistence:name&gt;
    &lt;persistence:parameters&gt;
        &lt;key&gt;date&lt;/key&gt;
        &lt;value&gt;#{currentDate}&lt;/value&gt;
    &lt;/persistence:parameters&gt;
&lt;/persistence:filter&gt;

&lt;persistence:managed-persistence-context name="personDatabase"
    persistence-unit-jndi-name="java:/EntityManagerFactories/personDatabase"&gt;
    &lt;core:filters&gt;
        &lt;value&gt;#{regionFilter}&lt;/value&gt;
        &lt;value&gt;#{currentFilter}&lt;/value&gt;
    &lt;/core:filters&gt;
&lt;/persistence:managed-persistence-context&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>Chapter&nbsp;9.&nbsp;JSF form validation in Seam</h2></div></div><div></div></div><p>
        In plain JSF, validation is defined in the view:
    </p><pre class="programlisting">&lt;h:form&gt;
    &lt;h:messages/&gt;

    &lt;div&gt;
        Country:
        &lt;h:inputText value="#{location.country}" required="true"&gt;
            &lt;my:validateCountry/&gt;
        &lt;/h:inputText&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        Zip code:
        &lt;h:inputText value="#{location.zip}" required="true"&gt;
            &lt;my:validateZip/&gt;
        &lt;/h:inputText&gt;
    &lt;/div&gt;

    &lt;h:commandButton/&gt;
&lt;/h:form&gt;</pre><p>
        In practice, this approach usually violates DRY, since most
        "validation" actually enforces constraints that are part of
        the data model, and exist all the way down to the database
        schema definition. Seam provides support for model-based
        constraints defined using Hibernate Validator.
    </p><p>
        Let's start by defining our constraints, on our 
        <tt class="literal">Location</tt> class:
    </p><pre class="programlisting">public class Location {
    private String country;
    private String zip;
    
    @NotNull
    @Length(max=30)
    public String getCountry() { return country; }
    public void setCountry(String c) { country = c; }

    @NotNull
    @Length(max=6)
    @Pattern("^\d*$")
    public String getZip() { return zip; }
    public void setZip(String z) { zip = z; }
}</pre><p>
        Well, that's a decent first cut, but in practice it might be
        more elegant to use custom constraints instead of the ones
        built into Hibernate Validator:
    </p><pre class="programlisting">public class Location {
    private String country;
    private String zip;
    
    @NotNull
    @Country
    public String getCountry() { return country; }
    public void setCountry(String c) { country = c; }

    @NotNull
    @ZipCode
    public String getZip() { return zip; }
    public void setZip(String z) { zip = z; }
}</pre><p>
        Whichever route we take, we no longer need to specify the
        type of validation to be used in the JSF page. Instead, we
        can use <tt class="literal">&lt;s:validate&gt;</tt> to validate
        against the constraint defined on the model object.
    </p><pre class="programlisting">&lt;h:form&gt;
    &lt;h:messages/&gt;

    &lt;div&gt;
        Country:
        &lt;h:inputText value="#{location.country}" required="true"&gt;
            &lt;s:validate/&gt;
        &lt;/h:inputText&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        Zip code:
        &lt;h:inputText value="#{location.zip}" required="true"&gt;
            &lt;s:validate/&gt;
        &lt;/h:inputText&gt;
    &lt;/div&gt;
    
    &lt;h:commandButton/&gt;

&lt;/h:form&gt;</pre><p>
         <span class="emphasis"><em>Note:</em></span> specifying <tt class="literal">@NotNull</tt>
         on the model does <span class="emphasis"><em>not</em></span> eliminate the requirement
         for <tt class="literal">required="true"</tt> to appear on the control!
         This is due to a limitation of the JSF validation architecture.
     </p><p>
        This approach <span class="emphasis"><em>defines</em></span> constraints on the model, and 
        <span class="emphasis"><em>presents</em></span> constraint violations in the view&#8212;a
        significantly better design.
    </p><p>
         However, it is not much less verbose than what we started with, 
         so let's try <tt class="literal">&lt;s:validateAll&gt;</tt>:
     </p><pre class="programlisting">&lt;h:form&gt;
    
    &lt;h:messages/&gt;

    &lt;s:validateAll&gt;

        &lt;div&gt;
            Country:
            &lt;h:inputText value="#{location.country}" required="true"/&gt;
        &lt;/div&gt;

        &lt;div&gt;
            Zip code:
            &lt;h:inputText value="#{location.zip}" required="true"/&gt;
        &lt;/div&gt;

        &lt;h:commandButton/&gt;

    &lt;/s:validateAll&gt;

&lt;/h:form&gt;</pre><p>
         This tag simply adds an <tt class="literal">&lt;s:validate&gt;</tt>
         to every input in the form. For a large form, it can save a lot
         of typing!
     </p><p>
         Now we need to do something about displaying feedback to the 
         user when validation fails. Currently we are displaying all
         messages at the top of the form. What we would really like to
         do is display the message next to the field with the error
         (this is possible in plain JSF), highlight the field and 
         label (this is not possible) and, for good measure, display 
         some image next the the field (also not possible). We also
         want to display a little colored asterisk next to the label
         for each required form field.
         
     </p><p>
         That's quite a lot of functionality we need for each field
         of our form. We wouldn't want to have to specify higlighting
         and the layout of the image, message and input field for every
         field on the form. So, instead, we'll specify the common
         layout in a facelets template:
     </p><pre class="programlisting">&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:s="http://jboss.com/products/seam/taglib"&gt;
                 
    &lt;div&gt;
    
        &lt;s:label styleClass="#{invalid?'error':''}"&gt;
            &lt;ui:insert name="label"/&gt;
            &lt;s:span styleClass="required" rendered="#{required}"&gt;*&lt;/s:span&gt;
        &lt;/s:label&gt;
        
        &lt;span class="#{invalid?'error':''}"&gt;
            &lt;h:graphicImage src="img/error.gif" rendered="#{invalid}"/&gt;
            &lt;s:validateAll&gt;
                &lt;ui:insert/&gt;
            &lt;/s:validateAll&gt;
        &lt;/span&gt;
        
        &lt;s:message styleClass="error"/&gt;
        
    &lt;/div&gt;
    
&lt;/ui:composition&gt;</pre><p>
         We can include this template for each of our form fields using
         <tt class="literal">&lt;s:decorate&gt;</tt>.
     </p><pre class="programlisting">&lt;h:form&gt;

    &lt;h:messages globalOnly="true"/&gt;

    &lt;s:decorate template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Country:&lt;/ui:define&gt;
        &lt;h:inputText value="#{location.country}" required="true"/&gt;
    &lt;/s:decorate&gt;
    
    &lt;s:decorate template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Zip code:&lt;/ui:define&gt;
        &lt;h:inputText value="#{location.zip}" required="true"/&gt;
    &lt;/s:decorate&gt;

    &lt;h:commandButton/&gt;

&lt;/h:form&gt;</pre><p>
        Finally, we can use RichFaces Ajax to display validation messages as the user 
        is navigating around the form:
    </p><pre class="programlisting">&lt;h:form&gt;

    &lt;h:messages globalOnly="true"/&gt;

    &lt;s:decorate id="countryDecoration" template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Country:&lt;/ui:define&gt;
        &lt;h:inputText value="#{location.country}" required="true"&gt;
            &lt;a:support event="onblur" reRender="countryDecoration" bypassUpdates="true"/&gt;
        &lt;/h:inputText&gt;
    &lt;/s:decorate&gt;
    
    &lt;s:decorate id="zipDecoration" template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Zip code:&lt;/ui:define&gt;
        &lt;h:inputText value="#{location.zip}" required="true"&gt;
            &lt;a:support event="onblur" reRender="zipDecoration" bypassUpdates="true"/&gt;
        &lt;/h:inputText&gt;
    &lt;/s:decorate&gt;

    &lt;h:commandButton/&gt;

&lt;/h:form&gt;</pre><p>
 		It's better style to define explicit ids for
        important controls on the page, especially if you want to do
        automated testing for the UI, using some toolkit like
        Selenium. If you don't provide explicit ids, JSF will generate
        them, but the generated values will change if you change
        anything on the page.
    </p><pre class="programlisting">&lt;h:form id="form"&gt;

    &lt;h:messages globalOnly="true"/&gt;

    &lt;s:decorate id="countryDecoration" template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Country:&lt;/ui:define&gt;
        &lt;h:inputText id="country" value="#{location.country}" required="true"&gt;
            &lt;a:support event="onblur" reRender="countryDecoration" bypassUpdates="true"/&gt;
        &lt;/h:inputText&gt;
    &lt;/s:decorate&gt;
    
    &lt;s:decorate id="zipDecoration" template="edit.xhtml"&gt;
        &lt;ui:define name="label"&gt;Zip code:&lt;/ui:define&gt;
        &lt;h:inputText id="zip" value="#{location.zip}" required="true"&gt;
            &lt;a:support event="onblur" reRender="zipDecoration" bypassUpdates="true"/&gt;
        &lt;/h:inputText&gt;
    &lt;/s:decorate&gt;

    &lt;h:commandButton/&gt;

&lt;/h:form&gt;</pre><p>
		And what if you want to specify a different message to be 
		displayed when validation fails?  You can use the Seam message
		bundle (and all it's goodies like el expressions inside the message,
		and per-view message bundles) with the Hibernate Validator:
	</p><pre class="programlisting">public class Location {
    private String name;
    private String zip;
    
    // Getters and setters for name

    @NotNull
    @Length(max=6)
    @ZipCode(message="#{messages['location.zipCode.invalid']}")
    public String getZip() { return zip; }
    public void setZip(String z) { zip = z; }
}</pre><pre class="programlisting">
location.zipCode.invalid = The zip code is not valid for #{location.name}
</pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="groovy"></a>Chapter&nbsp;10.&nbsp;Groovy integration</h2></div></div><div></div></div><p>One aspect of JBoss Seam is its RAD (Rapid Application Development) capability. While not synonymous with RAD,
        one interesting tool in this space is dynamic languages. Until recently, choosing a dynamic language was
        required choosing a completely different development platform (a development platform with a set of APIs and a
        runtime so great that you would no longer want to use you old legacy Java [sic] APIs anymore, which would be
        lucky because you would be forced to use those proprietary APIs anyway). Dynamic languages built on top of the
        Java Virtual Machine, and <a href="http://groovy.codehaus.org" target="_top">Groovy</a> in particular broke this
        approach in silos.</p><p>JBoss Seam now unites the dynamic language world with the Java EE world by seamlessly integrating both static
        and dynamic languages. JBoss Seam lets the application developer use the best tool for the task, without context
        switching. Writing dynamic Seam components is exactly like writing regular Seam components. You use the same
        annotations, the same APIs, the same everything.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6104"></a>10.1.&nbsp;Groovy introduction</h2></div></div><div></div></div><p>Groovy is an agile dynamic language based on the Java language but with additional features inspired by
            Python, Ruby and Smalltalk. The strengths of Groovy are twofold:</p><div class="itemizedlist"><ul type="disc"><li><p>Java syntax is supported in Groovy: Java code is Groovy code, making the learning curve very
                    smooth</p></li><li><p>Groovy objects are Java objects, and Groovy classes are Java classes: Groovy integrates smoothly
                    with existing Java libraries and frameworks.</p></li></ul></div><p>TODO: write a quick overview of the Groovy syntax add-on</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6118"></a>10.2.&nbsp;Writing Seam applications in Groovy</h2></div></div><div></div></div><p>There is not much to say about it. Since a Groovy object is a Java object, you can virtually write any
            Seam component, or any class for what it worth, in Groovy and deploy it. You can also mix Groovy classes and
            Java classes in the same application.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6123"></a>10.2.1.&nbsp;Writing Groovy components</h3></div></div><div></div></div><p>As you should have noticed by now, Seam uses annotations heavily. Be sure to use Groovy 1.1 Beta1 or
                above for annotation support. Here are some example of groovy code used in a Seam application.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6128"></a>10.2.1.1.&nbsp;Entity</h4></div></div><div></div></div><pre class="programlisting">    @Entity
    @Name("hotel")
    class Hotel implements Serializable
    {
        @Id @GeneratedValue
        Long id

        @Length(max=50) @NotNull
        String name

        @Length(max=100) @NotNull
        String address

        @Length(max=40) @NotNull
        String city

        @Length(min=2, max=10) @NotNull
        String state

        @Length(min=4, max=6) @NotNull
        String zip

        @Length(min=2, max=40) @NotNull
        String country

        @Column(precision=6, scale=2)
        BigDecimal price

        @Override
        String toString()
        {
            return "Hotel(${name},${address},${city},${zip})"
        }
    }</pre><p>Groovy natively support the notion of properties (getter/setter), so there is no need to
                    explicitly write verbose getters and setters: in the previous example, the hotel class can be
                    accessed from Java as <tt class="code">hotel.getCity()</tt>, the getters and setters being generated by the
                    Groovy compiler. This type of syntactic sugar makes the entity code very concise.</p><p>Some temporary gotchas: Groovy 1.1 Beta1 does not (yet) support generics. One negative effect of
                    this is that entity relationships have no built-in type information. It is necessary to use the
                    targetEntity attribute of the appropriate <tt class="literal">@*ToMany</tt> annotation instead of simply
                    using a generic type definition like <tt class="code">Collection&lt;Entity&gt;</tt>. For the same
                    reason, you won't be able to benefit from the very useful <a href="#framework" title="Chapter&nbsp;11.&nbsp;The Seam Application Framework">Chapter&nbsp;11, <i>The Seam Application Framework</i></a> yet. The good
                    news is that support for generics is targeted for Groovy 1.1 (Groovy 1.1 Beta2 at the time of
                    writing).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6148"></a>10.2.1.2.&nbsp;Seam component</h4></div></div><div></div></div><p>Writing Seam components in Groovy is in no way different than in Java: annotations are used to
                    mark the class as a Seam component.</p><pre class="programlisting">@Scope(ScopeType.SESSION)
@Name("bookingList")
class BookingListAction implements Serializable
{
    @In EntityManager em
    @In User user
    @DataModel List&lt;Booking&gt; bookings
    @DataModelSelection Booking booking
    @Logger Log log

    @Factory public void getBookings()
    {
        bookings = em.createQuery('''
                select b from Booking b
                where b.user.username = :username
                order by b.checkinDate''')
            .setParameter("username", user.username)
            .getResultList()
    }
    
    public void cancel()
    {
        log.info("Cancel booking: #{bookingList.booking.id} for #{user.username}")
        Booking cancelled = em.find(Booking.class, booking.id)
        if (cancelled != null) em.remove( cancelled )
        getBookings()
        FacesMessages.instance().add("Booking cancelled for confirmation number #{bookingList.booking.id}", new Object[0])
    }
}</pre><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6156"></a>10.2.2.&nbsp;seam-gen</h3></div></div><div></div></div><p>Seam gen has a transparent integration with Groovy. You can write Groovy code in seam-gen backed
                projects without any additional infrastructure requirement. When writing a Groovy entity, simply place
                your <tt class="filename">.groovy</tt> files in <tt class="filename">src/model</tt>. Unsurprisingly, when writing
                an action, simply place your <tt class="filename">.groovy</tt> files in
            <tt class="filename">src/action</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6173"></a>10.3.&nbsp;Deployment</h2></div></div><div></div></div><p>Deploying Groovy classes is very much like deploying Java classes (surprisingly, no need to write nor
            comply with a 3-letter composite specification to support a multi-language component framework).</p><p>Beyond standard deployments, JBoss Seam has the ability, at development time, to redeploy JavaBeans Seam
            component classes without having to restart the application, saving a lot of time in the development / test
            cycle. The same support is provided for GroovyBeans Seam components when the <tt class="filename">.groovy</tt>
            files are deployed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6183"></a>10.3.1.&nbsp;Deploying Groovy code</h3></div></div><div></div></div><p>A Groovy class <span class="emphasis"><em>is</em></span> a Java class, with a bytecode representation just like a Java
                class. To deploy, a Groovy entity, a Groovy Session bean or a Groovy Seam component, a compilation step
                is necessary. A common approach is to use the <tt class="literal">groovyc</tt> ant task. Once compiles, a
                Groovy class is in no way different than a Java class and the application server will treat them
                equally. Note that this allow a seamless mix of Groovy and Java code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6194"></a>10.3.2.&nbsp;Native .groovy file deployment at development time</h3></div></div><div></div></div><p>JBoss Seam natively supports the deployment of <tt class="literal">.groovy</tt> files (ie without
                compilation) in incremental hotdeployment mode (development only). This enables a very fast edit/test
                cycle. To set up .groovy deployments, follow the configuration at <a href="#gettingstarted-hotdeployment" title="2.7.&nbsp;Seam and incremental hot deployment">Section&nbsp;2.7, &#8220;Seam and incremental hot deployment&#8221;</a> and deploy your Groovy code (<tt class="filename">.groovy</tt>
                files) into the <tt class="filename">WEB-INF/dev</tt> directory. The GroovyBean components will be picked up
                incrementally with no need to restart the application (and obviously not the application server either).</p><p>Be aware that the native .groovy file deployment suffers the same limitations as the regular Seam
                hotdeployment:</p><div class="itemizedlist"><ul type="disc"><li><p>The components must be JavaBeans or GroovyBeans. They cannot be EJB3 bean</p></li><li><p>Entities cannot be hotdeployed</p></li><li><p>The hot-deployable components will not be visible to any classes deployed outside of
                            <tt class="literal">WEB-INF/dev</tt></p></li><li><p>Seam debug mode must be enabled</p></li></ul></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6228"></a>10.3.3.&nbsp;seam-gen</h3></div></div><div></div></div><p>Seam-gen transparently supports Groovy files deployment and compilation. This includes the native
                    <tt class="filename">.groovy</tt> file deployment in development mode (compilation-less). If you create a
                seam-gen project of type WAR, Java and Groovy classes in <tt class="filename">src/action</tt> will
                automatically be candidate for the incremental hot deployment. If you are in production mode, the Groovy
                files will simply be compiled before deployment.</p><p>You will find a live example of the Booking demo written completely in Groovy and supporting
                incremental hot deployment in <tt class="filename">examples/groovybooking</tt>.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="framework"></a>Chapter&nbsp;11.&nbsp;The Seam Application Framework</h2></div></div><div></div></div><p>
        Seam makes it really easy to create applications by writing
        plain Java classes with annotations, which don't need to extend
        any special interfaces or superclasses. But we can simplify
        some common programming tasks even further, by providing a set 
        of pre-built components which can be re-used either by
        configuration in <tt class="literal">components.xml</tt> (for very 
        simple cases) or extension.
    </p><p>
        The <span class="emphasis"><em>Seam Application Framework</em></span> can reduce
        the amount of code you need to write when doing basic database
        access in a web application, using either Hibernate or JPA.
    </p><p>
        We should emphasize that the framework is extremely simple, 
        just a handful of simple classes that are easy to understand
        and extend. The "magic" is in Seam itself&#8212;the same magic
        you use when creating any Seam application even without using 
        this framework.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6259"></a>11.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            The components provided by the Seam application framework
            may be used in one of two different approaches. The first
            way is to install and configure an instance of the component
            in <tt class="literal">components.xml</tt>, just like we have
            done with other kinds of built-in Seam components. For
            example, the following fragment from
            <tt class="literal">components.xml</tt> installs a component
            which can perform basic CRUD operations for a
            <tt class="literal">Person</tt> entity:
        </p><pre class="programlisting">&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" 
                       entity-manager="#{personDatabase}"&gt;
    &lt;framework:id&gt;#{param.personId}&lt;/framework:id&gt;
&lt;/framework:entity-home&gt;</pre><p>
            If that looks a bit too much like "programming in XML" for 
            your taste, you can use extension instead:
        </p><pre class="programlisting">@Stateful
@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; implements LocalPersonHome {
    @RequestParameter String personId;
    @In EntityManager personDatabase;
    
    public Object getId() { return personId; }
    public EntityManager getEntityManager() { return personDatabase; }
    
}</pre><p>
            The second approach has one huge advantage: you can easily add 
            extra functionality, and override the built-in functionality
            (the framework classes were carefully designed for extension
            and customization).
        </p><p>
            A second advantage is that your classes may be EJB stateful
            session beans, if you like. (They do not have to be, they 
            can be plain JavaBean components if you prefer.)  If you are using
            JBoss AS, you'll need 4.2.2.GA or later.
        </p><p>
            At this time, the Seam Application Framework provides just four
            built-in components: <tt class="literal">EntityHome</tt> and
            <tt class="literal">HibernateEntityHome</tt> for CRUD, along with
            <tt class="literal">EntityQuery</tt> and <tt class="literal">HibernateEntityQuery</tt>
            for queries.
        </p><p>
            The Home and Query components are written so that they can function
            with a scope of session, event or conversation. Which scope you
            use depends upon the state model you wish to use in your application.
        </p><p>
            The Seam Application Framework only works with Seam-managed
            persistence contexts. By default, the components will look
            for a persistence context named <tt class="literal">entityManager</tt>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6304"></a>11.2.&nbsp;Home objects</h2></div></div><div></div></div><p>
            A Home object provides persistence operations for a particular entity
            class. Suppose we have our trusty <tt class="literal">Person</tt> class:
        </p><pre class="programlisting">@Entity
public class Person {
    @Id private Long id;
    private String firstName;
    private String lastName;
    private Country nationality;
    
    //getters and setters...
}</pre><p>
            We can define a <tt class="literal">personHome</tt> component either via
            configuration:
        </p><pre class="programlisting">&lt;framework:entity-home name="personHome" entity-class="eg.Person" /&gt;</pre><p>
            Or via extension:
        </p><pre class="programlisting">@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {}</pre><p>
            A Home object provides the following operations: <tt class="literal">persist()</tt>,
            <tt class="literal">remove()</tt>, <tt class="literal">update()</tt> and 
            <tt class="literal">getInstance()</tt>. Before you can call the 
            <tt class="literal">remove()</tt>, or <tt class="literal">update()</tt> operations, you 
            must first set the identifier of the object you are interested in, using the 
            <tt class="literal">setId()</tt> method.
        </p><p>
            We can use a Home directly from a JSF page, for example:
        </p><pre class="programlisting">&lt;h1&gt;Create Person&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{personHome.instance.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{personHome.instance.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;</pre><p>
            Usually, it is much nicer to be able to refer to the <tt class="literal">Person</tt>
            merely as <tt class="literal">person</tt>, so let's make that possible by adding a
            line to <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" /&gt;</pre><p>
            (If we are using configuration.)
            Or by adding a <tt class="literal">@Factory</tt> method to <tt class="literal">PersonHome</tt>:
        </p><pre class="programlisting">@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
}</pre><p>
            (If we are using extension.) 
            This change simplifies our JSF page to the following:
        </p><pre class="programlisting">&lt;h1&gt;Create Person&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{person.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{person.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;</pre><p>
            Well, that lets us create new <tt class="literal">Person</tt> entries. Yes,
            that is all the code that is required! Now, if we want to be able to 
            display, update and delete pre-existing <tt class="literal">Person</tt> 
            entries in the database, we need to be able to pass the entry
            identifier to the <tt class="literal">PersonHome</tt>. Page parameters
            are a great way to do that:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/editPerson.jsp"&gt;
        &lt;param name="personId" value="#{personHome.id}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
            Now we can add the extra operations to our JSF page:
        </p><pre class="programlisting">&lt;h1&gt;
    &lt;h:outputText rendered="#{!personHome.managed}" value="Create Person"/&gt;
    &lt;h:outputText rendered="#{personHome.managed}" value="Edit Person"/&gt;
&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{person.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{person.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}" rendered="#{!personHome.managed}"/&gt;
        &lt;h:commandButton value="Update Person" action="#{personHome.update}" rendered="#{personHome.managed}"/&gt;
        &lt;h:commandButton value="Delete Person" action="#{personHome.remove}" rendered="#{personHome.managed}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;</pre><p>
            When we link to the page with no request parameters, the page will 
            be displayed as a "Create Person" page. When we provide a value for
            the <tt class="literal">personId</tt> request parameter, it will be an
            "Edit Person" page.
        </p><p>
            Suppose we need to create <tt class="literal">Person</tt> entries with their
            nationality initialized. We can do that easily, via configuration:
        </p><pre class="programlisting">&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" 
                       new-instance="#{newPerson}"/&gt;

&lt;component name="newPerson" 
           class="eg.Person"&gt;
    &lt;property name="nationality"&gt;#{country}&lt;/property&gt;
&lt;/component&gt;</pre><p>
             Or by extension:
         </p><pre class="programlisting">@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
}</pre><p>
            Of course, the <tt class="literal">Country</tt> could be an object managed by
            another Home object, for example, <tt class="literal">CountryHome</tt>.
        </p><p>
            To add more sophisticated operations (association management, etc), we can
            just add methods to <tt class="literal">PersonHome</tt>.
        </p><pre class="programlisting">@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
    public void migrate()
    {
        getInstance().setCountry(country);
        update();
    }
    
}</pre><p>
			The Home object raises an <tt class="literal">org.jboss.seam.afterTransactionSuccess</tt> 
			event when a transaction succeeds (a call to <tt class="literal">persist()</tt>, 
			<tt class="literal">update()</tt> or <tt class="literal">remove()</tt> succeeds).  By observing 
			this event we can refresh our queries when the underlying entities are changed.  If
			we only want to refresh certain queries when a particular entity is persited, 
			updated or removed we can observe the 
			<tt class="literal">org.jboss.seam.afterTransactionSuccess.&lt;name&gt;</tt> 
			event (where <tt class="literal">&lt;name&gt;</tt> is the name of the entity).
		</p><p>
            The Home object automatically displays faces messages when an operation is
            successful. To customize these messages we can, again, use configuration:
        </p><pre class="programlisting">&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome"
                       entity-class="eg.Person"
                       new-instance="#{newPerson}"&gt;
    &lt;framework:created-message&gt;New person #{person.firstName} #{person.lastName} created&lt;/framework:created-message&gt;
    &lt;framework:deleted-message&gt;Person #{person.firstName} #{person.lastName} deleted&lt;/framework:deleted-message&gt;
    &lt;framework:updated-message&gt;Person #{person.firstName} #{person.lastName} updated&lt;/framework:updated-message&gt;
&lt;/framework:entity-home&gt;

&lt;component name="newPerson" 
           class="eg.Person"&gt;
    &lt;property name="nationality"&gt;#{country}&lt;/property&gt;
&lt;/component&gt;</pre><p>
             Or extension:
         </p><pre class="programlisting">@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
    protected String getCreatedMessage() { return "New person #{person.firstName} #{person.lastName} created"; }
    protected String getUpdatedMessage() { return "Person #{person.firstName} #{person.lastName} updated"; }
    protected String getDeletedMessage() { return "Person #{person.firstName} #{person.lastName} deleted"; }
    
}</pre><p>
            But the best way to specify the messages is to put them in a resource
            bundle known to Seam (the bundle named <tt class="literal">messages</tt>,
            by default).
        </p><pre class="programlisting">Person_created=New person #{person.firstName} #{person.lastName} created
Person_deleted=Person #{person.firstName} #{person.lastName} deleted
Person_updated=Person #{person.firstName} #{person.lastName} updated</pre><p>
            This enables internationalization, and keeps your code and configuration clean of
            presentation concerns.
        </p><p>
            The final step is to add validation functionality to the page, using
            <tt class="literal">&lt;s:validateAll&gt;</tt> and <tt class="literal">&lt;s:decorate&gt;</tt>,
            but I'll leave that for you to figure out.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6472"></a>11.3.&nbsp;Query objects</h2></div></div><div></div></div><p>
            If we need a list of all <tt class="literal">Person</tt> instance in the database, we
            can use a Query object. For example:
        </p><pre class="programlisting">&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p"/&gt;</pre><p>
            We can use it from a JSF page:
        </p><pre class="programlisting">&lt;h1&gt;List of people&lt;/h1&gt;
&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre><p>
            We probably need to support pagination:
        </p><pre class="programlisting">&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p" 
                        order="lastName" 
                        max-results="20"/&gt;</pre><p>
            We'll use a page parameter to determine the page to display:
        </p><pre class="programlisting">&lt;pages&gt;
    &lt;page view-id="/searchPerson.jsp"&gt;
        &lt;param name="firstResult" value="#{people.firstResult}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;</pre><p>
            The JSF code for a pagination control is a bit verbose, but manageable:
        </p><pre class="programlisting">&lt;h1&gt;Search for people&lt;/h1&gt;
&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.previousExists}" value="First Page"&gt;
    &lt;f:param name="firstResult" value="0"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.previousExists}" value="Previous Page"&gt;
    &lt;f:param name="firstResult" value="#{people.previousFirstResult}"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.nextExists}" value="Next Page"&gt;
    &lt;f:param name="firstResult" value="#{people.nextFirstResult}"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.nextExists}" value="Last Page"&gt;
    &lt;f:param name="firstResult" value="#{people.lastFirstResult}"/&gt;
&lt;/s:link&gt;</pre><p>
            Real search screens let the user enter a bunch of optional search criteria
            to narrow the list of results returned. The Query object lets you specify
            optional "restrictions" to support this important usecase:
        </p><pre class="programlisting">&lt;component name="examplePerson" class="Person"/&gt;
        
&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p" 
                        order="lastName" 
                        max-results="20"&gt;
    &lt;framework:restrictions&gt;
        &lt;value&gt;lower(firstName) like lower( concat(#{examplePerson.firstName},'%') )&lt;/value&gt;
        &lt;value&gt;lower(lastName) like lower( concat(#{examplePerson.lastName},'%') )&lt;/value&gt;
    &lt;/framework:restrictions&gt;
&lt;/framework:entity-query&gt;</pre><p>
            Notice the use of an "example" object.
        </p><pre class="programlisting">&lt;h1&gt;Search for people&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{examplePerson.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{examplePerson.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h:commandButton value="Search" action="/search.jsp"/&gt;&lt;/div&gt;
&lt;/h:form&gt;

&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre><p>
			To refresh the query when the underlying entities change we observe the
			<tt class="literal">org.jboss.seam.afterTransactionSuccess</tt> event:
		</p><pre class="programlisting">&lt;event type="org.jboss.seam.afterTransactionSuccess"&gt;
    &lt;action execute="#{people.refresh}" /&gt;
&lt;/event&gt;</pre><p>
			Or, to just refresh the query when the person entity is persisted, updated or 
			removed through <tt class="literal">PersonHome</tt>:
		</p><pre class="programlisting">&lt;event type="org.jboss.seam.afterTransactionSuccess.Person"&gt;
    &lt;action execute="#{people.refresh}" /&gt;
&lt;/event&gt;</pre><p>
            The examples in this section have all shown reuse by configuration. However,
            reuse by extension is equally possible for Query objects.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6522"></a>11.4.&nbsp;Controller objects</h2></div></div><div></div></div><p>
            A totally optional part of the Seam Application Framework is the class
            <tt class="literal">Controller</tt> and its subclasses 
            <tt class="literal">EntityController</tt>
            <tt class="literal">HibernateEntityController</tt> and
            <tt class="literal">BusinessProcessController</tt>. These classes provide 
            nothing more than some convenience methods for access to commonly
            used built-in components and methods of built-in components. They help
            save a few keystrokes (characters can add up!) and provide a great
            launchpad for new users to explore the rich functionality built in
            to Seam.
        </p><p>
            For example, here is what <tt class="literal">RegisterAction</tt> from the
            Seam registration example would look like:
        </p><pre class="programlisting">@Stateless
@Name("register")
public class RegisterAction extends EntityController implements Register
{

   @In private User user;
   
   public String register()
   {
      List existing = createQuery("select u.username from User u where u.username=:username")
         .setParameter("username", user.getUsername())
         .getResultList();
      
      if ( existing.size()==0 )
      {
         persist(user);
         info("Registered new user #{user.username}");
         return "/registered.jspx";
      }
      else
      {
         addFacesMessage("User #{user.username} already exists");
         return null;
      }
   }

}</pre><p>
            As you can see, its not an earthshattering improvement...
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="drools"></a>Chapter&nbsp;12.&nbsp;Seam and JBoss Rules</h2></div></div><div></div></div><p>
        Seam makes it easy to call JBoss Rules (Drools) rulebases from Seam
        components or jBPM process definitions.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6553"></a>12.1.&nbsp;Installing rules</h2></div></div><div></div></div><p>
            The first step is to make an instance of <tt class="literal">org.drools.RuleBase</tt>
            available in a Seam context variable. For testing purposes, Seam provides a built-in component
            that compiles a static set of rules from the classpath. You can install
            this component via <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;drools:rule-base name="policyPricingRules"&gt;
    &lt;drools:rule-files&gt;
        &lt;value&gt;policyPricingRules&lt;/value&gt;
    &lt;/drools:rule-files&gt;
&lt;/drools:rule-base&gt;</pre><p>
             This component compiles rules from a set of <tt class="literal">.drl</tt>
             files and caches an instance of <tt class="literal">org.drools.RuleBase</tt>
             in the Seam <tt class="literal">APPLICATION</tt> context. Note that it is 
             quite likely that you will need to install multiple rule bases in a 
             rule-driven application.
         </p><p>
             If you want to use a Drools DSL, you alse need to specify the DSL
             definition:
         </p><pre class="programlisting">&lt;drools:rule-base name="policyPricingRules" dsl-file="policyPricing.dsl"&gt;
    &lt;drools:rule-files&gt;
        &lt;value&gt;policyPricingRules&lt;/value&gt;
    &lt;/drools:rule-files&gt;
&lt;/drools:rule-base&gt;</pre><p>
        In most rules-driven applications,
            rules need to be dynamically deployable, so a production application will want to use a
            Drools RuleAgent to manage the RuleBase.  The RuleAgent can connect to a Drools rule server (BRMS) 
            or hot deploy rules packages from a local file repository.  The RulesAgent-managed RuleBase is
            also configurable in <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;drools:rule-agent name="insuranceRules" 
                    configurationFile="/WEB-INF/deployedrules.properties" /&gt;</pre><p>The properties file contains properties specific to the RulesAgent. Here is an example configuration file from the
        Drools example distribution.</p><pre class="programlisting">newInstance=true
url=http://localhost:8080/drools-jbrms/org.drools.brms.JBRMS/package/org.acme.insurance/fmeyer
localCacheDir=/Users/fernandomeyer/projects/jbossrules/drools-examples/drools-examples-brms/cache
poll=30
name=insuranceconfig</pre><p>It is also possible to configure the options on the component directly, bypassing the configuration file.</p><pre class="programlisting">&lt;drools:rule-agent name="insuranceRules"
                   url="http://localhost:8080/drools-jbrms/org.drools.brms.JBRMS/package/org.acme.insurance/fmeyer"
                   local-cache-dir="/Users/fernandomeyer/projects/jbossrules/drools-examples/drools-examples-brms/cache"
                   poll="30"
                   configuration-name="insuranceconfig" /&gt;</pre><p>
             Next, we need to make an instance of <tt class="literal">org.drools.WorkingMemory</tt>
             available to each conversation. (Each <tt class="literal">WorkingMemory</tt>
             accumulates facts relating to the current conversation.)
         </p><pre class="programlisting">&lt;drools:managed-working-memory name="policyPricingWorkingMemory" auto-create="true" rule-base="#{policyPricingRules}"/&gt;</pre><p>
             Notice that we gave the <tt class="literal">policyPricingWorkingMemory</tt> a
             reference back to our rule base via the <tt class="literal">ruleBase</tt>
             configuration property.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6614"></a>12.2.&nbsp;Using rules from a Seam component</h2></div></div><div></div></div><p>
             We can now inject our <tt class="literal">WorkingMemory</tt> into any Seam component,
             assert facts, and fire rules:
         </p><pre class="programlisting">@In WorkingMemory policyPricingWorkingMemory;

@In Policy policy;
@In Customer customer;

public void pricePolicy() throws FactException
{
    policyPricingWorkingMemory.assertObject(policy);
    policyPricingWorkingMemory.assertObject(customer);
    policyPricingWorkingMemory.fireAllRules();
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6624"></a>12.3.&nbsp;Using rules from a jBPM process definition</h2></div></div><div></div></div><p>
             You can even allow a rule base to act as a jBPM action handler, decision
             handler, or assignment handler&#8212;in either a pageflow or business
             process definition.
         </p><pre class="programlisting">&lt;decision name="approval"&gt;
         
    &lt;handler class="org.jboss.seam.drools.DroolsDecisionHandler"&gt;
        &lt;workingMemoryName&gt;orderApprovalRulesWorkingMemory&lt;/workingMemoryName&gt;
        &lt;assertObjects&gt;
            &lt;element&gt;#{customer}&lt;/element&gt;
            &lt;element&gt;#{order}&lt;/element&gt;
            &lt;element&gt;#{order.lineItems}&lt;/element&gt;
        &lt;/assertObjects&gt;
    &lt;/handler&gt;
    
    &lt;transition name="approved" to="ship"&gt;
        &lt;action class="org.jboss.seam.drools.DroolsActionHandler"&gt;
            &lt;workingMemoryName&gt;shippingRulesWorkingMemory&lt;/workingMemoryName&gt;
            &lt;assertObjects&gt;
                &lt;element&gt;#{customer}&lt;/element&gt;
                &lt;element&gt;#{order}&lt;/element&gt;
                &lt;element&gt;#{order.lineItems}&lt;/element&gt;
            &lt;/assertObjects&gt;
        &lt;/action&gt;
    &lt;/transition&gt;
    
    &lt;transition name="rejected" to="cancelled"/&gt;
    
&lt;/decision&gt;</pre><p>
             The <tt class="literal">&lt;assertObjects&gt;</tt> element specifies EL expressions that
             return an object or collection of objects to be asserted as facts into the 
             <tt class="literal">WorkingMemory</tt>.
         </p><p>
             There is also support for using Drools for jBPM task assignments:
         </p><pre class="programlisting">&lt;task-node name="review"&gt;
    &lt;task name="review" description="Review Order"&gt;
        &lt;assignment handler="org.jboss.seam.drools.DroolsAssignmentHandler"&gt;
            &lt;workingMemoryName&gt;orderApprovalRulesWorkingMemory&lt;/workingMemoryName&gt;
            &lt;assertObjects&gt;
                &lt;element&gt;#{actor}&lt;/element&gt;
                &lt;element&gt;#{customer}&lt;/element&gt;
                &lt;element&gt;#{order}&lt;/element&gt;
                &lt;element&gt;#{order.lineItems}&lt;/element&gt;
            &lt;/assertObjects&gt;
        &lt;/assignment&gt;
    &lt;/task&gt;
    &lt;transition name="rejected" to="cancelled"/&gt;
    &lt;transition name="approved" to="approved"/&gt;
&lt;/task-node&gt;</pre><p>
             Certain objects are available to the rules as Drools globals, namely
             the jBPM <tt class="literal">Assignable</tt>, as <tt class="literal">assignable</tt>
             and a Seam <tt class="literal">Decision</tt> object, as <tt class="literal">decision</tt>.
             Rules which handle decisions should call <tt class="literal">decision.setOutcome("result")</tt>
             to determine the result of the decision. Rules which perform assignments should
             set the actor id using the <tt class="literal">Assignable</tt>.
         </p><pre class="programlisting">package org.jboss.seam.examples.shop

import org.jboss.seam.drools.Decision

global Decision decision

rule "Approve Order For Loyal Customer"
  when
    Customer( loyaltyStatus == "GOLD" )
    Order( totalAmount &lt;= 10000 )
  then
    decision.setOutcome("approved");
end</pre><pre class="programlisting">package org.jboss.seam.examples.shop

import org.jbpm.taskmgmt.exe.Assignable

global Assignable assignable

rule "Assign Review For Small Order"
  when
    Order( totalAmount &lt;= 100 )
  then
    assignable.setPooledActors( new String[] {"reviewers"} );
end</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;13.&nbsp;Security</h2></div></div><div></div></div><p>
    The Seam Security API is an optional Seam feature that provides authentication and authorization features
    for securing both domain and page resources within your Seam project.  
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6672"></a>13.1.&nbsp;Overview</h2></div></div><div></div></div><p>
      Seam Security provides two different modes of operation:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          <span class="emphasis"><em>simplified mode</em></span> - this mode supports authentication services
          and simple role-based security checks.
        </p></li><li><p>
          <span class="emphasis"><em>advanced mode</em></span> - this mode supports all the same features as the simplified mode, 
          plus it offers rule-based security checks using JBoss Rules.        
        </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6690"></a>13.1.1.&nbsp;Which mode is right for my application?</h3></div></div><div></div></div><p>
        That all depends on the requirements of your application.  If you have minimal security requirements, for example
        if you only wish to restrict certain pages and actions to users who are logged in, or who belong to a certain role,
        then the simplified mode will probably be sufficient.  The advantages of this is a more simplified configuration, 
        significantly less libraries to include, and a smaller memory footprint.
      </p><p>
        If on the other hand, your application requires security checks based on contextual state or complex business rules, 
        then you will require the features provided by the advanced mode.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6697"></a>13.2.&nbsp;Requirements</h2></div></div><div></div></div><p>
      If using the advanced mode features of Seam Security, the following jar files are required to be configured as modules in 
      <tt class="literal">application.xml</tt>.  If you are using Seam Security in simplified mode, these are <span class="emphasis"><em>not</em></span>
      required:
    </p><div class="itemizedlist"><ul type="disc"><li><p>drools-compiler-4.0.0.MR2.jar</p></li><li><p>drools-core-4.0.0.MR2.jar</p></li><li><p>janino-2.5.7.jar</p></li><li><p>antlr-runtime-3.0.jar</p></li><li><p>mvel14-1.2beta16.jar</p></li></ul></div><p>
      For web-based security, <tt class="literal">jboss-seam-ui.jar</tt> must also be included in the application's war file.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6729"></a>13.3.&nbsp;Disabling Security</h2></div></div><div></div></div><p>
      In some situations it may be necessary to disable Seam Security, for example during unit tests.  This can be done by
      calling the static method <tt class="literal">Identity.setSecurityEnabled(false)</tt> to disable security checks.  Doing this
      prevents any security checks being performed for the following:
    </p><div class="itemizedlist"><ul type="disc"><li><p>Entity Security</p></li><li><p>Hibernate Security Interceptor</p></li><li><p>Seam Security Interceptor</p></li><li><p>Page restrictions</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6750"></a>13.4.&nbsp;Authentication</h2></div></div><div></div></div><p>
      The authentication features provided by Seam Security are built upon JAAS (Java Authentication and Authorization Service),
      and as such provide a robust and highly configurable API for handling user authentication.  However, for less complex
      authentication requirements Seam offers a much more simplified method of authentication that hides the complexity of JAAS.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6755"></a>13.4.1.&nbsp;Configuration</h3></div></div><div></div></div><p>
        The simplified authentication method uses a built-in JAAS login module, <tt class="literal">SeamLoginModule</tt>, which
        delegates authentication to one of your own Seam components.  This login module is already configured inside Seam as
        part of a default application policy and as such does not require any additional configuration files.  It allows you to
        write an authentication method using the entity classes that are provided by your own application.  Configuring this
        simplified form of authentication requires the <tt class="literal">identity</tt> component to be configured in
        <tt class="literal">components.xml</tt>:
      </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:security="http://jboss.com/products/seam/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd
                 http://jboss.com/products/seam/security http://jboss.com/products/seam/security-2.0.xsd"&gt;                
        
    &lt;security:identity authenticate-method="#{authenticator.authenticate}"/&gt;
    
&lt;/components&gt;</pre><p>
        If you wish to use the advanced security features such as rule-based permission checks, all you need
        to do is include the Drools (JBoss Rules) jars in your classpath, and add some additional configuration,
        described later.
      </p><p>
        The EL expression <tt class="literal">#{authenticator.authenticate}</tt> is a method binding indicating that
        the <tt class="literal">authenticate</tt> method of the <tt class="literal">authenticator</tt> component will be used
        to authenticate the user.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6784"></a>13.4.2.&nbsp;Writing an authentication method</h3></div></div><div></div></div><p>
        The <tt class="literal">authenticate-method</tt> property specified for <tt class="literal">identity</tt> in
        <tt class="literal">components.xml</tt> specifies which method will be used by <tt class="literal">SeamLoginModule</tt>
        to authenticate users.  This method takes no parameters, and is expected to return a boolean indicating 
        whether authentication is successful or not.  The user's username and password can be obtained from
        <tt class="literal">Identity.instance().getUsername()</tt> and <tt class="literal">Identity.instance().getPassword()</tt>,
        respectively.  Any roles that the user is a member of should be assigned using
        <tt class="literal">Identity.instance().addRole()</tt>. Here's a complete example of an authentication method 
        inside a JavaBean component:
      </p><pre class="programlisting">@Name("authenticator")
public class Authenticator {
   @In EntityManager entityManager;
   
   public boolean authenticate() {
      try
      {
         User user = (User) entityManager.createQuery(
            "from User where username = :username and password = :password")
            .setParameter("username", Identity.instance().getUsername())
            .setParameter("password", Identity.instance().getPassword())
            .getSingleResult();

         if (user.getRoles() != null)
         {
            for (UserRole mr : user.getRoles())
               Identity.instance().addRole(mr.getName());
         }

         return true;
      }
      catch (NoResultException ex)
      {
         return false;
      }
      
   }
   
}</pre><p>
        In the above example, both <tt class="literal">User</tt> and <tt class="literal">UserRole</tt> are application-specific
        entity beans.  The <tt class="literal">roles</tt> parameter is populated with the roles that the user is a member
        of, which should be added to the <tt class="literal">Set</tt> as literal string values, e.g. "admin", "user".
        In this case, if the user record is not found and a <tt class="literal">NoResultException</tt> thrown, the
        authentication method returns <tt class="literal">false</tt> to indicate the authentication failed.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6832"></a>13.4.2.1.&nbsp;Identity.addRole()</h4></div></div><div></div></div><p>
          The <tt class="literal">Identity.addRole()</tt> method behaves differently depending on whether the current
          session is authenticated or not.  If the session is not authenticated, then <tt class="literal">addRole()</tt> 
          should <span class="emphasis"><em>only</em></span> be called during the authentication process.  When called here, the
          role name is placed into a temporary list of pre-authenticated roles.  Once authentication is successful,
          the pre-authenticated roles then become "real" roles, and calling <tt class="literal">Identity.hasRole()</tt>
          for those roles will then return true.  The following sequence diagram represents the list of pre-authenticated
          roles as a first class object to show more clearly how it fits in to the authentication process.
        
        </p><div class="mediaobject" align="center"><img src="../shared/images/security-addrole.png" align="middle"></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6854"></a>13.4.3.&nbsp;Writing a login form</h3></div></div><div></div></div><p>
        The <tt class="literal">Identity</tt> component provides both <tt class="literal">username</tt> and <tt class="literal">password</tt>
        properties, catering for the most common authentication scenario. These properties can be bound directly to the
        username and password fields on a login form.  Once these properties are set, calling the 
        <tt class="literal">identity.login()</tt> method will authenticate the user using the provided credentials.  
        Here's an example of a simple login form:
      </p><pre class="programlisting">&lt;div&gt;
    &lt;h:outputLabel for="name" value="Username"/&gt;
    &lt;h:inputText id="name" value="#{identity.username}"/&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h:outputLabel for="password" value="Password"/&gt;
    &lt;h:inputSecret id="password" value="#{identity.password}"/&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h:commandButton value="Login" action="#{identity.login}"/&gt;
&lt;/div&gt;</pre><p>
        Similarly, logging out the user is done by calling <tt class="literal">#{identity.logout}</tt>. Calling this
        action will clear the security state of the currently authenticated user.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6878"></a>13.4.4.&nbsp;Simplified Configuration - Summary</h3></div></div><div></div></div><p>
        So to sum up, there are the three easy steps to configure authentication:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Configure an authentication method in <tt class="literal">components.xml</tt>.
          </p></li><li><p>
            Write an authentication method.
          </p></li><li><p>
            Write a login form so that the user can authenticate.
          </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6896"></a>13.4.5.&nbsp;Handling Security Exceptions</h3></div></div><div></div></div><p>
        To prevent users from receiving the default error page in response to a security error, it's recommended that 
        <tt class="literal">pages.xml</tt> is configured to redirect security errors to a more "pretty" page.  The two
        main types of exceptions thrown by the security API are:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">NotLoggedInException</tt> - This exception is thrown if the user attempts to access a 
            restricted action or page when they are not logged in.
          </p></li><li><p>
            <tt class="literal">AuthorizationException</tt> - This exception is only thrown if the user is already logged in,
            and they have attempted to access a restricted action or page for which they do not have the necessary
            privileges.
          </p></li></ul></div><p>
        In the case of a <tt class="literal">NotLoggedInException</tt>, it is recommended that the user is redirected to
        either a login or registration page so that they can log in.  For an <tt class="literal">AuthorizationException</tt>,
        it may be useful to redirect the user to an error page. Here's an example of a <tt class="literal">pages.xml</tt> 
        file that redirects both of these security exceptions:      
      </p><pre class="programlisting">&lt;pages&gt;

    ...
    
    &lt;exception class="org.jboss.seam.security.NotLoggedInException"&gt;
        &lt;redirect view-id="/login.xhtml"&gt;
            &lt;message&gt;You must be logged in to perform this action&lt;/message&gt;
        &lt;/redirect&gt;
    &lt;/exception&gt;
    
    &lt;exception class="org.jboss.seam.security.AuthorizationException"&gt;
        &lt;end-conversation/&gt;
        &lt;redirect view-id="/security_error.xhtml"&gt;
            &lt;message&gt;You do not have the necessary security privileges to perform this action.&lt;/message&gt;
        &lt;/redirect&gt;
    &lt;/exception&gt;
  
&lt;/pages&gt;</pre><p>
        Most web applications require even more sophisticated handling of login redirection, so
        Seam includes some special functionality for handling this problem.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6932"></a>13.4.6.&nbsp;Login Redirection</h3></div></div><div></div></div><p>
        You can ask Seam to redirect the user to a login screen when an unauthenticated user tries 
        to access a particular view (or wildcarded view id) as follows:
      </p><pre class="programlisting">&lt;pages login-view-id="/login.xhtml"&gt;

    &lt;page view-id="/members/*" login-required="true"/&gt;
    
    ...
    
&lt;/pages&gt;</pre><p>
        (This is less of a blunt instrument than the exception handler shown above, but should 
        probably be used in conjunction with it.)
      </p><p>
        After the user logs in, we want to automatically send them back where they came from, so
        they can retry the action that required logging in. If you add the following event listeners 
        to <tt class="literal">components.xml</tt>, attempts to access a restricted view while not logged 
        in will be remembered, so that upon the user successfully logging in they will be redirected 
        to the originally requested view, with any page parameters that existed in the original
        request.
      </p><pre class="programlisting">&lt;event type="org.jboss.seam.notLoggedIn"&gt;
    &lt;action execute="#{redirect.captureCurrentView}"/&gt;
&lt;/event&gt;
    
&lt;event type="org.jboss.seam.postAuthenticate"&gt;
    &lt;action execute="#{redirect.returnToCapturedView}"/&gt;
&lt;/event&gt;</pre><p>
        Note that login redirection is implemented as a conversation-scoped mechanism, so don't end 
        the conversation in your <tt class="literal">authenticate()</tt> method.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6953"></a>13.4.7.&nbsp;HTTP Authentication</h3></div></div><div></div></div><p>
        Although not recommended for use unless absolutely necessary, Seam provides means for authenticating 
        using either HTTP Basic or HTTP Digest (RFC 2617) methods.  To use either form of authentication, 
        the <tt class="literal">authentication-filter</tt> component must be enabled in components.xml:
      </p><pre class="programlisting">
  &lt;web:authentication-filter url-pattern="*.seam" auth-type="basic"/&gt;
      </pre><p>
        To enable the filter for basic authentication, set <tt class="literal">auth-type</tt> to <tt class="literal">basic</tt>,
        or for digest authentication, set it to <tt class="literal">digest</tt>.  If using digest authentication, the
        <tt class="literal">key</tt> and <tt class="literal">realm</tt> must also be set:
      </p><pre class="programlisting">
  &lt;web:authentication-filter url-pattern="*.seam" auth-type="digest" key="AA3JK34aSDlkj" realm="My App"/&gt;
      </pre><p>
        The <tt class="literal">key</tt> can be any String value.  The <tt class="literal">realm</tt> is the name of the 
        authentication realm that is presented to the user when they authenticate.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6990"></a>13.4.7.1.&nbsp;Writing a Digest Authenticator</h4></div></div><div></div></div><p>
          If using digest authentication, your authenticator class should extend the abstract class
          <tt class="literal">org.jboss.seam.security.digest.DigestAuthenticator</tt>, and use the
          <tt class="literal">validatePassword()</tt> method to validate the user's plain text password
          against the digest request.  Here is an example:
        </p><pre class="programlisting">
   public boolean authenticate() 
   {
      try
      {            
         User user = (User) entityManager.createQuery(
            "from User where username = :username")
            .setParameter("username", identity.getUsername())
            .getSingleResult();
         
         return validatePassword(user.getPassword());
      }
      catch (NoResultException ex)
      {
         return false;
      }      
   }        
        </pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7003"></a>13.4.8.&nbsp;Advanced Authentication Features</h3></div></div><div></div></div><p>
        This section explores some of the advanced features provided by the security API for addressing more complex
        security requirements.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7008"></a>13.4.8.1.&nbsp;Using your container's JAAS configuration</h4></div></div><div></div></div><p>
          If you would rather not use the simplified JAAS configuration provided by the Seam Security API, you may
          instead delegate to the default system JAAS configuration by providing a <tt class="literal">jaasConfigName</tt>
          property in <tt class="literal">components.xml</tt>.  For example, if you are using JBoss AS and wish to use
          the <tt class="literal">other</tt> policy (which uses the <tt class="literal">UsersRolesLoginModule</tt> login module
          provided by JBoss AS), then the entry in <tt class="literal">components.xml</tt> would look like this:
        </p><pre class="programlisting">&lt;security:identity authenticate-method="#{authenticator.authenticate}" 
                      jaas-config-name="other"/&gt;</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7030"></a>13.5.&nbsp;Error Messages</h2></div></div><div></div></div><p>
      The security API produces a number of default faces messages for various security-related events.  
      The following table lists the message keys that can be used to override these messages by specifying 
      them in a <tt class="literal">message.properties</tt> resource file.  To suppress the message, just put the
      key with an empty value in the resource file.
    </p><div class="table"><a name="d0e7038"></a><p class="title"><b>Table&nbsp;13.1.&nbsp;Security Message Keys</b></p><table summary="Security Message Keys" border="1"><colgroup><col><col></colgroup><tbody><tr><td><p>
                <tt class="literal">org.jboss.seam.loginSuccessful</tt>
              </p></td><td><p>
                This message is produced when a user successfully logs in via the security API.
              </p></td></tr><tr><td><p>
                <tt class="literal">org.jboss.seam.loginFailed</tt>
              </p></td><td><p>
                This message is produced when the login process fails, either because the user provided an
                incorrect username or password, or because authentication failed in some other way.
              </p></td></tr><tr><td><p>
                <tt class="literal">org.jboss.seam.NotLoggedIn</tt>
              </p></td><td><p>
                This message is produced when a user attempts to perform an action or access a page that requires
                a security check, and the user is not currently authenticated.
              </p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7075"></a>13.6.&nbsp;Authorization</h2></div></div><div></div></div><p>
      There are a number of authorization features provided by the Seam Security API for securing access to
      components, component methods, and pages.  This section describes each of these.  An important thing to 
      note is that if you wish to use any of the advanced features (such as rule-based permissions) then 
      your <tt class="literal">components.xml</tt> must be configured to support this - see the Configuration section
      above.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7083"></a>13.6.1.&nbsp;Core concepts</h3></div></div><div></div></div><p>
        Each of the authorization mechanisms provided by the Seam Security API are built upon the concept of a user
        being granted roles and/or permissions.  A role is a <span class="emphasis"><em>group</em></span>, or <span class="emphasis"><em>type</em></span>,
        of user that may have been granted certain privileges for performing one or more specific actions within an
        application. A permission on the other hand is a privilege (sometimes once-off) for performing a single,
        specific action.  It is entirely possible to build an application using nothing but permissions, however
        roles offer a higher level of convenience when granting privileges to groups of users.
      </p><p>
        Roles are simple, consisting of only a name such as "admin", "user", "customer", etc.  Permissions consist of
        both a name and an action, and are represented within this documentation in the form <tt class="literal">name:action</tt>,
        for example <tt class="literal">customer:delete</tt>, or <tt class="literal">customer:insert</tt>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7105"></a>13.6.2.&nbsp;Securing components</h3></div></div><div></div></div><p>
        Let's start by examining the simplest form of authorization, component security, starting with the
        <tt class="literal">@Restrict</tt> annotation.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7113"></a>13.6.2.1.&nbsp;The @Restrict annotation</h4></div></div><div></div></div><p>
          Seam components may be secured either at the method or the class level, using the <tt class="literal">@Restrict</tt>
          annotation.  If both a method and it's declaring class are annotated with <tt class="literal">@Restrict</tt>,
          the method restriction will take precedence (and the class restriction will not apply).  If a method
          invocation fails a security check, then an exception will be thrown as per the contract for
          <tt class="literal">Identity.checkRestriction()</tt> (see Inline Restrictions).  A <tt class="literal">@Restrict</tt>
          on just the component class itself is equivalent to adding <tt class="literal">@Restrict</tt> to each of its
          methods.
        </p><p>
          An empty <tt class="literal">@Restrict</tt> implies a permission check of <tt class="literal">componentName:methodName</tt>.
          Take for example the following component method:
        </p><pre class="programlisting">@Name("account")
public class AccountAction {
    @Restrict public void delete() {
      ...
    }
}</pre><p>
          In this example, the implied permission required to call the <tt class="literal">delete()</tt> method is
          <tt class="literal">account:delete</tt>.  The equivalent of this would be to write
          <tt class="literal">@Restrict("#{s:hasPermission('account','delete',null)}")</tt>.  Now let's look at
          another example:
        </p><pre class="programlisting">@Restrict @Name("account")
public class AccountAction {
    public void insert() {
      ...
    }
    @Restrict("#{s:hasRole('admin')}") 
    public void delete() {
      ...
    }
}</pre><p>
          This time, the component class itself is annotated with <tt class="literal">@Restrict</tt>.  This means that
          any methods without an overriding <tt class="literal">@Restrict</tt> annotation require an implicit permission check.
          In the case of this example, the <tt class="literal">insert()</tt> method requires a permission of
          <tt class="literal">account:insert</tt>, while the <tt class="literal">delete()</tt> method requires that the user is a
          member of the <tt class="literal">admin</tt> role.
        </p><p>
          Before we go any further, let's address the <tt class="literal">#{s:hasRole()}</tt> expression seen in the above
          example.  Both <tt class="literal">s:hasRole</tt> and <tt class="literal">s:hasPermission</tt> are EL functions, which
          delegate to the correspondingly named methods of the <tt class="literal">Identity</tt> class. These
          functions can be used within any EL expression throughout the entirety of the security API.
        </p><p>
          Being an EL expression, the value of the <tt class="literal">@Restrict</tt> annotation may reference any objects that
          exist within a Seam context.  This is extremely useful when performing permission checks for a specific
          object instance.  Look at this example:
        </p><pre class="programlisting">@Name("account")
public class AccountAction {
    @In Account selectedAccount;
    @Restrict("#{s:hasPermission('account','modify',selectedAccount)}")
    public void modify() {
        selectedAccount.modify();
    }
}</pre><p>
          The interesting thing to note from this example is the reference to <tt class="literal">selectedAccount</tt>
          seen within the <tt class="literal">hasPermission()</tt> function call.  The value of this variable will be
          looked up from within the Seam context, and passed to the <tt class="literal">hasPermission()</tt> method
          in <tt class="literal">Identity</tt>, which in this case can then determine if the user has the required
          permission for modifying the specified <tt class="literal">Account</tt> object.
        </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7214"></a>13.6.2.2.&nbsp;Inline restrictions</h4></div></div><div></div></div><p>
          Sometimes it might be desirable to perform a security check in code, without using the
          <tt class="literal">@Restrict</tt> annotation.  In this situation, simply use
          <tt class="literal">Identity.checkRestriction()</tt> to evaluate a security expression, like this:
        </p><pre class="programlisting">public void deleteCustomer() {
    Identity.instance().checkRestriction("#{s:hasPermission('customer','delete',selectedCustomer)}");
}</pre><p>
          If the expression specified doesn't evaluate to <tt class="literal">true</tt>, either
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    if the user is not logged in, a <tt class="literal">NotLoggedInException</tt> 
                    exception is thrown or
                </p></li><li><p>
                    if the user is logged in, an <tt class="literal">AuthorizationException</tt> 
                    exception is thrown.
                </p></li></ul></div><p>
          It is also possible to call the <tt class="literal">hasRole()</tt> and <tt class="literal">hasPermission()</tt> 
          methods directly from Java code:
        </p><pre class="programlisting">if (!Identity.instance().hasRole("admin"))
     throw new AuthorizationException("Must be admin to perform this action");

if (!Identity.instance().hasPermission("customer", "create", null))
     throw new AuthorizationException("You may not create new customers");</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7255"></a>13.6.3.&nbsp;Security in the user interface</h3></div></div><div></div></div><p>
        One indication of a well designed user interface is that the user is not presented with options for 
        which they don't have the necessary privileges to use.  Seam Security allows conditional rendering of 
        either 1) sections of a page or 2) individual controls, based upon the privileges of the user, using
        the very same EL expressions that are used for component security.
      </p><p>
        Let's take a look at some examples of interface security.  First of all, let's pretend that we have a 
        login form that should only be rendered if the user is not already logged in.  Using the 
        <tt class="literal">identity.isLoggedIn()</tt> property, we can write this:
      </p><pre class="programlisting">&lt;h:form class="loginForm" rendered="#{not identity.loggedIn}"&gt;</pre><p>
        If the user isn't logged in, then the login form will be rendered - very straight forward so far.  
        Now let's pretend there is a menu on the page that contains some actions which should only be accessible
        to users in the <tt class="literal">manager</tt> role.  Here's one way that these could be written:
      </p><pre class="programlisting">&lt;h:outputLink action="#{reports.listManagerReports}" rendered="#{s:hasRole('manager')}"&gt;
    Manager Reports
&lt;/h:outputLink&gt;</pre><p>
        This is also quite straight forward.  If the user is not a member of the <tt class="literal">manager</tt>
        role, then the outputLink will not be rendered. The <tt class="literal">rendered</tt> attribute can
        generally be used on the control itself, or on a surrounding <tt class="literal">&lt;s:div&gt;</tt> or 
        <tt class="literal">&lt;s:span&gt;</tt> control.
      </p><p>
        Now for something more complex.  Let's say you have a <tt class="literal">h:dataTable</tt> control on a 
        page listing records for which you may or may not wish to render action links depending on the
        user's privileges.  The <tt class="literal">s:hasPermission</tt> EL function allows us to pass in an
        object parameter which can be used to determine whether the user has the requested permission 
        for that object or not. Here's how a dataTable with secured links might look:
      </p><pre class="programlisting">&lt;h:dataTable value="#{clients}" var="cl"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
        #{cl.name}
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;City&lt;/f:facet&gt;
        #{cl.city}
    &lt;/h:column&gt;   
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
        &lt;s:link value="Modify Client" action="#{clientAction.modify}"
                rendered="#{s:hasPermission('client','modify',cl)"/&gt;
        &lt;s:link value="Delete Client" action="#{clientAction.delete}"
                rendered="#{s:hasPermission('client','delete',cl)"/&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7298"></a>13.6.4.&nbsp;Securing pages</h3></div></div><div></div></div><p>
        Page security requires that the application is using a <tt class="literal">pages.xml</tt> file, however is
        extremely simple to configure.  Simply include a <tt class="literal">&lt;restrict/&gt;</tt> element within
        the <tt class="literal">page</tt> elements that you wish to secure.  If no explicit restriction is specified 
        by the <tt class="literal">restrict</tt> element, an implied permission of <tt class="literal">/viewId.xhtml:render</tt> 
        will be checked when the page is accessed via a non-faces (GET) request, and a permission of 
        <tt class="literal">/viewId.xhtml:restore</tt> will be required when any JSF postback (form submission) originates
        from the page.  Otherwise, the specified restriction will be evaluated as a standard security expression. 
        Here's a couple of examples:
      </p><pre class="programlisting">&lt;page view-id="/settings.xhtml"&gt;
    &lt;restrict/&gt;
&lt;/page&gt;</pre><p>
        This page has an implied permission of <tt class="literal">/settings.xhtml:render</tt> required for non-faces 
        requests and an implied permission of <tt class="literal">/settings.xhtml:restore</tt> for faces requests.
      </p><pre class="programlisting">&lt;page view-id="/reports.xhtml"&gt;    
    &lt;restrict&gt;#{s:hasRole('admin')}&lt;/restrict&gt;
&lt;/page&gt;</pre><p>
        Both faces and non-faces requests to this page require that the user is a member of the 
        <tt class="literal">admin</tt> role.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7338"></a>13.6.5.&nbsp;Securing Entities</h3></div></div><div></div></div><p>      
        Seam security also makes it possible to apply security restrictions to read, insert, update and 
        delete actions for entities.
      </p><p>
        To secure all actions for an entity class, add a <tt class="literal">@Restrict</tt> annotation on the class
        itself:
      </p><pre class="programlisting">@Entity
@Name("customer")
@Restrict
public class Customer {
  ...
}</pre><p>
        If no expression is specified in the <tt class="literal">@Restrict</tt> annotation, the default security check 
        that is performed is a permission check of <tt class="literal">entityName:action</tt>,
        where <tt class="literal">entityName</tt> is the Seam component name of the entity (or the fully-qualified class name if no @Name is 
        specified), and the <tt class="literal">action</tt> is either <tt class="literal">read</tt>, 
        <tt class="literal">insert</tt>, <tt class="literal">update</tt> or <tt class="literal">delete</tt>. 
      </p><p>
        It is also possible to only restrict certain actions, by placing a <tt class="literal">@Restrict</tt> annotation 
        on the relevent entity lifecycle method (annotated as follows):
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">@PostLoad</tt> - Called after an entity instance is loaded from the database. Use this
            method to configure a <tt class="literal">read</tt> permission.
          </p></li><li><p>
            <tt class="literal">@PrePersist</tt> - Called before a new instance of the entity is inserted. Use this method
            to configure an <tt class="literal">insert</tt> permission.
          </p></li><li><p>
            <tt class="literal">@PreUpdate</tt> - Called before an entity is updated. Use this method
            to configure an <tt class="literal">update</tt> permission.
          </p></li><li><p>
            <tt class="literal">@PreRemove</tt> - Called before an entity is deleted. Use this method
            to configure a <tt class="literal">delete</tt> permission.
          </p></li></ul></div><p>
        Here's an example of how an entity would be configured to perform a security check for any <tt class="literal">insert</tt>
        operations.  Please note that the method is not required to do anything, the only important thing in regard to 
        security is how it is annotated:
      </p><pre class="programlisting">
  @PrePersist @Restrict
  public void prePersist() {}      
   </pre><p>
        And here's an example of an entity permission rule that checks if the authenticated user is allowed to insert
        a new <tt class="literal">MemberBlog</tt> record (from the seamspace example).  The entity for which the security
        check is being made is automatically inserted into the working memory (in this case <tt class="literal">MemberBlog</tt>):
      </p><pre class="programlisting">rule InsertMemberBlog
  no-loop
  activation-group "permissions"  
when
  check: PermissionCheck(name == "memberBlog", action == "insert", granted == false)
  Principal(principalName : name)
  MemberBlog(member : member -&gt; (member.getUsername().equals(principalName)))
then
  check.grant();
end;</pre><p>
         This rule will grant the permission <tt class="literal">memberBlog:insert</tt> if the currently authenticated
         user (indicated by the <tt class="literal">Principal</tt> fact) has the same name as the member for which the
         blog entry is being created.  The "<tt class="literal">principalName : name</tt>" structure that can be seen in the
         <tt class="literal">Principal</tt> fact (and other places) is a variable binding - it binds the <tt class="literal">name</tt>
         property of the <tt class="literal">Principal</tt> to a variable called <tt class="literal">principalName</tt>.  Variable bindings
         allow the value to be referred to in other places, such as the following line which compares the member's username
         to the <tt class="literal">Principal</tt> name.  For more details, please refer to the JBoss Rules documentation. 
       </p><p>
         Finally, we need to install a listener class that integrates Seam security with
         your JPA provider.
       </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7463"></a>13.6.5.1.&nbsp;Entity security with JPA</h4></div></div><div></div></div><p>
          Security checks for EJB3 entity beans are performed with an <tt class="literal">EntityListener</tt>.
          You can install this listener by using the following <tt class="literal">META-INF/orm.xml</tt> file:
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
                 version="1.0"&gt;
                 
    &lt;persistence-unit-metadata&gt;
        &lt;persistence-unit-defaults&gt;
            &lt;entity-listeners&gt;
                &lt;entity-listener class="org.jboss.seam.security.EntitySecurityListener"/&gt;
            &lt;/entity-listeners&gt;
        &lt;/persistence-unit-defaults&gt;
    &lt;/persistence-unit-metadata&gt;
    
&lt;/entity-mappings&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7476"></a>13.6.5.2.&nbsp;Entity security with Hibernate</h4></div></div><div></div></div><p>
          If you are using a Hibernate <tt class="literal">SessionFactory</tt> configured via Seam, you don't 
          need to do anything special to use entity security.
        </p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7484"></a>13.7.&nbsp;Writing Security Rules</h2></div></div><div></div></div><p>
      Up to this point there has been a lot of mention of permissions, but no information about how permissions
      are actually defined or granted.  This section completes the picture, by explaining how permission 
      checks are processed, and how to implement permission checks for a Seam application.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7489"></a>13.7.1.&nbsp;Permissions Overview</h3></div></div><div></div></div><p>
        So how does the security API know whether a user has the <tt class="literal">customer:modify</tt> permission 
        for a specific customer?  Seam Security provides quite a novel method for determining user permissions,
        based on JBoss Rules.  A couple of the advantages of using a rule engine are 1) a centralized location 
        for the business logic that is behind each user permission, and 2) speed - JBoss Rules uses very efficient 
        algorithms for evaluating large numbers of complex rules involving multiple conditions.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7497"></a>13.7.2.&nbsp;Configuring a rules file</h3></div></div><div></div></div><p>
        Seam Security expects to find a <tt class="literal">RuleBase</tt> component called <tt class="literal">securityRules</tt>
        which it uses to evaluate permission checks.  This is configured in <tt class="literal">components.xml</tt> as follows:
      </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:security="http://jboss.com/products/seam/security"
            xmlns:drools="http://jboss.com/products/seam/drools"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/core http://jboss.com/products/seam/core-2.0.xsd 
                 http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd
                 http://jboss.com/products/seam/drools http://jboss.com/products/seam/drools-2.0.xsd"
                 http://jboss.com/products/seam/security http://jboss.com/products/seam/security-2.0.xsd"&gt;                 
        
   &lt;drools:rule-base name="securityRules"&gt;
       &lt;drools:rule-files&gt;
           &lt;value&gt;/META-INF/security.drl&lt;/value&gt;
       &lt;/drools:rule-files&gt;
   &lt;/drools:rule-base&gt;    
   
&lt;/components&gt;</pre><p>
        Once the <tt class="literal">RuleBase</tt> component is configured, it's time to write the security rules.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7518"></a>13.7.3.&nbsp;Creating a security rules file</h3></div></div><div></div></div><p>
        For this step you need to create a file called <tt class="literal">security.drl</tt> in the 
        <tt class="literal">/META-INF</tt> directory of your application's jar file.  In actual fact this file can be called
        anything you want, and exist in any location as long as it is configured appropriately in
        <tt class="literal">components.xml</tt>.
      </p><p>
        So what should the security rules file contain?  At this stage it might be a good idea to at least skim 
        through the JBoss Rules documentation, however to get started here's an extremely simple example:
      </p><pre class="programlisting">package MyApplicationPermissions;

import org.jboss.seam.security.PermissionCheck;
import org.jboss.seam.security.Role;

rule CanUserDeleteCustomers
when
  c: PermissionCheck(name == "customer", action == "delete")
  Role(name == "admin")
then
  c.grant();
end;</pre><p>
        Let's break this down.  The first thing we see is the package declaration.  A package in JBoss Rules
        is essentially a collection of rules.  The package name can be anything you want - it doesn't relate
        to anything else outside the scope of the rule base.
      </p><p>
        The next thing we can notice is a couple of import statements for the <tt class="literal">PermissionCheck</tt>
        and <tt class="literal">Role</tt> classes. These imports inform the rules engine that we'll be referencing 
        these classes within our rules.
      </p><p>
        Finally we have the code for the rule.  Each rule within a package should be given a unique name (usually 
        describing the purpose of the rule).  In this case our rule is called <tt class="literal">CanUserDeleteCustomers</tt> 
        and will be used to check whether a user is allowed to delete a customer record.
      </p><p>
        Looking at the body of the rule definition we can notice two distinct sections.  Rules have what is known
        as a left hand side (LHS) and a right hand side (RHS).  The LHS consists of the conditional part of the 
        rule, i.e. a list of conditions which must be satisfied for the rule to fire.  The LHS is represented by 
        the <tt class="literal">when</tt> section.  The RHS is the consequence, or action section of the rule that will
        only be fired if all of the conditions in the LHS are met.  The RHS is represented by the
        <tt class="literal">then</tt> section.  The end of the rule is denoted by the <tt class="literal">end;</tt> line.
      </p><p>
        If we look at the LHS of the rule, we see two conditions listed there.  Let's examine the first condition:
      </p><pre class="programlisting">c: PermissionCheck(name == "customer", action == "delete")</pre><p>
        In plain english, this condition is stating that there must exist a <tt class="literal">PermissionCheck</tt> object 
        with a <tt class="literal">name</tt> property equal to "customer", and an <tt class="literal">action</tt> property equal
        to "delete" within the working memory.  What is the working memory?  It is a session-scoped object that contains 
        the contextual information that is required by the rules engine to make a decision about a permission check.
        Each time the <tt class="literal">hasPermission()</tt> method is called, a temporary <tt class="literal">PermissionCheck</tt>
        object, or <span class="emphasis"><em>Fact</em></span>, is inserted into the working memory.  This <tt class="literal">PermissionCheck</tt>
        corresponds exactly to the permission that is being checked, so for example if you call 
        <tt class="literal">hasPermission("account", "create", null)</tt> then a <tt class="literal">PermissionCheck</tt>
        object with a <tt class="literal">name</tt> equal to "account" and <tt class="literal">action</tt> equal to "create" will be
        inserted into the working memory for the duration of the permission check.
      </p><p>
        So what else is in the working memory?  Besides the short-lived temporary facts inserted during a permission
        check, there are some longer-lived objects in the working memory that stay there for the entire duration of
        a user being authenticated.  These include any <tt class="literal">java.security.Principal</tt> objects that
        are created as part of the authentication process, plus a <tt class="literal">org.jboss.seam.security.Role</tt>
        object for each of the roles that the user is a member of.  It is also possible to insert additional 
        long-lived facts into the working memory by calling <tt class="literal">((RuleBasedIdentity) RuleBasedIdentity.instance()).getSecurityContext().insert()</tt>,
        passing the object as a parameter.
      </p><p>
        Getting back to our simple example, we can also notice that the first line of our LHS is prefixed with
        <tt class="literal">c:</tt>.  This is a variable binding, and is used to refer back to the object that is
        matched by the condition.  Moving onto the second line of our LHS, we see this:
      </p><pre class="programlisting">Role(name == "admin")</pre><p>
        This condition simply states that there must be a <tt class="literal">Role</tt> object with
        a <tt class="literal">name</tt> of "admin" within the working memory.  As mentioned, user roles are inserted 
        into the working memory as long-lived facts.  So, putting both conditions together, this rule is essentially 
        saying "I will fire if you are checking for the <tt class="literal">customer:delete</tt> permission and the user
        is a member of the <tt class="literal">admin</tt> role".
      </p><p>
        So what is the consequence of the rule firing?  Let's take a look at the RHS of the rule:
      </p><pre class="programlisting">c.grant()</pre><p>
        The RHS consists of Java code, and in this case is invoking the <tt class="literal">grant()</tt> 
        method of the <tt class="literal">c</tt> object, which as already mentioned is a variable binding 
        for the <tt class="literal">PermissionCheck</tt> object.  Besides the <tt class="literal">name</tt> and
        <tt class="literal">action</tt> properties of the <tt class="literal">PermissionCheck</tt> object, there
        is also a <tt class="literal">granted</tt> property which is initially set to <tt class="literal">false</tt>.
        Calling <tt class="literal">grant()</tt> on a <tt class="literal">PermissionCheck</tt> sets the 
        <tt class="literal">granted</tt> property to <tt class="literal">true</tt>, which means that the permission
        check was successful, allowing the user to carry out whatever action the permission check was
        intended for.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7675"></a>13.7.3.1.&nbsp;Wildcard permission checks</h4></div></div><div></div></div><p>
          It is possible to implement a wildcard permission check (which allows all actions for a given permission 
          name), by omitting the <tt class="literal">action</tt> constraint for the <tt class="literal">PermissionCheck</tt> in
          your rule, like this:
        </p><pre class="programlisting">rule CanDoAnythingToCustomersIfYouAreAnAdmin
when
  c: PermissionCheck(name == "customer")
  Role(name == "admin")
then
  c.grant();
end;        
        </pre><p>
          This rule allows users with the <tt class="literal">admin</tt> role to perform <span class="emphasis"><em>any</em></span> action for
          any <tt class="literal">customer</tt> permission check.
        </p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7699"></a>13.8.&nbsp;SSL Security</h2></div></div><div></div></div><p>
      Seam includes basic support for serving sensitive pages via the HTTPS protocol.  This is easily
      configured by specifying a <tt class="literal">scheme</tt> for the page in <tt class="literal">pages.xml</tt>.
      The following example shows how the view <tt class="literal">/login.xhtml</tt> is configured to use
      HTTPS:
    </p><pre class="programlisting">&lt;page view-id="/login.xhtml" scheme="https"&gt;</pre><p>
      This configuration is automatically extended to both <tt class="literal">s:link</tt> and 
      <tt class="literal">s:button</tt> JSF controls, which (when specifying the <tt class="literal">view</tt>)
      will also render the link using the correct protocol.  Based on the previous example, the following 
      link will use the HTTPS protocol because <tt class="literal">/login.xhtml</tt> is configured to use it:
    </p><pre class="programlisting">&lt;s:link view="/login.xhtml" value="Login"/&gt;</pre><p>
      Browsing directly to a view when using the <span class="emphasis"><em>incorrect</em></span> protocol will cause a 
      redirect to the same view using the <span class="emphasis"><em>correct</em></span> protocol.  For example, browsing
      to a page that has <tt class="literal">scheme="https"</tt> using HTTP will cause a redirect to the same
      page using HTTPS.
    </p><p>
      It is also possible to configure a <span class="emphasis"><em>default scheme</em></span> for all pages. This is useful
      if you wish to use HTTPS for a only few pages. If no default scheme is specified then the normal 
      behavior is to continue use the current scheme. So once the user accessed a page that required 
      HTTPS, then HTTPS would continue to be used after the user navigated away to other non-HTTPS pages.
      (While this is good for security, it is not so great for performance!). To define HTTP as the 
      default <tt class="literal">scheme</tt>, add this line to <tt class="literal">pages.xml</tt>:
    </p><pre class="programlisting">&lt;page view-id="*" scheme="http" /&gt;</pre><p>
      Of course, if <span class="emphasis"><em>none</em></span> of the pages in your application use HTTPS then it is not 
      required to specify a default scheme.
    </p><p>
      You may configure Seam to automatically invalidate the current HTTP session each time the scheme
      changes. Just add this line to <tt class="literal">components.xml</tt>:
    </p><pre class="programlisting">&lt;core:servlet-session invalidate-on-scheme-change="true"/&gt;</pre><p>
      This option helps make your system less vulnerable to sniffing of the session id or leakage of 
      sensitive data from pages using HTTPS to other pages using HTTP.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7769"></a>13.9.&nbsp;Implementing a Captcha Test</h2></div></div><div></div></div><p>
      Though strictly not part of the security API, it might be useful in certain circumstances (such as new
      user registrations, posting to a public blog or forum) to implement a Captcha (<span class="emphasis"><em>C</em></span>ompletely 
      <span class="emphasis"><em>A</em></span>utomated <span class="emphasis"><em>P</em></span>ublic <span class="emphasis"><em>T</em></span>uring test to tell 
      <span class="emphasis"><em>C</em></span>omputers and <span class="emphasis"><em>H</em></span>umans <span class="emphasis"><em>A</em></span>part) to 
      prevent automated bots from interacting with your application.  Seam provides seamless integration with
      JCaptcha, an excellent library for generating Captcha challenges.  If you wish to use the captcha
      feature in your application you need to include the jcaptcha-* jar file from the Seam lib directory in 
      your project, and register it in <tt class="literal">application.xml</tt> as a java module.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7798"></a>13.9.1.&nbsp;Configuring the Captcha Servlet</h3></div></div><div></div></div><p>
        To get up and running, it is necessary to configure the Seam Resource Servlet, which will provide the Captcha 
        challenge images to your pages.  This requires the following entry in <tt class="literal">web.xml</tt>:
      </p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.seam.servlet.SeamResourceServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/seam/resource/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7808"></a>13.9.2.&nbsp;Adding a Captcha to a page</h3></div></div><div></div></div><p>
        Adding a captcha challenge to a page is extremely easy.  Seam provides a page-scoped component,
        <tt class="literal">captcha</tt>, which provides everything that is required, including built-in captcha
        validation.  Here's an example:
      </p><pre class="programlisting">&lt;div&gt;
    &lt;h:graphicImage value="/seam/resource/captcha?#{captcha.id}"/&gt;
&lt;/div&gt;
  
&lt;div&gt;
    &lt;h:outputLabel for="verifyCaptcha"&gt;Enter the above letters&lt;/h:outputLabel&gt;
    &lt;h:inputText id="verifyCaptcha" value="#{captcha.response}" required="true"&gt;
      &lt;s:validate /&gt;
    &lt;/h:inputText&gt;
    &lt;div class="validationError"&gt;&lt;h:message for="verifyCaptcha"/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h:commandButton action="#{register.next}" value="Register"/&gt;
&lt;/div&gt;</pre><p>
        That's all there is to it.  The <tt class="literal">graphicImage</tt> control displays the Captcha challenge,
        and the <tt class="literal">inputText</tt> receives the user's response.  The response is automatically 
        validated against the Captcha when the form is submitted.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7826"></a>13.9.3.&nbsp;Customising the Captcha image</h3></div></div><div></div></div><p>
        The captcha image itself may be customised by providing an alternative <tt class="literal">ImageCaptchaService</tt>
        to the default (<tt class="literal">DefaultManageableImageCaptchaService</tt>). To configure a different
        <tt class="literal">ImageCaptchaService</tt>, add the following entry to <tt class="literal">components.xml</tt>:
      </p><pre class="programlisting">  &lt;component name="org.jboss.seam.captcha.captchaImage" service="#{customCaptcha.service}"/&gt;</pre><p>
        The <tt class="literal">service</tt> attribute specifies the <tt class="literal">ImageCaptchaService</tt> instance to
        use to generate captcha images.  For more information on configuring an <tt class="literal">ImageCaptchaService</tt> please
        refer to the JCaptcha documentation.  Here is an example of a custom image generator (which can be found in the 
        seamspace example):
      </p><pre class="programlisting">@Name("customCaptcha")
public class CustomCaptcha
{
   public ImageCaptchaService getService()
   {
      BasicGimpyEngine customCaptcha = new BasicGimpyEngine();
      GimpyFactory factory = new GimpyFactory(
            new RandomWordGenerator("ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789"), 
            new ComposedWordToImage(new RandomFontGenerator(new Integer(15), 
                  new Integer(15)), new UniColorBackgroundGenerator(new Integer(150), 
                        new Integer(30)), new RandomTextPaster(new Integer(4), 
                              new Integer(7), Color.BLACK)));
      GimpyFactory[] factories = {factory};
      customCaptcha.setFactories(factories);
      
      return new DefaultManageableImageCaptchaService(
                   new FastHashMapCaptchaStore(),
                   customCaptcha,
                   180,
                   120000,
                   75000);      
   }
}</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="i18n"></a>Chapter&nbsp;14.&nbsp;Internationalization and themes</h2></div></div><div></div></div><p>
        Seam makes it easy to build internationalized applications by
        providing several built-in components for handling multi-language
        UI messages.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7863"></a>14.1.&nbsp;Locales</h2></div></div><div></div></div><p>
            Each user login session has an associated instance of
            <tt class="literal">java.util.Locale</tt> (available to the 
            application as a component named 
            <tt class="literal">locale</tt>). Under normal circumstances,
            you won't need to do any special configuration to set
            the locale. Seam just delegates to JSF to determine
            the active locale:
        </p><div class="itemizedlist"><ul type="disc"><li><p>If there is a locale associated with the HTTP request
                (the browser locale), and that locale is in the list
                of supported locales from <tt class="literal">faces-config.xml</tt>, 
                use that locale for the rest of the session.</p></li><li><p>Otherwise, if a default locale was specified in the
                <tt class="literal">faces-config.xml</tt>, use that locale 
                for the rest of the session.</p></li><li><p>Otherwise, use the default locale of the server.</p></li></ul></div><p>
            It is <span class="emphasis"><em>possible</em></span> to set the locale
            manually via the Seam configuration properties
            <tt class="literal">org.jboss.seam.international.localeSelector.language</tt>,
            <tt class="literal">org.jboss.seam.international.localeSelector.country</tt> and
            <tt class="literal">org.jboss.seam.international.localeSelector.variant</tt>, but 
            we can't think of any good reason to ever do this.
        </p><p>
            It is, however, useful to allow the user to set the
            locale manually via the application user interface.
            Seam provides built-in functionality for overriding
            the locale determined by the algorithm above. All
            you have to do is add the following fragment to a 
            form in your JSP or Facelets page:
        </p><pre class="programlisting">&lt;h:selectOneMenu value="#{localeSelector.language}"&gt;
    &lt;f:selectItem itemLabel="English" itemValue="en"/&gt;
    &lt;f:selectItem itemLabel="Deutsch" itemValue="de"/&gt;
    &lt;f:selectItem itemLabel="Francais" itemValue="fr"/&gt;
&lt;/h:selectOneMenu&gt;
&lt;h:commandButton action="#{localeSelector.select}" value="#{messages['ChangeLanguage']}"/&gt;</pre><p>
            Or, if you want a list of all supported locales from 
            <tt class="literal">faces-config.xml</tt>, just use:
        </p><pre class="programlisting">&lt;h:selectOneMenu value="#{localeSelector.localeString}"&gt;
    &lt;f:selectItems value="#{localeSelector.supportedLocales}"/&gt;
&lt;/h:selectOneMenu&gt;
&lt;h:commandButton action="#{localeSelector.select}" value="#{messages['ChangeLanguage']}"/&gt;</pre><p>
            When this use selects an item from the drop-down, and 
            clicks the button, the Seam and JSF locales will be 
            overridden for the rest of the session.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7917"></a>14.2.&nbsp;Labels</h2></div></div><div></div></div><p>
            JSF supports internationalization of user interface labels and
            descriptive text via the use of <tt class="literal">&lt;f:loadBundle /&gt;</tt>.
            You can use this approach in Seam applications. Alternatively, you can
            take advantage of the Seam <tt class="literal">messages</tt> component to 
            display templated labels with embedded EL expressions.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7928"></a>14.2.1.&nbsp;Defining labels</h3></div></div><div></div></div><p>
            Seam provides a <tt class="literal">java.util.ResourceBundle</tt> (available 
            to the application as a <tt class="literal">org.jboss.seam.core.resourceBundle</tt>). 
            You'll need to make your internationalized labels available via this special 
            resource bundle. By default, the resource bundle used by Seam is named 
            <tt class="literal">messages</tt> and so you'll need to define your labels 
            in files named <tt class="literal">messages.properties</tt>, 
            <tt class="literal">messages_en.properties</tt>,
            <tt class="literal">messages_en_AU.properties</tt>, etc. These
            files usually belong in the <tt class="literal">WEB-INF/classes</tt> 
            directory.
        </p><p>
            So, in <tt class="literal">messages_en.properties</tt>:
        </p><pre class="programlisting">Hello=Hello</pre><p>
            And in <tt class="literal">messages_en_AU.properties</tt>:
        </p><pre class="programlisting">Hello=G'day</pre><p>
            You can select a different name for the resource bundle by setting
            the Seam configuration property named
            <tt class="literal">org.jboss.seam.core.resourceLoader.bundleNames</tt>. You can even specify
            a list of resource bundle names to be searched (depth first) for
            messages.
        </p><pre class="programlisting">&lt;core:resource-loader&gt;
    &lt;core:bundle-names&gt;
        &lt;value&gt;mycompany_messages&lt;/value&gt;
        &lt;value&gt;standard_messages&lt;/value&gt;       
    &lt;/core:bundle-names&gt;
&lt;/core:resource-loader&gt;</pre><p>
            If you want to define a message just for a particular page, you
            can specify it in a resource bundle with the same name as the
            JSF view id, with the leading <tt class="literal">/</tt> and trailing
            file extension removed. So we could put our message in 
            <tt class="literal">welcome/hello_en.properties</tt> if we only needed
            to display the message on <tt class="literal">/welcome/hello.jsp</tt>.
        </p><p>
            You can even specify an explicit bundle name in <tt class="literal">pages.xml</tt>:
        </p><pre class="programlisting">&lt;page view-id="/welcome/hello.jsp" bundle="HelloMessages"/&gt;</pre><p>
            Then we could use messages defined in <tt class="literal">HelloMessages.properties</tt>
            on <tt class="literal">/welcome/hello.jsp</tt>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8001"></a>14.2.2.&nbsp;Displaying labels</h3></div></div><div></div></div><p>
            If you define your labels using the Seam resource bundle, you'll
            be able to use them without having to type <tt class="literal">&lt;f:loadBundle ... /&gt;</tt>
            on every page. Instead, you can simply type:
        </p><pre class="programlisting">&lt;h:outputText value="#{messages['Hello']}"/&gt;</pre><p>
            or:
        </p><pre class="programlisting">&lt;h:outputText value="#{messages.Hello}"/&gt;</pre><p>
            Even better, the messages themselves may contain EL expressions:
        </p><pre class="programlisting">Hello=Hello, #{user.firstName} #{user.lastName}</pre><pre class="programlisting">Hello=G'day, #{user.firstName}</pre><p>
            You can even use the messages in your code:
        </p><pre class="programlisting">@In private Map&lt;String, String&gt; messages;</pre><pre class="programlisting">@In("#{messages['Hello']}") private String helloMessage;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8027"></a>14.2.3.&nbsp;Faces messages</h3></div></div><div></div></div><p>
            The <tt class="literal">facesMessages</tt> component is a super-convenient 
            way to display success or failure messages to the user. The functionality 
            we just described also works for faces messages:
        </p><pre class="programlisting">@Name("hello")
@Stateless
public class HelloBean implements Hello {
    @In FacesMessages facesMessages;
    
    public String sayIt() {
        facesMessages.addFromResourceBundle("Hello");
    }
}</pre><p>
            This will display <tt class="literal">Hello, Gavin King</tt> or <tt class="literal">G'day, Gavin</tt>,
            depending upon the user's locale.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8045"></a>14.3.&nbsp;Timezones</h2></div></div><div></div></div><p>
            There is also a session-scoped instance of <tt class="literal">java.util.Timezone</tt>,
            named <tt class="literal">org.jboss.seam.international.timezone</tt>, and a Seam component for changing 
            the timezone named <tt class="literal">org.jboss.seam.international.timezoneSelector</tt>. By default, 
            the timezone is the default timezone of the server. Unfortunately, the JSF specification 
            says that all dates and times should be assumed to be UTC, and displayed as UTC, unless 
            a timezone is explicitly specified using <tt class="literal">&lt;f:convertDateTime&gt;</tt>. 
            This is an extremely inconvenient default behavior.
        </p><p>
            Seam overrides this behavior, and defaults all dates and times to the Seam timezone.
            In addition, Seam provides the <tt class="literal">&lt;s:convertDateTime&gt;</tt> tag which 
            always performs conversions in the Seam timezone.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8067"></a>14.4.&nbsp;Themes</h2></div></div><div></div></div><p>
            Seam applications are also very easily skinnable. The theme API is very
            similar to the localization API, but of course these two concerns are
            orthogonal, and some applications support both localization and themes.
        </p><p>
            First, configure the set of supported themes:
        </p><pre class="programlisting">&lt;theme:theme-selector cookie-enabled="true"&gt;
    &lt;theme:available-themes&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;accessible&lt;/value&gt;
        &lt;value&gt;printable&lt;/value&gt;
    &lt;/theme:available-themes&gt;
&lt;/theme:theme-selector&gt;</pre><p>
            Note that the first theme listed is the default theme.
       </p><p>
            Themes are defined in a properties file with the same name as the theme.
            For example, the <tt class="literal">default</tt> theme is defined as a set of
            entries in <tt class="literal">default.properties</tt>. For example, 
            <tt class="literal">default.properties</tt> might define:
        </p><pre class="programlisting">css ../screen.css
template /template.xhtml</pre><p>
            Usually the entries in a theme resource bundle will be paths to CSS styles
            or images and names of facelets templates (unlike localization resource
            bundles which are usually text).
        </p><p>
            Now we can use these entries in our JSP or facelets pages. For example,
            to theme the stylesheet in a facelets page:
        </p><pre class="programlisting">&lt;link href="#{theme.css}" rel="stylesheet" type="text/css" /&gt;</pre><p>Or, when the page definition resides in a subdirectory:</p><pre class="programlisting">&lt;link href="#{facesContext.externalContext.requestContextPath}#{theme.css}" 
    rel="stylesheet" type="text/css" /&gt;</pre><p>
            Most powerfully, facelets lets us theme the template used by a <tt class="literal">&lt;ui:composition&gt;</tt>:
        </p><pre class="programlisting">&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://java.sun.com/jsf/facelets"
    xmlns:h="http://java.sun.com/jsf/html"
    xmlns:f="http://java.sun.com/jsf/core"
    template="#{theme.template}"&gt;</pre><p>
            Just like the locale selector, there is a built-in theme selector to allow 
            the user to freely switch themes:
        </p><pre class="programlisting">&lt;h:selectOneMenu value="#{themeSelector.theme}"&gt;
    &lt;f:selectItems value="#{themeSelector.themes}"/&gt;
&lt;/h:selectOneMenu&gt;
&lt;h:commandButton action="#{themeSelector.select}" value="Select Theme"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8112"></a>14.5.&nbsp;Persisting locale and theme preferences via cookies</h2></div></div><div></div></div><p>
            The locale selector, theme selector and timezone selector all support 
            persistence of locale and theme preference to a cookie. Simply set the 
            <tt class="literal">cookie-enabled</tt> property in <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;theme:theme-selector cookie-enabled="true"&gt;
    &lt;theme:available-themes&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;accessible&lt;/value&gt;
        &lt;value&gt;printable&lt;/value&gt;
    &lt;/theme:available-themes&gt;
&lt;/theme:theme-selector&gt;

&lt;international:locale-selector cookie-enabled="true"/&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="text"></a>Chapter&nbsp;15.&nbsp;Seam Text</h2></div></div><div></div></div><p>
        Collaboration-oriented websites require a human-friendly markup language for easy entry
        of formatted text in forum posts, wiki pages, blogs, comments, etc. Seam provides the
        <tt class="literal">&lt;s:formattedText/&gt;</tt> control for display of formatted text that
        conforms to the <span class="emphasis"><em>Seam Text</em></span> language. Seam Text is implemented using
        an ANTLR-based parser. You don't need to know anything about ANTLR to use it, however.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8136"></a>15.1.&nbsp;Basic fomatting</h2></div></div><div></div></div><p>
            Here is a simple example:
        </p><pre class="programlisting">It's easy to make *bold text*, /italic text/, |monospace|, 
~deleted text~, super^scripts^ or _underlines_.</pre><p>
            If we display this using <tt class="literal">&lt;s:formattedText/&gt;</tt>, we will get
            the following HTML produced:
        </p><pre class="programlisting">&lt;p&gt;
It's easy to make &lt;b&gt;bold text&lt;/b&gt;, &lt;i&gt;italic text&lt;/i&gt;, &lt;tt&gt;monospace&lt;/tt&gt;
&lt;del&gt;deleted text&lt;/del&gt;, super&lt;sup&gt;scripts&lt;/sup&gt; or &lt;u&gt;underlines&lt;/u&gt;.
&lt;/p&gt;</pre><p>
            We can use a blank line to indicate a new paragraph, and <tt class="literal">+</tt> to
            indicate a heading:
        </p><pre class="programlisting">+This is a big heading
You /must/ have some text following a heading!
 
++This is a smaller heading
This is the first paragraph. We can split it across multiple 
lines, but we must end it with a blank line.

This is the second paragraph.</pre><p>
            (Note that a simple newline is ignored, you need an additional blank line to wrap text into a new paragraph.)
           This is the HTML that results:
        </p><pre class="programlisting">&lt;h1&gt;This is a big heading&lt;/h1&gt;
&lt;p&gt;
You &lt;i&gt;must&lt;/i&gt; have some text following a heading!
&lt;/p&gt;
 
&lt;h2&gt;This is a smaller heading&lt;/h2&gt;
&lt;p&gt;
This is the first paragraph. We can split it across multiple 
lines, but we must end it with a blank line.
&lt;/p&gt;

&lt;p&gt;
This is the second paragraph.
&lt;/p&gt;</pre><p>
            Ordered lists are created using the <tt class="literal">#</tt> character. Unordered lists
            use the <tt class="literal">=</tt> character:
        </p><pre class="programlisting">An ordered list:
        
#first item
#second item
#and even the /third/ item

An unordered list:

=an item
=another item</pre><pre class="programlisting">&lt;p&gt;
An ordered list:
&lt;/p&gt;
 
&lt;ol&gt;       
&lt;li&gt;first item&lt;/li&gt;
&lt;li&gt;second item&lt;/li&gt;
&lt;li&gt;and even the &lt;i&gt;third&lt;/i&gt; item&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
An unordered list:
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an item&lt;/li&gt;
&lt;li&gt;another item&lt;/li&gt;
&lt;/ul&gt;</pre><p>
            Quoted sections should be surrounded in double quotes:
        </p><pre class="programlisting">The other guy said:
        
"Nyeah nyeah-nee 
/nyeah/ nyeah!"

But what do you think he means by "nyeah-nee"?</pre><pre class="programlisting">&lt;p&gt;
The other guy said:
&lt;/p&gt;
        
&lt;q&gt;Nyeah nyeah-nee
&lt;i&gt;nyeah&lt;/i&gt; nyeah!&lt;/q&gt;

&lt;p&gt;
But what do you think he means by &lt;q&gt;nyeah-nee&lt;/q&gt;?
&lt;/p&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8179"></a>15.2.&nbsp;Entering code and text with special characters</h2></div></div><div></div></div><p>
            Special characters such as <tt class="literal">*</tt>, <tt class="literal">|</tt>
            and <tt class="literal">#</tt>, along with HTML characters such as
            <tt class="literal">&lt;</tt>, <tt class="literal">&gt;</tt> and <tt class="literal">&amp;</tt> 
            may be escaped using <tt class="literal">\</tt>:
        </p><pre class="programlisting">You can write down equations like 2\*3\=6 and HTML tags
like \&lt;body\&gt; using the escape character: \\.</pre><pre class="programlisting">&lt;p&gt;
You can write down equations like 2*3=6 and HTML tags
like &amp;lt;body&amp;gt; using the escape character: \.
&lt;/p&gt;</pre><p>
            And we can quote code blocks using backticks:
        </p><pre class="programlisting">My code doesn't work:

`for (int i=0; i&lt;100; i--)
{
    doSomething();
}`

Any ideas?</pre><pre class="programlisting">&lt;p&gt;
My code doesn't work:
&lt;/p&gt;

&lt;pre&gt;for (int i=0; i&amp;lt;100; i--)
{
    doSomething();
}&lt;/pre&gt;

&lt;p&gt;
Any ideas?
&lt;/p&gt;</pre><p>
          Note that inline monospace formatting always escapes (most monospace formatted text is in fact
          code or tags with many special characters). So you can, for example, write:
       </p><pre class="programlisting">This is a |&lt;tag attribute="value"/&gt;| example.</pre><p>
          without escaping any of the characters inside the monospace bars. The downside is that
          you can't format inline monospace text in any other way (italics, underscore, and so on).
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8221"></a>15.3.&nbsp;Links</h2></div></div><div></div></div><p>
            A link may be created using the following syntax:
        </p><pre class="programlisting">Go to the Seam website at [=&gt;http://jboss.com/products/seam].</pre><p>
            Or, if you want to specify the text of the link:
        </p><pre class="programlisting">Go to [the Seam website=&gt;http://jboss.com/products/seam].</pre><p>
            For advanced users, it is even possible to customize the Seam Text parser to understand
            wikiword links written using this syntax.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8234"></a>15.4.&nbsp;Entering HTML</h2></div></div><div></div></div><p>
            Text may even include a certain limited subset of HTML (don't worry, the subset is chosen
            to be safe from cross-site scripting attacks). This is useful for creating links:
        </p><pre class="programlisting">You might want to link to &lt;a href="http://jboss.com/products/seam"&gt;something
cool&lt;/a&gt;, or even include an image: &lt;img src="/logo.jpg"/&gt;</pre><p>
           And for creating tables:
        </p><pre class="programlisting">&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;First name:&lt;/td&gt;&lt;td&gt;Gavin&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Last name:&lt;/td&gt;&lt;td&gt;King&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</pre><p>
            But you can do much more if you want!
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="itext"></a>Chapter&nbsp;16.&nbsp;iText PDF generation</h2></div></div><div></div></div><p>Seam now includes an component set for generating documents using iText. The primary focus of Seam's iText
        document support is for the generation of PDF doucuments, but Seam also offers basic support for RTF document
        generation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="itext.intro"></a>16.1.&nbsp;Using PDF Support</h2></div></div><div></div></div><p>iText support is provided by <tt class="literal">jboss-seam-pdf.jar</tt>. This JAR contains the iText JSF
            controls, which are used to construct views that can render to PDF, and the DocumentStore component, which
            serves the rendered documents to the user. To include PDF support in your application, included
                <tt class="literal">jboss-seam-pdf.jar</tt> in your <tt class="literal">WEB-INF/lib</tt> directory along with the
            iText JAR file. There is no further configuration needed to use Seam's iText supportfon. </p><p> The Seam iText module requires the use of Facelets as the view technology. Future versions of the library
            may also support the use of JSP. Additionally, it requires the use of the seam-ui package.</p><p> The <tt class="literal">examples/itext</tt> project contains an example of the PDF support in action. It
            demonstrates proper deployment packaging, and it contains a number examples that demonstrate the key PDF
            generation features current supported. </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.document"></a>16.1.1.&nbsp;Creating a document</h3></div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:document&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p> Documents are generated by facelets documents using tags in the
                                        <tt class="literal">http://jboss.com/products/seam/pdf</tt> namespace. Documents
                                    should always have the <tt class="literal">document</tt> tag at the root of the document.
                                    The <tt class="literal">document</tt> tag prepares Seam to generate a document into the
                                    DocumentStore and renders an HTML redirect to that stored content.</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">type</tt> &#8212; The type of the document to be produced.
                                            Valid values are <tt class="literal">PDF</tt>, <tt class="literal">RTF</tt> and
                                                <tt class="literal">HTML</tt> modes. Seam defaults to PDF generation, and many
                                            of the features only work correctly when generating PDF documents.</p></li><li><p>
                                            <tt class="literal">pageSize</tt> &#8212; The size of the page to be generate.
                                            The most commonly used values would be <tt class="literal">LETTER</tt> and
                                                <tt class="literal">A4</tt>. A full list of supported pages sizes can be found
                                            in <tt class="literal">com.lowagie.text.PageSize</tt> class. Alternatively,
                                            pageSize can provide the width and height of the page directly. The value
                                            "612 792", for example, is equivalent to the LETTER page size. </p></li><li><p>
                                            <tt class="literal">orientation</tt> &#8212; The orientation of the page.
                                            Valid values are <tt class="literal">portrait</tt> and
                                            <tt class="literal">landscape</tt>. In landscape mode, the height and width page
                                            size values are reversed. </p></li><li><p>
                                            <tt class="literal">margins</tt> &#8212; The left, right, top and bottom
                                            margin values. </p></li><li><p>
                                            <tt class="literal">marginMirroring</tt> &#8212; Indicates that margin
                                            settings should be reversed an alternating pages.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Metadata Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">title</tt>
                                        </p></li><li><p>
                                            <tt class="literal">subject</tt>
                                        </p></li><li><p>
                                            <tt class="literal">keywords</tt>
                                        </p></li><li><p>
                                            <tt class="literal">author</tt>
                                        </p></li><li><p>
                                            <tt class="literal">creator</tt>
                                        </p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:document xmlns:p="http://jboss.com/products/seam/pdf"&gt;                                                      
  The document goes here.                                                                                             
&lt;/p:document&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.text"></a>16.1.2.&nbsp;Basic Text Elements</h3></div></div><div></div></div><p> Useful documents will need to contain more than just text; however, the standard UI components are
                geared towards HTML generation and are not useful for generating PDF content. Instead, Seam provides a
                special UI components for generating suitable PDF content. Tags like
                <tt class="literal">&lt;p:image&gt;</tt> and <tt class="literal">&lt;p:paragraph&gt;</tt> are the
                basic foundations of simple documents. Tags like <tt class="literal">&lt;p:font&gt;</tt> provide style
                information to all the content surrounging them. </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:paragraph&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p> Most uses of text should be sectioned into paragraphs so that text fragments can
                                    be flowed, formatted and styled in logical groups.</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">firstLineIndent</tt>
                                        </p></li><li><p>
                                            <tt class="literal">extraParagraphSpace</tt>
                                        </p></li><li><p>
                                            <tt class="literal">leading</tt>
                                        </p></li><li><p>
                                            <tt class="literal">multipliedLeading</tt>
                                        </p></li><li><p>
                                            <tt class="literal">spacingBefore</tt> &#8212; The blank space to be inserted
                                            before the element. </p></li><li><p>
                                            <tt class="literal">spacingAfter</tt> &#8212; The blank space to be inserted
                                            after the element.</p></li><li><p>
                                            <tt class="literal">indentationLeft</tt>
                                        </p></li><li><p>
                                            <tt class="literal">indentationRight</tt>
                                        </p></li><li><p>
                                            <tt class="literal">keepTogether</tt>
                                        </p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:paragraph alignment="justify"&gt;
    This is a simple document.  It isn't very fancy.
&lt;/p:paragraph&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:text&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p> The <tt class="literal">text</tt> tag allows text fragments to be produced from
                                    application data using normal JSF converter mechanisms. It is very similar to the
                                        <tt class="literal">outputText</tt> tag used when rendering HTML documents. </p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">value</tt> &#8212; The value to be displayed. This will
                                            typically be a value binding expression.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:paragraph&gt;
    The item costs &lt;p:text value="#{product.price}"&gt;
        &lt;f:convertNumber type="currency" currencySymbol="$"/&gt;
    &lt;/p:text&gt;
&lt;/p:paragraph&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:font&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p> The font tag defines the default font to be used for all text inside of it. </p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">name</tt> &#8212; The font name, for example:
                                                <tt class="literal">COURIER</tt>, <tt class="literal">HELVETICA</tt>,
                                                <tt class="literal">TIMES-ROMAN</tt>, <tt class="literal">SYMBOL</tt> or
                                                <tt class="literal">ZAPFDINGBATS</tt>.</p></li><li><p><tt class="literal">size</tt> &#8212; The point size of the font.</p></li><li><p><tt class="literal">style</tt> &#8212; The font styles. Any combination of :
                                                <tt class="literal">NORMAL</tt>, <tt class="literal">BOLD</tt>,
                                            <tt class="literal">ITALIC</tt>, <tt class="literal">OBLIQUE</tt>,
                                            <tt class="literal">UNDERLINE</tt>, <tt class="literal">LINE-THROUGH</tt></p></li><li><p><tt class="literal">encoding</tt> &#8212; The character set encoding.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:font family="courier" style="bold" size="24"&gt;
    &lt;p:paragraph&gt;My Title&lt;/p:paragraph&gt;
&lt;/p:font&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:newPage&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:newPage</tt> inserts a page break. </p><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:newPage /&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:image&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:image</tt> inserts an image into the document. Images can be be
                                    loaded from the classpath or from the web application context using the
                                        <tt class="literal">value</tt> attribute. </p><p>Resources can also be dynamically generated by application code. The
                                        <tt class="literal">imageData</tt> attribute can specify a value binding expression
                                    whose value is a <tt class="literal">java.awt.Image</tt> object. </p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">value</tt> &#8212; A resource name or a method
                                            expression binding to an application-generated image. </p></li><li><p><tt class="literal">rotation</tt> &#8212; The rotation of the image in
                                            degrees. </p></li><li><p><tt class="literal">height</tt> &#8212; The height of the image. </p></li><li><p><tt class="literal">width</tt> &#8212; The width of the image. </p></li><li><p>
                                            <tt class="literal">alignment</tt>&#8212; The alignment of the image. (see
                                                <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for possible values) </p></li><li><p>
                                            <tt class="literal">alt</tt> &#8212; Alternative text representation for the
                                            image.</p></li><li><p>
                                            <tt class="literal">indentationLeft</tt>
                                        </p></li><li><p>
                                            <tt class="literal">indentationRight</tt>
                                        </p></li><li><p>
                                            <tt class="literal">spacingBefore</tt> &#8212; The blank space to be inserted
                                            before the element.</p></li><li><p>
                                            <tt class="literal">spacingAfter</tt> &#8212; The blank space to be inserted
                                            after the element.</p></li><li><p>
                                            <tt class="literal">widthPercentage</tt>
                                        </p></li><li><p>
                                            <tt class="literal">initialRotation</tt>
                                        </p></li><li><p>
                                            <tt class="literal">dpi</tt>
                                        </p></li><li><p>
                                            <tt class="literal">scalePercent</tt> &#8212; The scaling factor (as a
                                            percentage) to use for the image. This can be expressed as a single
                                            percentage value or as two percentage values representing separate x and y
                                            scaling percentages.</p></li><li><p>
                                            <tt class="literal">wrap</tt>
                                        </p></li><li><p>
                                            <tt class="literal">underlying</tt>
                                        </p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:image value="/jboss.jpg" /&gt;</pre><pre class="programlisting">&lt;p:image value="#{images.chart}" /&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:anchor&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:anchor</tt> defines clickable links from a document. It supports
                                    the following attributes:</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">name</tt> &#8212; The name of an in-document anchor
                                            destination.</p></li><li><p><tt class="literal">reference</tt> &#8212; The destination the link refers
                                            to. Links to other points in the document should begin with a "#". For
                                            example, "#link1" to refer to an anchor postion with a
                                            <tt class="literal">name</tt> of <tt class="literal">link1</tt>. Links may also be a
                                            full URL to point to a resource outside of the document.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:listItem&gt;&lt;p:anchor reference="#reason1"&gt;Reason 1&lt;/p:anchor&gt;&lt;/p:listItem&gt; 
...
&lt;p:paragraph&gt;
    &lt;p:anchor name="reason1"&gt;It's the quickest way to get "rich"&lt;/p:anchor&gt; 
    ... 
&lt;/p:paragraph&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.header"></a>16.1.3.&nbsp;Headers and Footers</h3></div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:header&gt;</tt>
                                </p><p>
                                    <tt class="literal">&lt;p:footer&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p>The <tt class="literal">p:header</tt> and <tt class="literal">p:footer</tt> components provide
                                    the ability to place header and footer text on each page of a generated document,
                                    with the exception of the first page. Header and footer declarations should appear
                                    near the top of a document. </p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">alignment</tt> &#8212; The alignment of the header/footer
                                            box section. (see <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for alignment values)</p></li><li><p><tt class="literal">backgroundColor</tt> &#8212; The background color of the
                                            header/footer box. (see <a href="#itext.colors" title="16.1.7.1.&nbsp;Color Values">Section&nbsp;16.1.7.1, &#8220;Color Values&#8221;</a> for color values)
                                        </p></li><li><p><tt class="literal">borderColor</tt> &#8212; The border color of the
                                            header/footer box. Individual border sides can be set using
                                                <tt class="literal">borderColorLeft</tt>, <tt class="literal">borderColorRight</tt>,
                                                <tt class="literal">borderColorTop</tt> and
                                            <tt class="literal">borderColorBottom</tt>.(see <a href="#itext.colors" title="16.1.7.1.&nbsp;Color Values">Section&nbsp;16.1.7.1, &#8220;Color Values&#8221;</a> for
                                            color values) </p></li><li><p>
                                            <tt class="literal">borderWidth</tt> &#8212; The width of the border.
                                            Inidvidual border sides can be specified using
                                            <tt class="literal">borderWidthLeft</tt>, <tt class="literal">borderWidthRight</tt>,
                                                <tt class="literal">borderWidthTop</tt> and
                                            <tt class="literal">borderWidthBottom</tt>.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:facet name="header"&gt;
  &lt;p:font size="12"&gt;
    &lt;p:footer borderWidthTop="1" borderColorTop="blue" 
              borderWidthBottom="0" alignment="center"&gt;
        Why Seam? [&lt;p:pageNumber /&gt;]
    &lt;/p:footer&gt;
  &lt;/p:font&gt;
&lt;/f:facet&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:pageNumber&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p>The current page number can be placed inside of a header or footer using the
                                        <tt class="literal">p:pageNumber</tt> tag. The page number tag can only be used in the
                                    context of a header or footer and can only be used once.</p><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:footer borderWidthTop="1" borderColorTop="blue" 
          borderWidthBottom="0" alignment="center"&gt;
    Why Seam? [&lt;p:pageNumber /&gt;]
&lt;/p:footer&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.chapters"></a>16.1.4.&nbsp;Chapters and Sections</h3></div></div><div></div></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:chapter&gt;</tt>
                                </p><p>
                                    <tt class="literal">&lt;p:section&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p>If the generated document follows a book/article structure, the
                                    <tt class="literal">p:chapter</tt> and <tt class="literal">p:section</tt> tags can be used to
                                    provide the necessary structure. Sections can only be used inside of chapters, but
                                    they may be nested arbitrarily deep. Most PDF viewers provide easy navigation
                                    between chapters and sections in a document. </p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">alignment</tt> &#8212; The alignment of the header/footer
                                            box section. (see <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for alignment values)</p></li><li><p><tt class="literal">number</tt> &#8212; The chapter number. Every chapter
                                            should be assigned a chapter number.</p></li><li><p><tt class="literal">numberDepth</tt> &#8212; The depth of numbering for
                                            section. All sections are numbered relative to their surrounding
                                            chapter/sections. The fourth section of of the first section of chapter
                                            three would be section 3.1.4, if displayed at the default number depth of
                                            three. To omit the chapter number, a number depth of 2 should be used. In
                                            that case, the section number would be displayed as 1.4.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:document xmlns:p="http://jboss.com/products/seam/pdf"
            title="Hello"&gt;

   &lt;p:chapter number="1"&gt;
      &lt;p:title&gt;&lt;p:paragraph&gt;Hello&lt;/p:paragraph&gt;&lt;/p:title&gt;
      &lt;p:paragraph&gt;Hello #{user.name}!&lt;/p:paragraph&gt;
   &lt;/p:chapter&gt;

   &lt;p:chapter number="2"&gt;
      &lt;p:title&gt;&lt;p:paragraph&gt;Goodbye&lt;/p:paragraph&gt;&lt;/p:title&gt;
      &lt;p:paragraph&gt;Goodbye #{user.name}.&lt;/p:paragraph&gt;
   &lt;/p:chapter&gt;

&lt;/p:document&gt; </pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:header&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p>Any chapter or section can contain a <tt class="literal">p:title</tt>. The title will be
                                    displayed next to the chapter/section number. The body of the title may contain raw
                                    text or may be a <tt class="literal">p:paragraph</tt>. </p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.list"></a>16.1.5.&nbsp;Lists</h3></div></div><div></div></div><p>List structures can be displayed using the <tt class="literal">p:list</tt> and <tt class="literal">p:listItem</tt>
                tags. Lists may contain arbitrarily-nested sublists. List items may not be used outside of a list. he
                following document uses the <tt class="literal">ui:repeat</tt> tag to to display a list of values retrieved
                from a Seam component. </p><pre class="programlisting">&lt;p:document xmlns:p="http://jboss.com/products/seam/pdf"
            xmlns:ui="http://java.sun.com/jsf/facelets"
            title="Hello"&gt;
   &lt;p:list style="numbered"&gt;
      &lt;ui:repeat value="#{documents}" var="doc"&gt;
         &lt;p:listItem&gt;#{doc.name}&lt;/p:listItem&gt;
      &lt;/ui:repeat&gt;
   &lt;/p:list&gt;
&lt;/p:document&gt;</pre><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:list&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">style</tt> &#8212; The ordering/bulleting style of list.
                                            One of: <tt class="literal">NUMBERED</tt>, <tt class="literal">LETTERED</tt>,
                                                <tt class="literal">GREEK</tt>, <tt class="literal">ROMAN</tt>,
                                                <tt class="literal">ZAPFDINGBATS</tt>, <tt class="literal">ZAPFDINGBATS_NUMBER</tt>.
                                            If no style is given, the list items are bulleted.</p></li><li><p><tt class="literal">listSymbol</tt> &#8212; For bulleted lists, specifies
                                            the bullet symbol. </p></li><li><p><tt class="literal">indent</tt> &#8212; The indentation level of the
                                        list.</p></li><li><p><tt class="literal">lowerCase</tt> &#8212; For list styles using letters,
                                            indicates whether the letters should be lower case.</p></li><li><p><tt class="literal">charNumber</tt> &#8212; For ZAPFDINGBATS, indicates the
                                            character code of the bullet character.</p></li><li><p><tt class="literal">numberType</tt> &#8212; For ZAPFDINGBATS_NUMBER,
                                            indicates the numbering style.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:list style="numbered"&gt;
  &lt;ui:repeat value="#{documents}" var="doc"&gt;
    &lt;p:listItem&gt;#{doc.name}&lt;/p:listItem&gt;
  &lt;/ui:repeat&gt;
&lt;/p:list&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:listItem&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:listItem</tt> supports the following attributes:</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">alignment</tt> &#8212; The alignment of the header/footer
                                            box section. (see <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for alignment values)</p></li><li><p><tt class="literal">alignment</tt> &#8212; The alignment of the list item.
                                            (See <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for possible values)</p></li><li><p><tt class="literal">indentationLeft</tt> &#8212; The left indentation
                                            amount.</p></li><li><p><tt class="literal">indentationRight</tt> &#8212; The right indentation
                                            amount.</p></li><li><p><tt class="literal">listSymbol</tt> &#8212; Overrides the default list
                                            symbol for this list item.</p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">...</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.tables"></a>16.1.6.&nbsp;Tables</h3></div></div><div></div></div><p>Table structures can be created using the <tt class="literal">p:table</tt> and <tt class="literal">p:cell</tt>
                tags. Unlike many table structures, there is no explicit row declaration. If a table has 3 columns, then
                every 3 cells will automatically form a row. Header and footer rows can be declared, and the headers and
                footers will be repeated in the event a table structure spans multiple pages.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:table&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:table</tt> supports the following attributes.</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">columns</tt> &#8212; The number of columns (cells) that
                                            make up a table row.</p></li><li><p><tt class="literal">widths</tt> &#8212; The relative widths of each column.
                                            There should be one value for each column. For example: widths="2 1 1" would
                                            indicate that there are 3 columns and the first column should be twice the
                                            size of the second and third column.</p></li><li><p><tt class="literal">headerRows</tt> &#8212; The initial number of rows which
                                            are considered to be headers or footer rows and should be repeated if the
                                            table spans multiple pages. </p></li><li><p><tt class="literal">footerRows</tt> &#8212; The number of rows that are
                                            considered to be footer rows. This value is subtracted from the
                                                <tt class="literal">headerRows</tt> value. If document has 2 rows which make
                                            up the header and one row that makes up the footer,
                                            <tt class="literal">headerRows</tt> should be set to 3 and
                                            <tt class="literal">footerRows</tt> should be set to 1</p></li><li><p><tt class="literal">widthPercentage</tt> &#8212; The percentage of the page
                                            width that the table spans.</p></li><li><p><tt class="literal">horizontalAlignment</tt> &#8212; The horizontal
                                            alignment of the table. (See <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for possible
                                            values)</p></li><li><p>
                                            <tt class="literal">skipFirstHeader</tt>
                                        </p></li><li><p>
                                            <tt class="literal">runDirection</tt>
                                        </p></li><li><p>
                                            <tt class="literal">lockedWidth</tt>
                                        </p></li><li><p>
                                            <tt class="literal">splitRows</tt>
                                        </p></li><li><p><tt class="literal">spacingBefore</tt> &#8212; The blank space to be
                                            inserted before the element.</p></li><li><p><tt class="literal">spacingAfter</tt> &#8212; The blank space to be inserted
                                            after the element.</p></li><li><p>
                                            <tt class="literal">extendLastRow</tt>
                                        </p></li><li><p>
                                            <tt class="literal">headersInEvent</tt>
                                        </p></li><li><p>
                                            <tt class="literal">splitLate</tt>
                                        </p></li><li><p>
                                            <tt class="literal">keepTogether</tt>
                                        </p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:table columns="3" headerRows="1"&gt;
  &lt;p:cell&gt;name&lt;/p:cell&gt;
  &lt;p:cell&gt;owner&lt;/p:cell&gt;
  &lt;p:cell&gt;size&lt;/p:cell&gt;
  &lt;ui:repeat value="#{documents}" var="doc"&gt;
    &lt;p:cell&gt;#{doc.name}&lt;/p:cell&gt;
    &lt;p:cell&gt;#{doc.user.name}&lt;/p:cell&gt;
    &lt;p:cell&gt;#{doc.size}&lt;/p:cell&gt;
  &lt;/ui:repeat&gt;
&lt;/p:table&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                    <tt class="literal">&lt;p:cell&gt;</tt>
                                </p></td><td valign="top"><p>
                                    <span class="emphasis"><em>Description</em></span>
                                </p><p><tt class="literal">p:cell</tt> supports the following attributes.</p><p>
                                    <span class="emphasis"><em>Attributes</em></span>
                                </p><div class="itemizedlist"><ul type="disc"><li><p>
                                            <tt class="literal">colspan</tt> &#8212; Cells can span more than one column
                                            by declaring a <tt class="literal">colspan</tt> greater than 1. Tables do not have
                                            the ability to span across multiple rows. </p></li><li><p><tt class="literal">horizontalAlignment</tt> &#8212; The horizontal
                                            alignment of the cell. (see <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for possible
                                            values)</p></li><li><p><tt class="literal">verticalAlignment</tt> &#8212; The vertical alignment of
                                            the cell. (see <a href="#itext.alignment" title="16.1.7.2.&nbsp;Alignment Values">Section&nbsp;16.1.7.2, &#8220;Alignment Values&#8221;</a> for possible values)</p></li><li><p>
                                            <tt class="literal">padding</tt> &#8212; Padding on a given side can also be
                                            specified using <tt class="literal">paddingLeft</tt>,
                                            <tt class="literal">paddingRight</tt>, <tt class="literal">paddingTop</tt> and
                                                <tt class="literal">paddingBottom</tt>.</p></li><li><p>
                                            <tt class="literal">useBorderPadding</tt>
                                        </p></li><li><p>
                                            <tt class="literal">leading</tt>
                                        </p></li><li><p>
                                            <tt class="literal">multipliedLeading</tt>
                                        </p></li><li><p>
                                            <tt class="literal">indent</tt>
                                        </p></li><li><p>
                                            <tt class="literal">verticalAlignment</tt>
                                        </p></li><li><p>
                                            <tt class="literal">extraParagraphSpace</tt>
                                        </p></li><li><p>
                                            <tt class="literal">fixedHeight</tt>
                                        </p></li><li><p>
                                            <tt class="literal">noWrap</tt>
                                        </p></li><li><p>
                                            <tt class="literal">minimumHeight</tt>
                                        </p></li><li><p>
                                            <tt class="literal">followingIndent</tt>
                                        </p></li><li><p>
                                            <tt class="literal">rightIndent</tt>
                                        </p></li><li><p>
                                            <tt class="literal">spaceCharRatio</tt>
                                        </p></li><li><p>
                                            <tt class="literal">runDirection</tt>
                                        </p></li><li><p>
                                            <tt class="literal">arabicOptions</tt>
                                        </p></li><li><p>
                                            <tt class="literal">useAscender</tt>
                                        </p></li><li><p>
                                            <tt class="literal">grayFill</tt>
                                        </p></li><li><p>
                                            <tt class="literal">rotation</tt>
                                        </p></li></ul></div><p>
                                    <span class="emphasis"><em>Usage</em></span>
                                </p><pre class="programlisting">&lt;p:cell&gt;...&lt;/p:cell&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.constant"></a>16.1.7.&nbsp;Document Constants</h3></div></div><div></div></div><p>This section documents some of the constants shared by attributes on multiple tags. </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="itext.colors"></a>16.1.7.1.&nbsp;Color Values</h4></div></div><div></div></div><p>Seam documents do not yet support a full color specification. Currently, only named colors are
                    supported. They are: <tt class="literal">white</tt>, <tt class="literal">gray</tt>,
                    <tt class="literal">lightgray</tt>, <tt class="literal">darkgray</tt>, <tt class="literal">black</tt>,
                    <tt class="literal">red</tt>, <tt class="literal">pink</tt>, <tt class="literal">yellow</tt>,
                    <tt class="literal">green</tt>, <tt class="literal">magenta</tt>, <tt class="literal">cyan</tt> and
                    <tt class="literal">blue</tt>. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="itext.alignment"></a>16.1.7.2.&nbsp;Alignment Values</h4></div></div><div></div></div><p> Where alignment values are used, the Seam PDF supports the following horizontal alignment values:
                        <tt class="literal">left</tt>, <tt class="literal">right</tt>, <tt class="literal">center</tt>,
                    <tt class="literal">justify</tt> and <tt class="literal">justifyall</tt>. The vertical alignment values are
                        <tt class="literal">top</tt>, <tt class="literal">middle</tt>, <tt class="literal">bottom</tt>, and
                        <tt class="literal">baseline</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="itext.configuration"></a>16.1.8.&nbsp;Configuring iText</h3></div></div><div></div></div><p>Document generation works out of the box with no additional configuration needed. However, there are a
                few points of configuration that are needed for more serious applications. </p><p> The default implementation serves PDF documents from a generic URL,
                <tt class="literal">/seam-doc.seam</tt>. Many browsers (and users) would prefer to see URLs that contain the
                actual PDF name like <tt class="literal">/myDocument.pdf</tt>. This capability requires some configuration. To
                serve PDF files, all *.pdf resources should be mapped to the Seam Servlet Filter and to the
                DocumentStoreServlet:</p><pre class="programlisting">&lt;filter&gt;
    &lt;filter-name&gt;Seam Servlet Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.jboss.seam.servlet.SeamServletFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;Seam Servlet Filter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.pdf&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;servlet&gt;
    &lt;servlet-name&gt;Document Store Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.seam.pdf.DocumentStoreServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Document Store Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.pdf&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre><p> The <tt class="literal">useExtensions</tt> option on the document store component completes the
                functionality by instructing the document store to generate URLs with the correct filename extension for
                the document type being generated. </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:pdf="http://jboss.com/products/seam/pdf"&gt;
    &lt;pdf:documentStore useExtensions="true" /&gt;
&lt;/components&gt;</pre><p> Generated documents are stored in conversation scope and will expire when the conversation ends. At
                that point, references to the document will be invalid. To You can specify a default view to be shown
                when a document does not exist using the <tt class="literal">errorPage</tt> property of the documentStore. </p><pre class="programlisting">&lt;pdf:documentStore useExtensions="true" errorPage="/pdfMissing.seam" /&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="itext.charting"></a>16.2.&nbsp;Charting</h2></div></div><div></div></div><div class="informaltable"><a name="itext.barchart"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:barchart&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>Displays a bar chart.</p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">borderVisible</tt> &#8212; Controls whether or not a border is
                                        displayed around the entire chart. </p></li><li><p>
                                        <tt class="literal">borderPaint</tt> &#8212; The color of the border, if visible;
                                    </p></li><li><p>
                                        <tt class="literal">borderBackgroundPaint</tt> &#8212; The default background
                                        color of the chart. </p></li><li><p>
                                        <tt class="literal">borderStroke</tt> &#8212; </p></li><li><p>
                                        <tt class="literal">domainAxisLabel</tt> &#8212; The text label for the domain
                                        axis. </p></li><li><p>
                                        <tt class="literal">domainAxisPaint</tt> &#8212; The color of the domain axis
                                        label. </p></li><li><p>
                                        <tt class="literal">domainGridlinesVisible</tt>&#8212; Controls whether or not
                                        gridlines for the domain axis are shown on the chart. </p></li><li><p>
                                        <tt class="literal">domainGridlinePaint</tt>&#8212; The color of the domain
                                        gridlines, if visible. </p></li><li><p>
                                        <tt class="literal">domainGridlineStroke</tt> &#8212; The stroke style of the
                                        domain gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">height</tt> &#8212; The height of the chart. </p></li><li><p>
                                        <tt class="literal">width</tt> &#8212; The width of the chart. </p></li><li><p>
                                        <tt class="literal">is3D</tt> &#8212; A boolean value indicating that the chart
                                        should be rendered in 3D instead of 2D. </p></li><li><p>
                                        <tt class="literal">legend</tt> &#8212; A boolean value indicating whether or not
                                        the chart should include a legend. </p></li><li><p>
                                        <tt class="literal">legendItemPaint</tt>&#8212; The default color of the text
                                        labels in the legend. </p></li><li><p>
                                        <tt class="literal">legendItemBackgoundPaint</tt>&#8212; The background color for
                                        the legend, if different from the chart background color.</p></li><li><p>
                                        <tt class="literal">orientation</tt> &#8212; The orientation of the plot, either
                                            <tt class="code">vertical</tt> (the default) or <tt class="code">horizontal</tt>. </p></li><li><p>
                                        <tt class="literal">plotBackgroundPaint</tt>&#8212; The color of the plot
                                        background.</p></li><li><p>
                                        <tt class="literal">plotBackgroundAlpha</tt>&#8212; The alpha (transparency) level
                                        of the plot background. It should be a number between 0 (completely transparent)
                                        and 1 (completely opaque). </p></li><li><p>
                                        <tt class="literal">plotForegroundAlpha</tt>&#8212; The alpha (transparency) level
                                        of the plot. It should be a number between 0 (completely transparent) and 1
                                        (completely opaque). </p></li><li><p>
                                        <tt class="literal">plotOutlinePaint</tt>&#8212; The color of the range gridlines,
                                        if visible. </p></li><li><p>
                                        <tt class="literal">plotOutlineStroke</tt> &#8212; The stroke style of the range
                                        gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">rangeAxisLabel</tt> &#8212; The text label for the range axis.
                                    </p></li><li><p>
                                        <tt class="literal">rangeAxisPaint</tt> &#8212; The color of the range axis label.
                                    </p></li><li><p>
                                        <tt class="literal">rangeGridlinesVisible</tt>&#8212; Controls whether or not
                                        gridlines for the range axis are shown on the chart. </p></li><li><p>
                                        <tt class="literal">rangeGridlinePaint</tt>&#8212; The color of the range
                                        gridlines, if visible. </p></li><li><p>
                                        <tt class="literal">rangeGridlineStroke</tt> &#8212; The stroke style of the range
                                        gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">title</tt> &#8212; The chart title text. </p></li><li><p>
                                        <tt class="literal">titlePaint</tt>&#8212; The color of the chart title text.
                                    </p></li><li><p>
                                        <tt class="literal">titleBackgroundPaint</tt>&#8212; The background color around
                                        the chart title.</p></li><li><p>
                                        <tt class="literal">width</tt> &#8212; The width of the chart. </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">
&lt;p:barchart title="Bar Chart" legend="true"
            width="500" height="500"&gt;
    &lt;p:series key="Last Year"&gt;
        &lt;p:data columnKey="Joe" value="100" /&gt;
        &lt;p:data columnKey="Bob" value="120" /&gt;
    &lt;/p:series&gt;        &lt;p:series key="This Year"&gt;
        &lt;p:data columnKey="Joe" value="125" /&gt;
        &lt;p:data columnKey="Bob" value="115" /&gt;
    &lt;/p:series&gt;
&lt;/p:barchart&gt;                                
                            </pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.linechart"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:linechart&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>Displays a line chart.</p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">borderVisible</tt> &#8212; Controls whether or not a border is
                                        displayed around the entire chart. </p></li><li><p>
                                        <tt class="literal">borderPaint</tt> &#8212; The color of the border, if visible;
                                    </p></li><li><p>
                                        <tt class="literal">borderBackgroundPaint</tt> &#8212; The default background
                                        color of the chart. </p></li><li><p>
                                        <tt class="literal">borderStroke</tt> &#8212; </p></li><li><p>
                                        <tt class="literal">domainAxisLabel</tt> &#8212; The text label for the domain
                                        axis. </p></li><li><p>
                                        <tt class="literal">domainAxisPaint</tt> &#8212; The color of the domain axis
                                        label. </p></li><li><p>
                                        <tt class="literal">domainGridlinesVisible</tt>&#8212; Controls whether or not
                                        gridlines for the domain axis are shown on the chart. </p></li><li><p>
                                        <tt class="literal">domainGridlinePaint</tt>&#8212; The color of the domain
                                        gridlines, if visible. </p></li><li><p>
                                        <tt class="literal">domainGridlineStroke</tt> &#8212; The stroke style of the
                                        domain gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">height</tt> &#8212; The height of the chart. </p></li><li><p>
                                        <tt class="literal">width</tt> &#8212; The width of the chart. </p></li><li><p>
                                        <tt class="literal">is3D</tt> &#8212; A boolean value indicating that the chart
                                        should be rendered in 3D instead of 2D. </p></li><li><p>
                                        <tt class="literal">legend</tt> &#8212; A boolean value indicating whether or not
                                        the chart should include a legend. </p></li><li><p>
                                        <tt class="literal">legendItemPaint</tt>&#8212; The default color of the text
                                        labels in the legend. </p></li><li><p>
                                        <tt class="literal">legendItemBackgoundPaint</tt>&#8212; The background color for
                                        the legend, if different from the chart background color.</p></li><li><p>
                                        <tt class="literal">orientation</tt> &#8212; The orientation of the plot, either
                                            <tt class="code">vertical</tt> (the default) or <tt class="code">horizontal</tt>. </p></li><li><p>
                                        <tt class="literal">plotBackgroundPaint</tt>&#8212; The color of the plot
                                        background.</p></li><li><p>
                                        <tt class="literal">plotBackgroundAlpha</tt>&#8212; The alpha (transparency) level
                                        of the plot background. It should be a number between 0 (completely transparent)
                                        and 1 (completely opaque). </p></li><li><p>
                                        <tt class="literal">plotForegroundAlpha</tt>&#8212; The alpha (transparency) level
                                        of the plot. It should be a number between 0 (completely transparent) and 1
                                        (completely opaque). </p></li><li><p>
                                        <tt class="literal">plotOutlinePaint</tt>&#8212; The color of the range gridlines,
                                        if visible. </p></li><li><p>
                                        <tt class="literal">plotOutlineStroke</tt> &#8212; The stroke style of the range
                                        gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">rangeAxisLabel</tt> &#8212; The text label for the range axis.
                                    </p></li><li><p>
                                        <tt class="literal">rangeAxisPaint</tt> &#8212; The color of the range axis label.
                                    </p></li><li><p>
                                        <tt class="literal">rangeGridlinesVisible</tt>&#8212; Controls whether or not
                                        gridlines for the range axis are shown on the chart. </p></li><li><p>
                                        <tt class="literal">rangeGridlinePaint</tt>&#8212; The color of the range
                                        gridlines, if visible. </p></li><li><p>
                                        <tt class="literal">rangeGridlineStroke</tt> &#8212; The stroke style of the range
                                        gridleines, if visible. </p></li><li><p>
                                        <tt class="literal">title</tt> &#8212; The chart title text. </p></li><li><p>
                                        <tt class="literal">titlePaint</tt>&#8212; The color of the chart title text.
                                    </p></li><li><p>
                                        <tt class="literal">titleBackgroundPaint</tt>&#8212; The background color around
                                        the chart title.</p></li><li><p>
                                        <tt class="literal">width</tt> &#8212; The width of the chart. </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">&lt;p:linechart title="Line Chart"
            width="500" height="500"&gt;
    &lt;p:series key="Prices"&gt;
        &lt;p:data columnKey="2003" value="7.36" /&gt;
        &lt;p:data columnKey="2004" value="11.50" /&gt;
        &lt;p:data columnKey="2005" value="34.625" /&gt;
        &lt;p:data columnKey="2006" value="76.30" /&gt;
        &lt;p:data columnKey="2007" value="85.05" /&gt;
    &lt;/p:series&gt;
&lt;/p:linechart&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.piechart"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:piechart&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>Displays a pie chart.</p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">title</tt>
                                    </p></li><li><p>
                                        <tt class="literal">label</tt>
                                    </p></li><li><p>
                                        <tt class="literal">legend</tt>
                                    </p></li><li><p>
                                        <tt class="literal">is3D</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelLinkMargin</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelLinkPaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelLinkStroke</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelLinksVisible</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelOutlinePaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelOutlineStroke</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelShadowPaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelPaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelGap</tt>
                                    </p></li><li><p>
                                        <tt class="literal">labelBackgroundPaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">startAngle</tt>
                                    </p></li><li><p>
                                        <tt class="literal">circular</tt>
                                    </p></li><li><p>
                                        <tt class="literal">direction</tt>
                                    </p></li><li><p>
                                        <tt class="literal">sectionOutlinePaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">sectionOutlineStroke</tt>
                                    </p></li><li><p>
                                        <tt class="literal">sectionOutlinesVisible</tt>
                                    </p></li><li><p>
                                        <tt class="literal">baseSectionOutlinePaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">baseSectionPaint</tt>
                                    </p></li><li><p>
                                        <tt class="literal">baseSectionOutlineStroke</tt>
                                    </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting"></pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.series"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:series&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>Category data can be broken down into series. The series tag is used to categorize a
                                set of data with a series and apply styling to the entire series. </p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">key</tt> &#8212; The series name. </p></li><li><p>
                                        <tt class="literal">seriesPaint</tt> &#8212; The color of each item in the series
                                    </p></li><li><p>
                                        <tt class="literal">seriesOutlinePaint</tt> &#8212; The outline color for each
                                        item in the series. </p></li><li><p>
                                        <tt class="literal">seriesOutlineStroke</tt> &#8212; The stroke used to draw each
                                        item in the series. </p></li><li><p>
                                        <tt class="literal">seriesVisible</tt> &#8212; A boolean indicating if the series
                                        should be displayed. </p></li><li><p>
                                        <tt class="literal">seriesVisibleInLegend</tt> &#8212; A boolean indiciating if
                                        the series should be listed in the legend. </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">&lt;p:series key="data1"&gt;
    &lt;ui:repeat value="#{data.pieData1}" var="item"&gt;
        &lt;p:data columnKey="#{item.name}" value="#{item.value}" /&gt;
    &lt;/ui:repeat&gt;
&lt;/p:series&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.chartdata"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:data&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>The data tag describes each data point to be displayed in the graph.</p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">key</tt> &#8212; The name of the data item. </p></li><li><p>
                                        <tt class="literal">series</tt> &#8212; The series name, when not embedded inside
                                        a <tt class="code">&lt;p:series&gt;</tt>. </p></li><li><p>
                                        <tt class="literal">value</tt> &#8212; The numeric data value. </p></li><li><p>
                                        <tt class="literal">explodedPercent</tt> &#8212; For pie charts, indicates how
                                        exploded a from the pie a piece is. </p></li><li><p>
                                        <tt class="literal">sectionOutlinePaint</tt> &#8212; For bar charts, the color of the section outline.</p></li><li><p>
                                        <tt class="literal">sectionOutlineStroke</tt> &#8212; For bar charts, the stroke type for the section outline.</p></li><li><p>
                                        <tt class="literal">sectionPaint</tt> &#8212; For bar charts, the color of the section.</p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">&lt;p:data key="foo" value="20" sectionPaint="#111111" 
        explodedPercent=".2" /&gt;
&lt;p:data key="bar" value="30" sectionPaint="#333333" /&gt;
&lt;p:data key="baz" value="40" sectionPaint="#555555" 
        sectionOutlineStroke="my-dot-style" /&gt;</pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.color"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:color&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>The color component declares a color or gradient than can be referenced when drawing
                                filled shapes. </p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">color</tt> &#8212; The color value. For gradient colors, this
                                        the starting color. <a href="#itext.colors" title="16.1.7.1.&nbsp;Color Values">Section&nbsp;16.1.7.1, &#8220;Color Values&#8221;</a>
                                    </p></li><li><p>
                                        <tt class="literal">color2</tt> &#8212; For gradient colors, this is the color
                                        that ends the gradient. </p></li><li><p>
                                        <tt class="literal">point</tt> &#8212; The co-ordinates where the gradient color
                                        begins. </p></li><li><p>
                                        <tt class="literal">point2</tt> &#8212; The co-ordinates where the gradient color
                                        ends. </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">&lt;p:color id="foo" color="#0ff00f"/&gt;
&lt;p:color id="bar" color="#ff00ff" color2="#00ff00" 
                  point="50 50" point2="300 300"/&gt;  </pre></td></tr></tbody></table></div><div class="informaltable"><a name="itext.stroke"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:stroke&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p>Describes a stroke used to draw lines in a chart.</p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">width</tt> &#8212; The width of the stroke. </p></li><li><p><tt class="literal">cap</tt> &#8212; The line cap type. Valid values are
                                            <tt class="literal">butt</tt>, <tt class="literal">round</tt> and
                                        <tt class="literal">square</tt></p></li><li><p><tt class="literal">join</tt> &#8212; The line join type. Valid values are
                                            <tt class="literal">miter</tt>, <tt class="literal">round</tt> and
                                        <tt class="literal">bevel</tt></p></li><li><p>
                                        <tt class="literal">miterLimit</tt> &#8212; For miter joins, this value is the
                                        limit of the size of the join. </p></li><li><p>
                                        <tt class="literal">dash</tt> &#8212; The dash value sets the dash pattern to be
                                        used to draw the line. The space separated integers indicate the length of each
                                        alternating drawn and undrawn segments. </p></li><li><p>
                                        <tt class="literal">dashPhase</tt> &#8212; The dash phase indicates the offset
                                        into the dash pattern that the the line should be drawn with. </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting">&lt;p:stroke id="dot2" width="2" cap="round" join="bevel" dash="2 3" /&gt;                            </pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="itext.barcodes"></a>16.3.&nbsp;Bar codes</h2></div></div><div></div></div><p>...</p><div class="informaltable"><a name="itext.barcode"></a><table border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
                                <tt class="literal">&lt;p:barcode&gt;</tt>
                            </p></td><td valign="top"><p>
                                <span class="emphasis"><em>Description</em></span>
                            </p><p></p><p>
                                <span class="emphasis"><em>Attributes</em></span>
                            </p><div class="itemizedlist"><ul type="disc"><li><p>
                                        <tt class="literal">type</tt>
                                    </p></li><li><p>
                                        <tt class="literal">code</tt>
                                    </p></li><li><p>
                                        <tt class="literal">xpos</tt>
                                    </p></li><li><p>
                                        <tt class="literal">ypos</tt>
                                    </p></li><li><p>
                                        <tt class="literal">rotDegrees</tt>
                                    </p></li><li><p>
                                        <tt class="literal">barHeight</tt>
                                    </p></li><li><p>
                                        <tt class="literal">textSize</tt>
                                    </p></li><li><p>
                                        <tt class="literal">minBarWidth</tt>
                                    </p></li><li><p>
                                        <tt class="literal">barMultiplier</tt>
                                    </p></li></ul></div><p>
                                <span class="emphasis"><em>Usage</em></span>
                            </p><pre class="programlisting"></pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="itext.links"></a>16.4.&nbsp;Further documentation</h2></div></div><div></div></div><p>For further information on iText, see:</p><p>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <a href="http://www.lowagie.com/iText/" target="_top">iText Home Page</a>
                    </p></li><li><p>
                        <a href="http://www.manning.com/lowagie/" target="_top">iText in Action</a>
                    </p></li></ul></div><p>

        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mail"></a>Chapter&nbsp;17.&nbsp;Email</h2></div></div><div></div></div><p>
    Seam now includes an optional components for templating and sending emails.
  </p><p>
    Email support is provided by <tt class="literal">jboss-seam-mail.jar</tt>. This 
    JAR contains the mail JSF controls, which are used to construct emails,
    and the <tt class="literal">mailSession</tt> manager component. 
  </p><p>
    The examples/mail project contains an example of the email support in 
    action. It demonstrates proper packaging, and it contains a number of 
    example that demonstrate the key features currently supported. 
  </p><p>
    You can also test your mail's using Seam's integration testing environment.
    See <a href="#testing.mail" title="31.3.2.&nbsp;Integration Testing Seam Mail">Section&nbsp;31.3.2, &#8220;Integration Testing Seam Mail&#8221;</a>.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10698"></a>17.1.&nbsp;Creating a message</h2></div></div><div></div></div><p>
      You don't need to learn a whole new templating language to use Seam Mail 
      &#8212; an email is just facelet!
    </p><pre class="programlisting">&lt;m:message xmlns="http://www.w3.org/1999/xhtml"
    xmlns:m="http://jboss.com/products/seam/mail"
    xmlns:h="http://java.sun.com/jsf/html"&gt;
  
    &lt;m:from name="Peter" address="peter@example.com" /&gt;
    &lt;m:to name="#{person.firstname} #{person.lastname}"&gt;#{person.address}&lt;/m:to&gt;
    &lt;m:subject&gt;Try out Seam!&lt;/m:subject&gt;
    
    &lt;m:body&gt;
        &lt;p&gt;&lt;h:outputText value="Dear #{person.firstname}" /&gt;,&lt;/p&gt;
        &lt;p&gt;You can try out Seam by visiting 
        &lt;a href="http://labs.jboss.com/jbossseam"&gt;http://labs.jboss.com/jbossseam&lt;/a&gt;.&lt;/p&gt;
        &lt;p&gt;Regards,&lt;/p&gt;
        &lt;p&gt;Pete&lt;/p&gt;
    &lt;/m:body&gt;
    
&lt;/m:message&gt;</pre><p>
      The <tt class="literal">&lt;m:message&gt;</tt> tag wraps the whole message, 
      and tells Seam to start rendering an email.  Inside the <tt class="literal">&lt;m:message&gt;</tt>
      tag we use an <tt class="literal">&lt;m:from&gt;</tt> tag to set who the 
      message is from, a <tt class="literal">&lt;m:to&gt;</tt> tag to	specify a 
      sender (notice how we use EL as we would in a normal facelet), and a 
      <tt class="literal">&lt;m:subject&gt;</tt> tag.
    </p><p>
      The <tt class="literal">&lt;m:body&gt;</tt> tag wraps the body of the email. 
      You can use regular HTML tags inside the body as well as JSF components.
    </p><p>
      So, now you have your email template, how do you go about sending it? 
      Well, at the end of rendering the <tt class="literal">m:message</tt> the 
      <tt class="literal">mailSession</tt> is called to send the email, so all you 
      have to do is ask Seam to render the view:
    </p><pre class="programlisting">@In(create=true)
private Renderer renderer;
   
public void send() {
    try {
       renderer.render("/simple.xhtml");
       facesMessages.add("Email sent successfully");
   } 
   catch (Exception e) {
       facesMessages.add("Email sending failed: " + e.getMessage());
   }
}</pre><p>
      If, for example, you entered an invalid email address, then an exception 
      would be thrown, which is caught and then displayed to the user.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10739"></a>17.1.1.&nbsp;Attachments</h3></div></div><div></div></div><p>
        Seam makes it easy to attach files to an email.  It supports most of 
        the standard java types used when working with files.
      </p><p>
        If you wanted to email the <tt class="literal">jboss-seam-mail.jar</tt>:
      </p><pre class="programlisting">&lt;m:attachment value="/WEB-INF/lib/jboss-seam-mail.jar"/&gt;</pre><p>
        Seam will load the file from the classpath, and attach it to the email.
        By default it would be attached as <tt class="literal">jboss-seam-mail.jar</tt>;
   		if you wanted it to have another name you would just add the <tt class="literal">fileName</tt> attribute:
      </p><pre class="programlisting">&lt;m:attachment value="/WEB-INF/lib/jboss-seam-mail.jar" fileName="this-is-so-cool.jar"/&gt;</pre><p>
        You could also attach a <tt class="literal">java.io.File</tt>, a <tt class="literal">java.net.URL</tt>:
      </p><pre class="programlisting">&lt;m:attachment value="#{numbers}"/&gt;</pre><p>
        Or a <tt class="literal">byte[]</tt> or a <tt class="literal">java.io.InputStream</tt>:
      </p><pre class="programlisting">&lt;m:attachment value="#{person.photo}" contentType="image/png"/&gt;</pre><p>
        You'll notice that for a <tt class="literal">byte[]</tt> and a <tt class="literal">java.io.InputStream</tt>
        you need to specify the MIME type of the attachment (as that 
        information is not carried as part of the file).
      </p><p>
        And it gets even better, you can attach a Seam generated PDF, or any 
        standard JSF view, just by wrapping a <tt class="literal">&lt;m:attachment&gt;</tt> 
        around the normal tags you would use:
      </p><pre class="programlisting">&lt;m:attachment fileName="tiny.pdf"&gt;
    &lt;p:document&gt;                                                      
        A very tiny PDF                                                                                                
    &lt;/p:document&gt;
&lt;/m:attachment&gt;</pre><p>
        If you had a set of files you wanted to attach (for example a set of 
        pictures loaded from a database) you can just use a <tt class="literal">&lt;ui:repeat&gt;</tt>:
      </p><pre class="programlisting">&lt;ui:repeat value="#{people}" var="person"&gt;
    &lt;m:attachment value="#{person.photo}" contentType="image/jpeg" fileName="#{person.firstname}_#{person.lastname}.jpg"/&gt;
&lt;/ui:repeat&gt;</pre><p>
        And if you want to display an attached image inline:
      </p><pre class="programlisting">&lt;m:attachment 
    value="#{person.photo}" 
    contentType="image/jpeg" 
    fileName="#{person.firstname}_#{person.lastname}.jpg" 
    status="personPhoto" 
    disposition="inline" /&gt;
&lt;img src="cid:#{personPhoto.contentId}" /&gt;</pre><p>
        You may be wondering what <tt class="literal">cid:#{...}</tt> does. Well, the
        IETF specified that by putting this as the src for your image, the 
        attachments will be looked at when trying to locate the image (the 
        <tt class="literal">Content-ID</tt>'s must match) &#8212; magic!
      </p><p>
        You must declare the attachment before trying to access the status object.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10817"></a>17.1.2.&nbsp;HTML/Text alternative part</h3></div></div><div></div></div><p>
        Whilst most mail readers nowadays support HTML, some don't, so you can 
        add a plain text alternative to your email body:
      </p><pre class="programlisting">&lt;m:body&gt;
    &lt;f:facet name="alternative"&gt;Sorry, your email reader can't show our fancy email, 
please go to http://labs.jboss.com/jbossseam to explore Seam.&lt;/f:facet&gt;
&lt;/m:body&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10824"></a>17.1.3.&nbsp;Multiple recipients</h3></div></div><div></div></div><p>
        Often you'll want to send an email to a group of recipients (for 
        example your users).  All of the recipient mail tags can be placed 
        inside a <tt class="literal">&lt;ui:repeat&gt;</tt>:
      </p><pre class="programlisting">&lt;ui:repeat value="#{allUsers} var="user"&gt;
    &lt;m:to name="#{user.firstname} #{user.lastname}" address="#{user.emailAddress}" /&gt;
&lt;/ui:repeat&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10834"></a>17.1.4.&nbsp;Multiple messages</h3></div></div><div></div></div><p>
        Sometimes, however, you need to send a slightly different message to 
        each recipient (e.g. a password	reset).  The best way to do this is to 
        place the whole message inside a <tt class="literal">&lt;ui:repeat&gt;</tt>:
      </p><pre class="programlisting">&lt;ui:repeat value="#{people}" var="p"&gt;
    &lt;m:message&gt;
        &lt;m:from name="#{person.firstname} #{person.lastname}"&gt;#{person.address}&lt;/m:from&gt;
        &lt;m:to name="#{p.firstname}"&gt;#{p.address}&lt;/m:to&gt;
            ...
    &lt;/m:message&gt;
&lt;/ui:repeat&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10844"></a>17.1.5.&nbsp;Templating</h3></div></div><div></div></div><p>
        The mail templating example shows that facelets templating Just Works 
        with the Seam mail tags.
      </p><p>
        Our <tt class="literal">template.xhtml</tt> contains:
      </p><pre class="programlisting">&lt;m:message&gt;
   &lt;m:from name="Seam" address="do-not-reply@jboss.com" /&gt;
   &lt;m:to name="#{person.firstname} #{person.lastname}"&gt;#{person.address}&lt;/m:to&gt;
   &lt;m:subject&gt;#{subject}&lt;/m:subject&gt;
   &lt;m:body&gt;
       &lt;html&gt;
           &lt;body&gt;
               &lt;ui:insert name="body"&gt;This is the default body, specified by the template.&lt;/ui:insert&gt;
           &lt;/body&gt;
       &lt;/html&gt;
   &lt;/m:body&gt;
&lt;/m:message&gt;</pre><p>
        Our <tt class="literal">templating.xhtml</tt> contains:
      </p><pre class="programlisting">&lt;ui:param name="subject" value="Templating with Seam Mail"/&gt;
&lt;ui:define name="body"&gt;
    &lt;p&gt;This example demonstrates that you can easily use &lt;i&gt;facelets templating&lt;/i&gt; in email!&lt;/p&gt;
&lt;/ui:define&gt;</pre><p>
        You can also use facelets source tags in your email, but you must place
        them in a jar in <tt class="literal">WEB-INF/lib</tt> - referencing the 
        <tt class="literal">.taglib.xml</tt> from <tt class="literal">web.xml</tt> isn't 
        reliable when using Seam Mail (if you send your mail asynchrounously 
        Seam Mail doesn't have access to the full JSF or Servlet context, and 
        so doesn't know about <tt class="literal">web.xml</tt> configuration 
        parameters).
      </p><p>
        If you do need more configure Facelets or JSF when sending mail, you'll
        need to override the Renderer component and do the configuration 
        programmatically - only for advanced users!
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10879"></a>17.1.6.&nbsp;Internationalisation</h3></div></div><div></div></div><p>
        Seam supports sending internationalised messages.  By default, the 
        encoding provided by JSF is used, but this can be overridden on the 
        template:
      </p><pre class="programlisting">&lt;m:message charset="UTF-8"&gt;
   ...
&lt;/m:message&gt;</pre><p>
        The body, subject and recipient (and from) name will be encoded.  
        You'll need to make sure facelets uses the correct charset for parsing
        your pages by setting encoding of the template:
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10890"></a>17.1.7.&nbsp;Other Headers</h3></div></div><div></div></div><p>
        Sometimes you'll want to add other headers to your email.  Seam 
        provides support for some (see <a href="#mail.tags" title="17.5.&nbsp;Tags">Section&nbsp;17.5, &#8220;Tags&#8221;</a>). For 
        example, we can set the importance of the email, and ask for a read 
        receipt:
      </p><pre class="programlisting">&lt;m:message xmlns:m="http://jboss.com/products/seam/mail"
    importance="low"
    requestReadReceipt="true"/&gt;</pre><p>
        Otherise you can add any header to the message using the 
        <tt class="literal">&lt;m:header&gt;</tt> tag:
      </p><pre class="programlisting">&lt;m:header name="X-Sent-From" value="JBoss Seam"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10906"></a>17.2.&nbsp;Receiving emails</h2></div></div><div></div></div><p>
      If you are using EJB then you can use a MDB (Message Driven Bean) to 
      receive email.  JBoss provides a JCA adaptor &#8212; 
      <tt class="literal">mail-ra.rar</tt> &#8212; but the version distributed with
      JBoss AS has a number of limitations (and isn't bundled in some versions)
      therefore we recommend using the <tt class="literal">mail-ra.rar</tt> 
      distributed with Seam is recommended (it's in the <tt class="literal">mail</tt>
      directory in the Seam bundle).  <tt class="literal">mail-ra.rar</tt> should 
      be placed in <tt class="literal">$JBOSS_HOME/server/default/deploy</tt>; if the
      version of JBoss AS you use already has this file, replace it.
    </p><p>
      You can configure it like this:
    </p><pre class="programlisting">@MessageDriven(activationConfig={
    @ActivationConfigProperty(propertyName="mailServer", propertyValue="localhost"),
    @ActivationConfigProperty(propertyName="mailFolder", propertyValue="INBOX"),
    @ActivationConfigProperty(propertyName="storeProtocol", propertyValue="pop3"),
    @ActivationConfigProperty(propertyName="userName", propertyValue="seam"),
    @ActivationConfigProperty(propertyName="password", propertyValue="seam")
})
@ResourceAdapter("mail-ra.rar")
@Name("mailListener")
public class MailListenerMDB implements MailListener {

    @In(create=true)
    private OrderProcessor orderProcessor;

    public void onMessage(Message message) {
       // Process the message
       orderProcessor.process(message.getSubject());
    }
   
}</pre><p>
      Each message received will cause <tt class="literal">onMessage(Message message)</tt> 
      to be called.  Most Seam annotations will work inside a MDB but you 
      musn't access the persistence context.
    </p><p>
      You can find more information on<tt class="literal">mail-ra.rar</tt>
      at <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=InboundJavaMail" target="_top">http://wiki.jboss.org/wiki/Wiki.jsp?page=InboundJavaMail</a>.
    </p><p>
      If you aren't using JBoss AS you can still use <tt class="literal">mail-ra.rar</tt> 
      or you may find your application server includes a similar adapter.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10948"></a>17.3.&nbsp;Configuration</h2></div></div><div></div></div><p>
      To include Email support in your application, include <tt class="literal">jboss-seam-mail.jar</tt>
      in your <tt class="literal">WEB-INF/lib</tt> directory. If you are using JBoss 
      AS there is no further configuration needed to use Seam's email support.
      Otherwise you need to make sure you have the JavaMail API, an 
      implementation of the JavaMail API present (the API and impl used in 
      JBoss AS are distributed with seam as <tt class="literal">lib/mail.jar</tt>),
      and a copy of the Java Activation Framework (distributed with Seam as 
      <tt class="literal">lib/activation.jar</tt>.
    </p><p>
      The Seam Email module requires the use of Facelets as the view 
      technology. Future versions of the library may also support the use of 
      JSP. Additionally, it requires the use of the seam-ui package.
    </p><p>
      The <tt class="literal">mailSession</tt> component uses JavaMail to talk to a 
      'real' SMTP server.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10972"></a>17.3.1.&nbsp;<tt class="literal">mailSession</tt></h3></div></div><div></div></div><p>
        A JavaMail Session may be available via a JNDI lookup if you are 
        working in an JEE environment or you can use a Seam configured Session.
      </p><p>
        The mailSession component's properties are described in more detail in 
        <a href="#components.mail" title="28.8.&nbsp;Mail-related components">Section&nbsp;28.8, &#8220;Mail-related components&#8221;</a>.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10982"></a>17.3.1.1.&nbsp;JNDI lookup in JBoss AS</h4></div></div><div></div></div><p>
          The JBossAS <tt class="literal">deploy/mail-service.xml</tt> configures a 
          JavaMail session binding into JNDI.  The default service 
          configuration will need altering for your network.  
          <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JavaMail" target="_top">http://wiki.jboss.org/wiki/Wiki.jsp?page=JavaMail</a>
          describes the service in more detail.
        </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
    xmlns:core="http://jboss.com/products/seam/core"
    xmlns:mail="http://jboss.com/products/seam/mail"&gt;
        
    &lt;mail:mail-session session-jndi-name="java:/Mail"/&gt;
    
&lt;/components&gt;</pre><p>
          Here we tell Seam to get the mail session bound to 
          <tt class="literal">java:/Mail</tt> from JNDI.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11000"></a>17.3.1.2.&nbsp;Seam configured Session</h4></div></div><div></div></div><p>
          A mail session can be configured via <tt class="literal">components.xml</tt>.
          Here we tell Seam to use <tt class="literal">smtp.example.com</tt> as the 
          smtp server:
        </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
    xmlns:core="http://jboss.com/products/seam/core"
    xmlns:mail="http://jboss.com/products/seam/mail"&gt;
        
    &lt;mail:mail-session host="smtp.example.com"/&gt;
    
&lt;/components&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11013"></a>17.4.&nbsp;Meldware</h2></div></div><div></div></div><p>
	  Seam's mail examples use Meldware (from <a href="http://buni.org" target="_top">buni.org</a>) 
      as a mail server. Meldware is a groupware package that provides 
      <tt class="literal">SMTP</tt>, <tt class="literal">POP3</tt>, <tt class="literal">IMAP</tt>,
      webmail, a shared calendar and an graphical admin tool; it's written as a
      JEE application so can be deployed onto JBoss AS alongside your Seam
      application. 
    </p><p>
      The version of Meldware distributed with Seam (in the <tt class="literal">mail/buni-meldware</tt>
      folder is specially tailored for development - mailboxes, users and 
      aliases (email addresses) are created everytime the the application 
      deploys.  If you want to use Meldware for anything more than sending
      emails in production it's recommended you a vanilla copy. To create 
      mailboxes, users and aliaes, you can use the <tt class="literal">meldware</tt>
      component:
    </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
    xmlns:core="http://jboss.com/products/seam/core"
    xmlns:mail="http://jboss.com/products/seam/mail"&gt;
              
    &lt;mail:mail-session host="smtp.example.com"/&gt;
    
    &lt;mail:meldware&gt;
        &lt;mail:users&gt;
            &lt;value&gt;#{duke}&lt;/value&gt;
            &lt;value&gt;#{root}&lt;/value&gt;
	    &lt;/mail:users&gt;
    &lt;/mail:meldware&gt;
    
   	&lt;mail:meldware-user name="duke" username="duke" password="duke"&gt;
   	    &lt;mail:aliases&gt;
   	        &lt;value&gt;duke@jboss.org&lt;/value&gt;
   	        &lt;value&gt;duke@jboss.com&lt;/value&gt;
   	    &lt;/mail:aliases&gt;
   	&lt;mail:meldware-user name="root" username="root" password="root" administrator="true" /&gt; 
&lt;/components&gt;</pre><p>
      Here we've created two users, <tt class="literal">duke</tt>, who has two email
      addresses and an administrator with the username <tt class="literal">root</tt>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail.tags"></a>17.5.&nbsp;Tags</h2></div></div><div></div></div><p>
      Emails are generated using tags in the <tt class="literal">http://jboss.com/products/seam/mail</tt>
      namespace. Documents should always have the <tt class="literal">message</tt>
      tag at the root of the message. The message tag prepares Seam to generate
      an email.
    </p><p>
      The standard templating tags of facelets can be used as normal. Inside
      the body you can use any JSF tag; if it  requires access to external 
      resources (stylesheets, javascript) then be sure to set the 
      <tt class="literal">urlBase</tt>.
    </p><div class="variablelist"><dl><dt><span class="term">&lt;m:message&gt;</span></dt><dd><p>
	        Root tag of a mail message
	      </p><div class="itemizedlist"><ul type="disc"><li><p>
	            <tt class="literal">importance</tt> &#8212; low, normal or high.  By
                default normal, this sets the importance of the mail message.
              </p></li><li><p>
                <tt class="literal">precedence</tt> &#8212; sets the precedence of
                the message (e.g. bulk).
              </p></li><li><p>
                <tt class="literal">requestReadReceipt</tt> &#8212; by default false,
                if set, a read receipt request will be will be added, with the
                read receipt being sent to the <tt class="literal">From:</tt>
                address.
              </p></li><li><p>
                <tt class="literal">urlBase</tt> &#8212; If set, the value is
                prepended to the <tt class="literal">requestContextPath</tt> allowing
                you to use components such as
                <tt class="literal">&lt;h:graphicImage&gt;</tt> in your emails.
              </p></li></ul></div></dd><dt><span class="term">&lt;m:from&gt;</span></dt><dd><p>
            Set's the From: address for the email.  You can only have one of 
            these per email.
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                <tt class="literal">name</tt> &#8212; the name the email should come
                from.
              </p></li><li><p>
                <tt class="literal">address</tt> &#8212; the email address the email
                should come from.
              </p></li></ul></div></dd><dt><span class="term">&lt;m:replyTo&gt;</span></dt><dd><p>
              Set's the Reply-to: address for the email.  You can only have one
              of these per email.
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                 <tt class="literal">address</tt> &#8212; the email address the email
                 should come from.
               </p></li></ul></div></dd><dt><span class="term">&lt;m:to&gt;</span></dt><dd><p>
            Add a recipient to the email. Use multiple &lt;m:to&gt; tags for
            multiple recipients. This tag can be safely placed inside a repeat 
            tag such as &lt;ui:repeat&gt;.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                <tt class="literal">name</tt> &#8212; the name of the recipient.
              </p></li><li><p>
                <tt class="literal">address</tt> &#8212; the email address of the recipient.
              </p></li></ul></div></dd><dt><span class="term">&lt;m:cc&gt;</span></dt><dd><p>
              Add a cc recipient to the email. Use multiple &lt;m:cc&gt; tags
              for multiple ccs. This tag can be safely placed inside a iterator
              tag such as &lt;ui:repeat&gt;.
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">name</tt> &#8212; the name of the recipient.
                </p></li><li><p>
                  <tt class="literal">address</tt> &#8212;  the email address of the
                  recipient.
                </p></li></ul></div></dd><dt><span class="term">&lt;m:bcc&gt;</span></dt><dd><p>
              Add a bcc recipient to the email. Use multiple &lt;m:bcc&gt; 
              tags for multiple bccs. This tag can be safely placed inside a
              repeat tag such as &lt;ui:repeat&gt;.
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">name</tt> &#8212; the name of the recipient.
                </p></li><li><p>
                  <tt class="literal">address</tt> &#8212; the email address of the
                  recipient.
                </p></li></ul></div></dd><dt><span class="term">&lt;m:header&gt;</span></dt><dd><p>
              Add a header to the email (e.g. <tt class="literal">X-Sent-From: JBoss Seam</tt>)
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">name</tt> &#8212; The name of the header to 
                  add (e.g. <tt class="literal">X-Sent-From</tt>).
                </p></li><li><p>
                  <tt class="literal">value</tt> &#8212; The value of the header to
                  add (e.g. <tt class="literal">JBoss Seam</tt>).
                </p></li></ul></div></dd><dt><span class="term">&lt;m:attachment&gt;</span></dt><dd><p>
            Add an attachment to the email.
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                <tt class="literal">value</tt> &#8212; The file to attach:
              </p><div class="itemizedlist"><ul type="circle"><li><p>
                    <tt class="literal">String</tt> &#8212; A <tt class="literal">String</tt>
                     is interpreted as a path to file within the classpath
                  </p></li><li><p>
                    <tt class="literal">java.io.File</tt> &#8212; An EL expression
                    can reference a <tt class="literal">File</tt> object
                  </p></li><li><p>
                   <tt class="literal">java.net.URL</tt> &#8212; An EL expression
                   can reference a <tt class="literal">URL</tt> object
                  </p></li><li><p>
                    <tt class="literal">java.io.InputStream</tt> &#8212; An EL 
                    expression can reference an <tt class="literal">InputStream</tt>. 
                    In this case both a <tt class="literal">fileName</tt> and a 
                    <tt class="literal">contentType</tt> must be specified.
                  </p></li><li><p>
                    <tt class="literal">byte[]</tt> &#8212; An EL expression can
                    reference an <tt class="literal">byte[]</tt>. In this case both
                    a <tt class="literal">fileName</tt> and a 
                    <tt class="literal">contentType</tt> must be specified.
                  </p></li></ul></div><p>If the value attribute is ommitted:</p><div class="itemizedlist"><ul type="circle"><li><p>
                    If this tag contains a <tt class="literal">&lt;p:document&gt;</tt>
                    tag, the document described will be generated and 
                    attached to the email.  A <tt class="literal">fileName</tt>
                    should be specfied.
                  </p></li><li><p>
                    If this tag contains other JSF tags a HTML document will 
                    be generated from them and attached to the email. A 
                    <tt class="literal">fileName</tt> should be specfied.
                  </p></li></ul></div></li><li><p>
                <tt class="literal">fileName</tt> &#8212; Specify the file name to
                use for the attached file.
              </p></li><li><p>
                <tt class="literal">contentType</tt> &#8212; Specify the MIME type
                of the attached file
              </p></li></ul></div></dd><dt><span class="term">&lt;m:subject&gt;</span></dt><dd><p>
            Set's the subject for the email.
          </p></dd><dt><span class="term">&lt;m:body&gt;</span></dt><dd><p>
            Set's the body for the email.  Supports an <tt class="literal">alternative</tt>
            facet which, if an HTML email is generated can contain
            alternative text for a mail reader which doesn't support html.
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                <tt class="literal">type</tt> &#8212; If set to <tt class="literal">plain</tt>
                then a plain text email will be generated otherwise an HTML 
                email is generated.  
              </p></li></ul></div></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms"></a>Chapter&nbsp;18.&nbsp;Asynchronicity and messaging</h2></div></div><div></div></div><p>
        Seam makes it very easy to perform work asynchronously from a web request. When most people
        think of asynchronicity in Java EE, they think of using JMS. This is certainly one way to
        approach the problem in Seam, and is the right way when you have strict and well-defined
        quality of service requirements. Seam makes it easy to send and recieve JMS messages using
        Seam components.
    </p><p>
        But for many usecases, JMS is overkill. Seam layers a simple asynchronous method and event
        facility over your choice of <span class="emphasis"><em>dispatchers</em></span>:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
                <tt class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</tt> (by default)
            </p></li><li><p>
                the EJB timer service (for EJB 3.0 environments)
            </p></li><li><p>
                Quartz
            </p></li></ul></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11371"></a>18.1.&nbsp;Asynchronicity</h2></div></div><div></div></div><p>
            Asynchronous events and method calls have the same quality of service expectations as  
            the underlying dispatcher mechanism. The default dispatcher, based upon a 
            <tt class="literal">ScheduledThreadPoolExecutor</tt> performs efficiently but provides no
            support for persistent asynchronous tasks, and hence no guarantee that a task
            will ever actually be executed. If you're working in an environment that supports
            EJB 3.0, and add the following line to <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;async:timer-service-dispatcher/&gt;</pre><p>
            then your asynchronous tasks will be processed by the container's EJB timer service. If 
            you're not familiar with the Timer service, don't worry, you don't need to interact with 
            it directly if you want to use asynchronous methods in Seam. The important thing to know
            is that any good EJB 3.0 implementation will have the option of using persistent timers, 
            which gives some guarantee that the tasks will eventually be processed.
        </p><p>
            Another alternative is to use the open source Quartz library to manage asynchronous method. 
            You need to bundle the Quartz library JAR (found in the <tt class="literal">lib</tt> directory) 
            in your EAR and declare it as a Java module in <tt class="literal">application.xml</tt>. In addition, 
            you need to add the following line to <tt class="literal">components.xml</tt> to install the Quartz 
            dispatcher.
        </p><pre class="programlisting">&lt;async:quartz-dispatcher/&gt;</pre><p>
            The Seam API for the default <tt class="literal">ScheduledThreadPoolExecutor</tt>, the EJB3 
            <tt class="literal">Timer</tt>, and the Quartz <tt class="literal">Scheduler</tt> are largely the 
            same. They can just "plug and play" by adding a line to <tt class="literal">components.xml</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11413"></a>18.1.1.&nbsp;Asynchronous methods</h3></div></div><div></div></div><p>
            In simplest form, an asynchronous call just lets a method call be processed asynchronously 
            (in a different thread) from the caller. We usually use an asynchronous call when we want 
            to return an immediate response to the client, and let some expensive work be processed in
            the background. This pattern works very well in applications which use AJAX, where the
            client can automatically poll the server for the result of the work.
        </p><p>
            For EJB components, we annotate the local interface to specify that a method is processed
            asynchronously.
        </p><pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public void processPayment(Payment payment);
}</pre><p>
            (For JavaBean components we can annotate the component implementation class if we like.)
        </p><p>
            The use of asynchronicity is transparent to the bean class:
        </p><pre class="programlisting">@Stateless
@Name("paymentHandler")
public class PaymentHandlerBean implements PaymentHandler
{
    public void processPayment(Payment payment)
    {
        //do some work!
    }
}</pre><p>
            And also transparent to the client:
        </p><pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String pay()
    {
        paymentHandler.processPayment( new Payment(bill) );
        return "success";
    }
}</pre><p>
            The asynchronous method is processed in a completely new event context and does
            not have access to the session or conversation context state of the caller. However,
            the business process context <span class="emphasis"><em>is</em></span> propagated.
        </p><p>
            Asynchronous method calls may be scheduled for later execution using the
            <tt class="literal">@Duration</tt>, <tt class="literal">@Expiration</tt> and
            <tt class="literal">@IntervalDuration</tt> annotations.
        </p><pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public void processScheduledPayment(Payment payment, @Expiration Date date);

    @Asynchronous
    public void processRecurringPayment(Payment payment, 
                                        @Expiration Date date, 
                                        @IntervalDuration Long interval)'
}</pre><pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String schedulePayment()
    {
        paymentHandler.processScheduledPayment( new Payment(bill), bill.getDueDate() );
        return "success";
    }

    public String scheduleRecurringPayment()
    {
        paymentHandler.processRecurringPayment( new Payment(bill), bill.getDueDate(), 
                                                ONE_MONTH );
        return "success";
    }
}</pre><p>
            Both client and server may access the <tt class="literal">Timer</tt> object associated with
            the invocation. The <tt class="literal">Timer</tt> object shown below is the EJB3 timer when you use the EJB3 dispatcher. For the default <tt class="literal">ScheduledThreadPoolExecutor</tt>, the returned object is <tt class="literal">Future</tt> from the JDK. For the Quartz dispatcher, it returns <tt class="literal">QuartzTriggerHandle</tt>, which we will discuss in the next section.
        </p><pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public Timer processScheduledPayment(Payment payment, @Expiration Date date);
}</pre><pre class="programlisting">@Stateless
@Name("paymentHandler")
public class PaymentHandlerBean implements PaymentHandler
{
    @In Timer timer;
    
    public Timer processScheduledPayment(Payment payment, @Expiration Date date)
    {
        //do some work!
        
        return timer; //note that return value is completely ignored
    }

}</pre><pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String schedulePayment()
    {
        Timer timer = paymentHandler.processScheduledPayment( new Payment(bill), 
                                                              bill.getDueDate() );
        return "success";
    }
}</pre><p>
            Asynchronous methods cannot return any other value to the caller.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11477"></a>18.1.2.&nbsp;Asynchronous methods with the Quartz Dispatcher</h3></div></div><div></div></div><p>
            The Quartz dispatcher (see earlier on how to install it) allows you to use the <tt class="literal">@Asynchronous</tt>, <tt class="literal">@Duration</tt>, <tt class="literal">@Expiration</tt>, and <tt class="literal">@IntervalDuration</tt> annotations as above. But it has some powerful additional features. The Quartz dispatcher supports three new annotations.
        </p><p>The <tt class="literal">@FinalExpiration</tt> annotation specifies an end date for the recurring task.</p><pre class="programlisting">
    // Defines the method in the "processor" component
    @Asynchronous
    public QuartzTriggerHandle schedulePayment(@Expiration Date when, 
                                 @IntervalDuration Long interval,
                                 @FinalExpiration Date endDate, 
                                 Payment payment) 
    { 
        // do the repeating or long running task until endDate
    }
    
    ... ...
    
    // Schedule the task in the business logic processing code
    // Starts now, repeats every hour, and ends on May 10th, 2010
    Calendar cal = Calendar.getInstance ();
    cal.set (2010, Calendar.MAY, 10);
    processor.schedulePayment(new Date(), 60*60*1000, cal.getTime(), payment);
</pre><p>Note that the method returns the <tt class="literal">QuartzTriggerHandle</tt> object, which you can use later to stop, pause, and resume the scheduler. The <tt class="literal">QuartzTriggerHandle</tt> object is serializable, so you can save it into the database if you need to keep it around for extended period of time.</p><pre class="programlisting">QuartzTriggerHandle handle =
         processor.schedulePayment(payment.getPaymentDate(), 
                                   payment.getPaymentCron(), 
                                   payment);
        payment.setQuartzTriggerHandle( handle );
        // Save payment to DB
        
        // later ...
        
        // Retrieve payment from DB
        // Cancel the remaining scheduled tasks
        payment.getQuartzTriggerHandle().cancel();
</pre><p>The <tt class="literal">@IntervalCron</tt> annotation supports Unix cron job syntax for task scheduling. For instance, the following asynchronous method runs at 2:10pm and at 2:44pm every Wednesday in the month of March.
        </p><pre class="programlisting">
    // Define the method
    @Asynchronous
    public QuartzTriggerHandle schedulePayment(@Expiration Date when, 
                                 @IntervalCron String cron, 
                                 Payment payment) 
    { 
        // do the repeating or long running task
    }
    
    ... ...
    
    // Schedule the task in the business logic processing code
    QuartzTriggerHandle handle = 
      processor.schedulePayment(new Date(), "0 10,44 14 ? 3 WED", payment);
</pre><p>The <tt class="literal">@IntervalBusinessDay</tt> annotation supports invocation on the "nth Business Day" scenario. For instance, the following asynchronous method runs at 14:00 on the 2nd business day of each month. By default, it excludes all weekends and US federal holidays until 2010 from the business days.
        </p><pre class="programlisting">
    // Define the method
    @Asynchronous
    public QuartzTriggerHandle schedulePayment(@Expiration Date when, 
                                 @IntervalBusinessDay NthBusinessDay nth, 
                                 Payment payment) 
    { 
        // do the repeating or long running task
    }
    
    ... ...
    
    // Schedule the task in the business logic processing code
    QuartzTriggerHandle handle = 
      processor.schedulePayment(new Date(), 
          new NthBusinessDay(2, "14:00", WEEKLY), payment);
</pre><p>The <tt class="literal">NthBusinessDay</tt> object contains the configuration of the invocation trigger. You can specify more holidays (e.g., company holidays, non-US holidays etc.) via the <tt class="literal">additionalHolidays</tt> property.</p><pre class="programlisting">
public class NthBusinessDay implements Serializable
{
      int n;
      String fireAtTime;
      List &lt;Date&gt; additionalHolidays;
      BusinessDayIntervalType interval;
      boolean excludeWeekends;
      boolean excludeUsFederalHolidays;

      public enum BusinessDayIntervalType { WEEKLY, MONTHLY, YEARLY }

      public NthBusinessDay ()
      {
        n = 1;
        fireAtTime = "12:00";
        additionalHolidays = new ArrayList &lt;Date&gt; ();
        interval = BusinessDayIntervalType.WEEKLY;
        excludeWeekends = true;
        excludeUsFederalHolidays = true;
      }     
      ... ...
}
</pre><p>The <tt class="literal">@IntervalDuration</tt>, <tt class="literal">@IntervalCron</tt>, and <tt class="literal">@IntervalNthBusinessDay</tt> annotations are mutually exclusive. If they are used in the same method, a <tt class="literal">RuntimeException</tt> will be thrown.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11549"></a>18.1.3.&nbsp;Asynchronous events</h3></div></div><div></div></div><p>
                Component-driven events may also be asynchronous. To raise an event for asynchronous
                processing, simply call the <tt class="literal">raiseAsynchronousEvent()</tt> method of 
                the <tt class="literal">Events</tt> class. To schedule a timed event, call the
                <tt class="literal">raiseTimedEvent()</tt> method, passing a <span class="emphasis"><em>schedule</em></span>
                object (for the default dispatcher or timer service dispatcher, use <tt class="literal">TimerSchedule</tt>). 
                Components may observe asynchronous events in the usual way, but remember that only the 
                business process context is propagated to the asynchronous thread.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11569"></a>18.2.&nbsp;Messaging in Seam</h2></div></div><div></div></div><p>
        Seam makes it easy to send and receive JMS messages to and from
        Seam components.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11574"></a>18.2.1.&nbsp;Configuration</h3></div></div><div></div></div><p>
            To configure Seam's infrastructure for sending JMS messages,
            you need to tell Seam about any topics and queues you want to
            send messages to, and also tell Seam where to find the
            <tt class="literal">QueueConnectionFactory</tt> and/or
            <tt class="literal">TopicConnectionFactory</tt>.
        </p><p>
            Seam defaults to using <tt class="literal">UIL2ConnectionFactory</tt>
            which is the usual connection factory for use with JBossMQ. If
            you are using some other JMS provider, you need to set one or
            both of <tt class="literal">queueConnection.queueConnectionFactoryJndiName</tt>
            and <tt class="literal">topicConnection.topicConnectionFactoryJndiName</tt>
            in <tt class="literal">seam.properties</tt>, <tt class="literal">web.xml</tt>
            or <tt class="literal">components.xml</tt>.
        </p><p>
            You also need to list topics and queues in <tt class="literal">components.xml</tt>
            to install Seam managed <tt class="literal">TopicPublisher</tt>s and
            <tt class="literal">QueueSender</tt>s:
        </p><pre class="programlisting">&lt;jms:managed-topic-publisher name="stockTickerPublisher" 
                             auto-create="true" 
                             topic-jndi-name="topic/stockTickerTopic"/&gt;

&lt;jms:managed-queue-sender name="paymentQueueSender" 
                          auto-create="true" 
                          queue-jndi-name="queue/paymentQueue"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11618"></a>18.2.2.&nbsp;Sending messages</h3></div></div><div></div></div><p>
            Now, you can inject a JMS <tt class="literal">TopicPublisher</tt> and
            <tt class="literal">TopicSession</tt> into any component:
        </p><pre class="programlisting">@In 
private TopicPublisher stockTickerPublisher;   
@In 
private TopicSession topicSession;

public void publish(StockPrice price) {
      try
      {
         stockTickerPublisher.publish( topicSession.createObjectMessage(price) );
      } 
      catch (Exception ex)
      {
         throw new RuntimeException(ex);
      } 
}</pre><p>Or, for working with a queue:</p><pre class="programlisting">@In
private QueueSender paymentQueueSender;   
@In
private QueueSession queueSession;

public void publish(Payment payment) {
      try
      {
         paymentQueueSender.send( queueSession.createObjectMessage(payment) );
      } 
      catch (Exception ex)
      {
         throw new RuntimeException(ex);
      } 
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11635"></a>18.2.3.&nbsp;Receiving messages using a message-driven bean</h3></div></div><div></div></div><p>
            You can process messages using any EJB3 message driven bean. Message-driven
            beans may even be Seam components, in which case it is possible to inject
            other event and application scoped Seam components.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11640"></a>18.2.4.&nbsp;Receiving messages in the client</h3></div></div><div></div></div><p>
            Seam Remoting lets you subscribe to a JMS topic from client-side JavaScript. This is
            described in <a href="#remoting" title="Chapter&nbsp;21.&nbsp;Remoting">Chapter&nbsp;21, <i>Remoting</i></a>.
        </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="cache"></a>Chapter&nbsp;19.&nbsp;Caching</h2></div></div><div></div></div><p>
        In almost all enterprise applications, the database is the primary 
        bottleneck, and the least scalable tier of the runtime environment. 
        People from a PHP/Ruby environment will try to tell you that so-called
        "shared nothing" architectures scale well. While that may be literally
        true, I don't know of many interesting multi-user applications which 
        can be implemented with no sharing of resources between different 
        nodes of the cluster. What these silly people are really thinking of 
        is a "share nothing except for the database" architecture. Of course, 
        sharing the database is the primary problem with scaling a multi-user 
        application&#8212;so the claim that this architecture is highly scalable 
        is absurd, and tells you a lot about the kind of applications that these
        folks spend most of their time working on. 
    </p><p>
        Almost anything we can possibly do to share the database <span class="emphasis"><em>less 
        often</em></span> is worth doing.
    </p><p>
        This calls for a cache. Well, not just one cache. A well designed Seam
        application will feature a rich, multi-layered caching strategy that
        impacts every layer of the application:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
                The database, of course, has its own cache. This is 
                super-important, but can't scale like a cache in the
                application tier.
            </p></li><li><p>
                Your ORM solution (Hibernate, or some other JPA implementation)
                has a second-level cache of data from the database. This is
                a very powerful capability, but is often misused. In a clustered
                environment, keeping the data in the cache transactionally
                consistent across the whole cluster, and with the database,
                is quite expensive. It makes most sense for data which is shared
                between many users, and is updated rarely. In traditional 
                stateless architectures, people often try to use the second-level
                cache for conversational state. This is always bad, and is
                especially wrong in Seam.
            </p></li><li><p>
                The Seam conversation context is a cache of conversational state.
                Components you put into the conversation context can hold and cache
                state relating to the current user interaction.
            </p></li><li><p>
                In particular, the
                Seam-managed persistence context (or an extended EJB container-managed
                persistence context associated with a conversation-scoped stateful
                session bean) acts as a cache of data that has been read in the
                current conversation. This cache tends to have a pretty high
                hitrate! Seam optimizes the replication of Seam-managed persistence 
                contexts in a clustered environment, and there is no requirement for 
                transactional consistency with the database (optimistic locking is 
                sufficient) so you don't need to worry too much about the performance 
                implications of this cache, unless you read thousands of objects into
                a single persistence context.
            </p></li><li><p>
                The application can cache non-transactional state in the Seam
                application context. State kept in the application context is
                of course not visible to other nodes in the cluster.
            </p></li><li><p>
                The application can cache transactional state using the Seam
                <tt class="literal">pojoCache</tt> component, which integrates
                JBossCache into the Seam environment. This state will be visible
                to other nodes if you run JBoss cache in a clustered mode.
            </p></li><li><p>
                Finally, Seam lets you cache rendered fragments of a JSF page. Unlike  
                the ORM second-level cache, this cache is not automatically invalidated 
                when data changes, so you need to write application code to perform
                explicit invalidation, or set appropriate expiration policies.
            </p></li></ul></div><p>
        For more information about the second-level cache, you'll need to refer to
        the documentation of your ORM solution, since this is an extremely complex
        topic. In this section we'll discuss the use of JBossCache directly, via
        the <tt class="literal">pojoCache</tt> component, or as the page fragment cache,
        via the <tt class="literal">&lt;s:cache&gt;</tt> control.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11692"></a>19.1.&nbsp;Using JBossCache in Seam</h2></div></div><div></div></div><p>
            The built-in <tt class="literal">pojoCache</tt> component manages an instance
            of <tt class="literal">org.jboss.cache.aop.PojoCache</tt>. You can safely put 
            any immutable Java object in the cache, and it will be replicated across
            the cluster (assuming that replication is enabled). If you want to
            keep mutable objects in the cache, you'll need to run the JBossCache
            bytecode preprocessor to ensure that changes to the objects will be
            automatically detected and replicated.
        </p><p>
            To use <tt class="literal">pojoCache</tt>, all you need to do is put the
            JBossCache jars in the classpath, and provide a resource named
            <tt class="literal">treecache.xml</tt> with an appropriate cache configuration.
            JBossCache has many scary and confusing configuration settings, so
            we won't discuss them here. Please refer to the JBossCache documentation
            for more information.
        </p><p>
            You can find a sample <tt class="literal">treecache.xml</tt> in
            <tt class="literal">examples/blog/resources/treecache.xml</tt>.
        </p><p>
            For an EAR depoyment of Seam, we recommend that the JBossCache jars and
            configuration go directly into the EAR. Make sure you place both
            <tt class="literal">jboss-cache.jar</tt> and <tt class="literal">jgroups.jar</tt>
            in your EAR's lib folder.
        </p><p>
            Now you can inject the cache into any Seam component:
        </p><pre class="programlisting">@Name("chatroom")
public class Chatroom {
    @In PojoCache pojoCache;
    
    public void join(String username) {
      try
      {
         Set&lt;String&gt; userList = (Set&lt;String&gt;) pojoCache.get("chatroom", "userList");
         if (userList==null) 
         {
            userList = new HashSet&lt;String&gt;();
            pojoCache.put("chatroom", "userList", userList);
         }
         userList.put(username);
      }
      catch (CacheException ce)
      {
         throw new RuntimeException(ce);
      }
    }
}</pre><p>
            If you want to have multiple JBossCache configurations in your application,
            use <tt class="literal">components.xml</tt>:
        </p><pre class="programlisting">&lt;core:pojo-cache name="myCache" cfg-resource-name="myown/cache.xml"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11738"></a>19.2.&nbsp;Page fragment caching</h2></div></div><div></div></div><p>
            The most interesting user of JBossCache is the <tt class="literal">&lt;s:cache&gt;</tt>
            tag, Seam's solution to the problem of page fragment caching in JSF.
            <tt class="literal">&lt;s:cache&gt;</tt> uses <tt class="literal">pojoCache</tt> internally,
            so you need to follow the steps listed above before you can use it. (Put the jars 
            in the EAR, wade through the scary configuration options, etc.)
        </p><p>
            <tt class="literal">&lt;s:cache&gt;</tt> is used for caching some rendered content which
            changes rarely. For example, the welcome page of our blog displays the recent
            blog entries:
        </p><pre class="programlisting">&lt;s:cache key="recentEntries-#{blog.id}" region="welcomePageFragments"&gt;
   &lt;h:dataTable value="#{blog.recentEntries}" var="blogEntry"&gt;
      &lt;h:column&gt;
         &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
         &lt;div&gt;
            &lt;s:formattedText value="#{blogEntry.body}"/&gt;
         &lt;/div&gt;
      &lt;/h:column&gt;
   &lt;/h:dataTable&gt;
&lt;/s:cache&gt;</pre><p>
            The <tt class="literal">key</tt> let's you have multiple cached versions of each page
            fragment. In this case, there is one cached version per blog. The 
            <tt class="literal">region</tt> determines the JBossCache node that all version will
            be stored in. Different nodes may have different expiry policies. (That's the 
            stuff you set up using the aforementioned scary configuration options.)
        </p><p>
            Of course, the big problem with <tt class="literal">&lt;s:cache&gt;</tt> is that it 
            is too stupid to know when the underlying data changes (for example, when the 
            blogger posts a new entry). So you need to evict the cached fragment manually:
        </p><pre class="programlisting">public void post() {
    ...
    entityManager.persist(blogEntry);
    pojoCache.remove("welcomePageFragments", "recentEntries-" + blog.getId() );
}</pre><p>
            Alternatively, if it is not critical that changes are immediately visible to the
            user, you could set a short expiry time on the JbossCache node.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="webservices"></a>Chapter&nbsp;20.&nbsp;Web Services</h2></div></div><div></div></div><p>
    Seam integrates with JBossWS to allow standard JEE web services to take full advantage of Seam's contextual framework,
    including support for conversational web services. This chapter walks through the steps required to allow web 
    services to run within a Seam environment.
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11781"></a>20.1.&nbsp;Configuration and Packaging</h2></div></div><div></div></div><p>
      To allow Seam to intercept web service requests so that the necessary Seam contexts can be created for the request, 
      a special SOAP handler must be configured; <tt class="literal">org.jboss.seam.webservice.SOAPRequestHandler</tt>
      is a <tt class="literal">SOAPHandler</tt> implementation that does the work of managing Seam's lifecycle during the scope
      of a web service request.  The easiest way to configure a project to use this handler, is to place a file called
      <tt class="literal">standard-jaxws-endpoint-config.xml</tt> into the <tt class="literal">META-INF</tt> directory of the
      <tt class="literal">jar</tt> file that contains the web service classes.  This file contains the following SOAP handler
      configuration:
    </p><pre class="programlisting">&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" 
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
              xmlns:javaee="http://java.sun.com/xml/ns/javaee"
              xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;
   &lt;endpoint-config&gt;
      &lt;config-name&gt;Seam WebService Endpoint&lt;/config-name&gt;
      &lt;pre-handler-chains&gt;
         &lt;javaee:handler-chain&gt;
            &lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;
            &lt;javaee:handler&gt;
               &lt;javaee:handler-name&gt;SOAP Request Handler&lt;/javaee:handler-name&gt;
               &lt;javaee:handler-class&gt;org.jboss.seam.webservice.SOAPRequestHandler&lt;/javaee:handler-class&gt;
            &lt;/javaee:handler&gt;
         &lt;/javaee:handler-chain&gt;
      &lt;/pre-handler-chains&gt;
   &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11803"></a>20.2.&nbsp;Conversational Web Services</h2></div></div><div></div></div><p>
      So how are conversations propagated between web service requests?  Seam uses a SOAP header element present
      in both the SOAP request and response messages to carry the conversation ID from the consumer to the service,
      and back again.  Here's an example of a web service request that contains a conversation ID:
    </p><pre class="programlisting">&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
    xmlns:seam="http://seambay.example.seam.jboss.org/"&gt;
  &lt;soapenv:Header&gt;
    &lt;seam:conversationId xmlns:seam='http://www.jboss.org/seam/webservice'&gt;2&lt;/seam:conversationId&gt;
  &lt;/soapenv:Header&gt;
  &lt;soapenv:Body&gt;
    &lt;seam:confirmAuction/&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;    
    </pre><p>
      As you can see in the above SOAP message, there is a <tt class="literal">conversationId</tt> element within the
      SOAP header that contains the conversation ID for the request, in this case <tt class="literal">2</tt>.  
      Unfortunately, because web services may be consumed by a variety of web service clients written in a 
      variety of languages, it is up to the developer to implement conversation ID propagation between individual 
      web services that are intended to be used within the scope of a single conversation.
    </p><p>
      An important thing to note is that the <tt class="literal">conversationId</tt> header element must be qualified
      with a namespace of <tt class="literal">http://www.jboss.org/seam/webservice</tt>, otherwise Seam will not be
      able to read the conversation ID from the request. Here's an example of a response to the above request message:
    </p><pre class="programlisting">&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
  &lt;env:Header&gt;
    &lt;seam:conversationId xmlns:seam='http://www.jboss.org/seam/webservice'&gt;2&lt;/seam:conversationId&gt;
  &lt;/env:Header&gt;
  &lt;env:Body&gt;
    &lt;confirmAuctionResponse xmlns="http://seambay.example.seam.jboss.org/"/&gt;
  &lt;/env:Body&gt;
&lt;/env:Envelope&gt;    
    </pre><p>
      As you can see, the response message contains the same <tt class="literal">conversationId</tt> element as the request.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11833"></a>20.2.1.&nbsp;A Recommended Strategy</h3></div></div><div></div></div><p>
        As web services must be implemented as either a stateless session bean or POJO, it is recommended that for
        conversational web services, the web service acts as a facade to a conversational Seam component.
      </p><div class="mediaobject" align="center"><img src="../shared/images/ws-strategy.png" align="middle"></div><p>
        If the web service is written as a stateless session bean, then it is also possible to make it a Seam
        component by giving it a <tt class="literal">@Name</tt>.  Doing this allows Seam's bijection (and other) 
        features to be used in the web service class itself. 
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11848"></a>20.3.&nbsp;An example web service</h2></div></div><div></div></div><p>
      Let's walk through an example web service.  The code in this section all comes from the seamBay example
      application in Seam's <tt class="literal">/examples</tt> directory, and follows the recommended strategy as
      described in the previous section.  Let's first take a look at the web service class and one of its web 
      service methods:
    </p><pre class="programlisting">@Stateless
@WebService(name = "AuctionService", serviceName = "AuctionService")
public class AuctionService implements AuctionServiceRemote
{           
   @WebMethod
   public boolean login(String username, String password)
   {
      Identity.instance().setUsername(username);
      Identity.instance().setPassword(password);
      Identity.instance().login();
      return Identity.instance().isLoggedIn();
   }
   
   // snip
}</pre><p>
      As you can see, our web service is a stateless session bean, and is annotated using the JWS annotations 
      from the <tt class="literal">javax.jws</tt> package, as defined by JSR-181.  The <tt class="literal">@WebService</tt> 
      annotation tells the container that this class implements a web service, and the <tt class="literal">@WebMethod</tt> 
      annotation on the <tt class="literal">login()</tt> method identifies the method as a web service method.  
      The <tt class="literal">name</tt> and <tt class="literal">serviceName</tt> attributes in the <tt class="literal">@WebService</tt> 
      annotation are optional.
    </p><p>
      As is required by the specification, each method that is to be exposed as a web service method must also be 
      declared in the remote interface of the web service class (when the web service is a stateless session bean).  
      In the above example, the <tt class="literal">AuctionServiceRemote</tt> interface must declare the <tt class="literal">login()</tt> 
      method as it is annotated as a <tt class="literal">@WebMethod</tt>.
    </p><p>
      As you can see in the above code, the web service implements a <tt class="literal">login()</tt> method that 
      delegates to Seam's built-in <tt class="literal">Identity</tt> component.  In keeping with our recommended strategy,
      the web service is written as a simple facade, passing off the real work to a Seam component.  This allows
      for the greatest reuse of business logic between web services and other clients.
    </p><p>
      Let's look at another example.  This web service method begins a new conversation by delegating to the
      <tt class="literal">AuctionAction.createAuction()</tt> method:
    </p><pre class="programlisting">   @WebMethod
   public void createAuction(String title, String description, int categoryId)
   {
      AuctionAction action = (AuctionAction) Component.getInstance(AuctionAction.class, true);
      action.createAuction();
      action.setDetails(title, description, categoryId);
   }</pre><p>
      And here's the code from <tt class="literal">AuctionAction</tt>:
    </p><pre class="programlisting">   @Begin
   public void createAuction()
   {
      auction = new Auction();
      auction.setAccount(authenticatedAccount);
      auction.setStatus(Auction.STATUS_UNLISTED);        
      durationDays = DEFAULT_AUCTION_DURATION;
   }</pre><p>
      From this we can see how web services can participate in long running conversations, by acting as a facade
      and delegating the real work to a conversational Seam component.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="remoting"></a>Chapter&nbsp;21.&nbsp;Remoting</h2></div></div><div></div></div><p> Seam provides a convenient method of remotely accessing components from a web page, using AJAX (Asynchronous
    Javascript and XML). The framework for this functionality is provided with almost no up-front development effort -
    your components only require simple annotating to become accessible via AJAX. This chapter describes the steps
    required to build an AJAX-enabled web page, then goes on to explain the features of the Seam Remoting framework in
    more detail. </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11921"></a>21.1.&nbsp;Configuration</h2></div></div><div></div></div><p> To use remoting, the Seam Resource servlet must first be configured in your <tt class="literal">web.xml</tt> file: </p><pre class="programlisting">&lt;servlet&gt;
  &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.seam.servlet.SeamResourceServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/seam/resource/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre><p> The next step is to import the necessary Javascript into your web page. There are a minimum of two scripts
      that must be imported. The first one contains all the client-side framework code that enables remoting
      functionality: </p><pre class="programlisting">&lt;script type="text/javascript" src="seam/resource/remoting/resource/remote.js"&gt;&lt;/script&gt;</pre><p> The second script contains the stubs and type definitions for the components you wish to call. It is
      generated dynamically based on the local interface of your components, and includes type definitions for all of
      the classes that can be used to call the remotable methods of the interface. The name of the script reflects the
      name of your component. For example, if you have a stateless session bean annotated with
        <tt class="literal">@Name("customerAction")</tt>, then your script tag should look like this: </p><pre class="programlisting">&lt;script type="text/javascript" 
          src="seam/resource/remoting/interface.js?customerAction"&gt;&lt;/script&gt;</pre><p> If you wish to access more than one component from the same page, then include them all as parameters of your
      script tag: </p><pre class="programlisting">&lt;script type="text/javascript" 
        src="seam/resource/remoting/interface.js?customerAction&amp;accountAction"&gt;&lt;/script&gt;</pre><p>
      Alternatively, you may use the <tt class="literal">s:remote</tt> tag to import the required Javascript.  Separate each
      component or class name you wish to import with a comma: 
    </p><pre class="programlisting">
  &lt;s:remote include="customerAction,accountAction"/&gt;    
    </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11953"></a>21.2.&nbsp;The "Seam" object</h2></div></div><div></div></div><p> Client-side interaction with your components is all performed via the <tt class="literal">Seam</tt> Javascript
      object. This object is defined in <tt class="literal">remote.js</tt>, and you'll be using it to make asynchronous calls
      against your component. It is split into two areas of functionality; <tt class="literal">Seam.Component</tt> contains
      methods for working with components and <tt class="literal">Seam.Remoting</tt> contains methods for executing remote
      requests. The easiest way to become familiar with this object is to start with a simple example. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11970"></a>21.2.1.&nbsp;A Hello World example</h3></div></div><div></div></div><p> Let's step through a simple example to see how the <tt class="literal">Seam</tt> object works. First of all,
        let's create a new Seam component called <tt class="literal">helloAction</tt>. </p><pre class="programlisting">@Stateless
@Name("helloAction")
public class HelloAction implements HelloLocal {
    public String sayHello(String name) {
        return "Hello, " + name;
    }
}</pre><p>You also need to create a local interface for our new component - take special note of the
          <tt class="literal">@WebRemote</tt> annotation, as it's required to make our method accessible via remoting:</p><pre class="programlisting">@Local
public interface HelloLocal {
  @WebRemote
  public String sayHello(String name);
}</pre><p> That's all the server-side code we need to write. Now for our web page - create a new page and import the 
          <tt class="literal">helloAction</tt> component: </p><pre class="programlisting">&lt;s:remote include="helloAction"/&gt;</pre><p> To make this a fully interactive user experience, let's add a button to our page: </p><pre class="programlisting">&lt;button onclick="javascript:sayHello()"&gt;Say Hello&lt;/button&gt;</pre><p> We'll also need to add some more script to make our button actually do something when it's clicked: </p><pre class="programlisting">&lt;script type="text/javascript"&gt;
  //&lt;![CDATA[

  function sayHello() {
    var name = prompt("What is your name?");
    Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
  }

  function sayHelloCallback(result) {
    alert(result);
  }

   // ]]&gt;
&lt;/script&gt;</pre><p> We're done! Deploy your application and browse to your page. Click the button, and enter a name when
        prompted. A message box will display the hello message confirming that the call was successful. If you want to
        save some time, you'll find the full source code for this Hello World example in Seam's
          <tt class="literal">/examples/remoting/helloworld</tt> directory. </p><p> So what does the code of our script actually do? Let's break it down into smaller pieces. To start with,
        you can see from the Javascript code listing that we have implemented two methods - the first method is
        responsible for prompting the user for their name and then making a remote request. Take a look at the following
        line: </p><pre class="programlisting">Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);</pre><p> The first section of this line, <tt class="literal">Seam.Component.getInstance("helloAction")</tt> returns a
        proxy, or "stub" for our <tt class="literal">helloAction</tt> component. We can invoke the methods of our component
        against this stub, which is exactly what happens with the remainder of the line: <tt class="literal">sayHello(name,
          sayHelloCallback);</tt>. </p><p> What this line of code in its completeness does, is invoke the <tt class="literal">sayHello</tt> method of our
        component, passing in <tt class="literal">name</tt> as a parameter. The second parameter,
        <tt class="literal">sayHelloCallback</tt> isn't a parameter of our component's <tt class="literal">sayHello</tt> method,
        instead it tells the Seam Remoting framework that once it receives the response to our request, it should pass
        it to the <tt class="literal">sayHelloCallback</tt> Javascript method. This callback parameter is entirely optional,
        so feel free to leave it out if you're calling a method with a <tt class="literal">void</tt> return type or if you
        don't care about the result. </p><p> The <tt class="literal">sayHelloCallback</tt> method, once receiving the response to our remote request then pops
        up an alert message displaying the result of our method call. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12050"></a>21.2.2.&nbsp;Seam.Component</h3></div></div><div></div></div><p> The <tt class="literal">Seam.Component</tt> Javascript object provides a number of client-side methods for
        working with your Seam components. The two main methods, <tt class="literal">newInstance()</tt> and
          <tt class="literal">getInstance()</tt> are documented in the following sections however their main difference is
        that <tt class="literal">newInstance()</tt> will always create a new instance of a component type, and
          <tt class="literal">getInstance()</tt> will return a singleton instance. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12070"></a>21.2.2.1.&nbsp;Seam.Component.newInstance()</h4></div></div><div></div></div><p> Use this method to create a new instance of an entity or Javabean component. The object returned by this
          method will have the same getter/setter methods as its server-side counterpart, or alternatively if you wish
          you can access its fields directly. Take the following Seam entity component for example: </p><pre class="programlisting">@Name("customer")
@Entity
public class Customer implements Serializable
{
  private Integer customerId;
  private String firstName;
  private String lastName;
    
  @Column public Integer getCustomerId() { 
    return customerId; 
  }
    
  public void setCustomerId(Integer customerId} { 
    this.customerId = customerId; 
  }
  
  @Column public String getFirstName() { 
    return firstName; 
  }
  
  public void setFirstName(String firstName) {
    this.firstName = firstName; 
  }
  
  @Column public String getLastName() {
    return lastName;
  }
  
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
}</pre><p> To create a client-side Customer you would write the following code: </p><pre class="programlisting">var customer = Seam.Component.newInstance("customer");</pre><p> Then from here you can set the fields of the customer object: </p><pre class="programlisting">customer.setFirstName("John");
// Or you can set the fields directly
customer.lastName = "Smith";</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12085"></a>21.2.2.2.&nbsp;Seam.Component.getInstance()</h4></div></div><div></div></div><p> The <tt class="literal">getInstance()</tt> method is used to get a reference to a Seam session bean component
          stub, which can then be used to remotely execute methods against your component. This method returns a
          singleton for the specified component, so calling it twice in a row with the same component name will return
          the same instance of the component. </p><p> To continue our example from before, if we have created a new <tt class="literal">customer</tt> and we now wish
          to save it, we would pass it to the <tt class="literal">saveCustomer()</tt> method of our
          <tt class="literal">customerAction</tt> component: </p><pre class="programlisting">Seam.Component.getInstance("customerAction").saveCustomer(customer);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12106"></a>21.2.2.3.&nbsp;Seam.Component.getComponentName()</h4></div></div><div></div></div><p> Passing an object into this method will return its component name if it is a component, or
          <tt class="literal">null</tt> if it is not. </p><pre class="programlisting">if (Seam.Component.getComponentName(instance) == "customer")
  alert("Customer");
else if (Seam.Component.getComponentName(instance) == "staff")
  alert("Staff member");</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12116"></a>21.2.3.&nbsp;Seam.Remoting</h3></div></div><div></div></div><p> Most of the client side functionality for Seam Remoting is contained within the
        <tt class="literal">Seam.Remoting</tt> object. While you shouldn't need to directly call most of its methods, there
        are a couple of important ones worth mentioning. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12124"></a>21.2.3.1.&nbsp;Seam.Remoting.createType()</h4></div></div><div></div></div><p> If your application contains or uses Javabean classes that aren't Seam components, you may need to create
          these types on the client side to pass as parameters into your component method. Use the
          <tt class="literal">createType()</tt> method to create an instance of your type. Pass in the fully qualified Java
          class name as a parameter: </p><pre class="programlisting">var widget = Seam.Remoting.createType("com.acme.widgets.MyWidget");</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12134"></a>21.2.3.2.&nbsp;Seam.Remoting.getTypeName()</h4></div></div><div></div></div><p> This method is the equivalent of <tt class="literal">Seam.Component.getComponentName()</tt> but for
          non-component types. It will return the name of the type for an object instance, or <tt class="literal">null</tt> if
          the type is not known. The name is the fully qualified name of the type's Java class. </p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12145"></a>21.3.&nbsp;Evaluating EL Expressions</h2></div></div><div></div></div><p>
      Seam Remoting also supports the evaluation of EL expressions, which provides another convenient method for retrieving
      data from the server.  Using the <tt class="literal">Seam.Remoting.eval()</tt> function, an EL expression can be remotely
      evaluated on the server and the resulting value returned to a client-side callback method.  This function accepts two
      parameters, the first being the EL expression to evaluate, and the second being the callback method to invoke with the
      value of the expression.  Here's an example:
    </p><pre class="programlisting">  function customersCallback(customers) {
    for (var i = 0; i &lt; customers.length; i++) {
      alert("Got customer: " + customers[i].getName());
    }    
  }
    
  Seam.Remoting.eval("#{customers}", customersCallback);  
    </pre><p>
      In this example, the expression <tt class="literal">#{customers}</tt> is evaluated by Seam, and the value of the expression
      (in this case a list of Customer objects) is returned to the <tt class="literal">customersCallback()</tt> method.  It is 
      important to remember that the objects returned this way must have their types imported (via <tt class="literal">s:remote</tt>)
      to be able to work with them in Javascript.  So to work with a list of <tt class="literal">customer</tt> objects,
      it is required to import the <tt class="literal">customer</tt> type:
    </p><pre class="programlisting">&lt;s:remote include="customer"/&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12174"></a>21.4.&nbsp;Client Interfaces</h2></div></div><div></div></div><p> In the configuration section above, the interface, or "stub" for our component is imported into our page 
        either via <tt class="literal">seam/resource/remoting/interface.js</tt>: </p> or using the <tt class="literal">s:remote</tt>
        tag:

    <pre class="programlisting">&lt;script type="text/javascript" 
        src="seam/resource/remoting/interface.js?customerAction"&gt;&lt;/script&gt;</pre><pre class="programlisting">&lt;s:remote include="customerAction"/&gt;</pre><p> By including this script in our page, the interface definitions for our component, plus any other components
      or types that are required to execute the methods of our component are generated and made available for the
      remoting framework to use. </p><p> There are two types of client stub that can be generated, "executable" stubs and "type" stubs. Executable
      stubs are behavioural, and are used to execute methods against your session bean components, while type stubs
      contain state and represent the types that can be passed in as parameters or returned as a result. </p><p> The type of client stub that is generated depends on the type of your Seam component. If the component is a
      session bean, then an executable stub will be generated, otherwise if it's an entity or JavaBean, then a type stub
      will be generated. There is one exception to this rule; if your component is a JavaBean (ie it is not a session
      bean nor an entity bean) and any of its methods are annotated with @WebRemote, then an executable stub will be
      generated for it instead of a type stub. This allows you to use remoting to call methods of your JavaBean
      components in a non-EJB environment where you don't have access to session beans. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12196"></a>21.5.&nbsp;The Context</h2></div></div><div></div></div><p> The Seam Remoting Context contains additional information which is sent and received as part of a remoting
      request/response cycle. At this stage it only contains the conversation ID but may be expanded in the future. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12201"></a>21.5.1.&nbsp;Setting and reading the Conversation ID</h3></div></div><div></div></div><p> If you intend on using remote calls within the scope of a conversation then you need to be able to read or
      set the conversation ID in the Seam Remoting Context. To read the conversation ID after making a remote request
      call <tt class="literal">Seam.Remoting.getContext().getConversationId()</tt>. To set the conversation ID before making a
      request, call <tt class="literal">Seam.Remoting.getContext().setConversationId()</tt>. </p><p> If the conversation ID hasn't been explicitly set with
        <tt class="literal">Seam.Remoting.getContext().setConversationId()</tt>, then it will be automatically assigned the
      first valid conversation ID that is returned by any remoting call. If you are working with multiple conversations
      within your page, then you may need to explicitly set the conversation ID before each call. If you are working
      with just a single conversation, then you don't need to do anything special. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12217"></a>21.5.2.&nbsp;Remote calls within the current conversation scope</h3></div></div><div></div></div><p> In some circumstances it may be required to make a remote call within the scope of the
        current view's conversation.  To do this, you must explicitly set the conversation ID to that
        of the view before making the remote call.  This small snippet of JavaScript will set the
        conversation ID that is used for remoting calls to the current view's conversation ID: </p><pre class="programlisting">Seam.Remoting.getContext().setConversationId( #{conversation.id} );</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12224"></a>21.6.&nbsp;Batch Requests</h2></div></div><div></div></div><p> Seam Remoting allows multiple component calls to be executed within a single request. It is recommended that
      this feature is used wherever it is appropriate to reduce network traffic. </p><p> The method <tt class="literal">Seam.Remoting.startBatch()</tt> will start a new batch, and any component calls
      executed after starting a batch are queued, rather than being sent immediately. When all the desired component
      calls have been added to the batch, the <tt class="literal">Seam.Remoting.executeBatch()</tt> method will send a single
      request containing all of the queued calls to the server, where they will be executed in order. After the calls
      have been executed, a single response containining all return values will be returned to the client and the
      callback functions (if provided) triggered in the same order as execution. </p><p> If you start a new batch via the <tt class="literal">startBatch()</tt> method but then decide you don't want to
      send it, the <tt class="literal">Seam.Remoting.cancelBatch()</tt> method will discard any calls that were queued and
      exit the batch mode. </p><p> To see an example of a batch being used, take a look at <tt class="literal">/examples/remoting/chatroom</tt>.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12250"></a>21.7.&nbsp;Working with Data types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12253"></a>21.7.1.&nbsp;Primitives / Basic Types</h3></div></div><div></div></div><p> This section describes the support for basic data types. On the server side these values are generally
        compatible with either their primitive type or their corresponding wrapper class. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12258"></a>21.7.1.1.&nbsp;String</h4></div></div><div></div></div><p> Simply use Javascript String objects when setting String parameter values. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12263"></a>21.7.1.2.&nbsp;Number</h4></div></div><div></div></div><p> There is support for all number types supported by Java. On the client side, number values are always
          serialized as their String representation and then on the server side they are converted to the correct
          destination type. Conversion into either a primitive or wrapper type is supported for <tt class="literal">Byte</tt>,
            <tt class="literal">Double</tt>, <tt class="literal">Float</tt>, <tt class="literal">Integer</tt>, <tt class="literal">Long</tt> and
            <tt class="literal">Short</tt> types. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12286"></a>21.7.1.3.&nbsp;Boolean</h4></div></div><div></div></div><p> Booleans are represented client side by Javascript Boolean values, and server side by a Java boolean.
        </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12291"></a>21.7.2.&nbsp;JavaBeans</h3></div></div><div></div></div><p> In general these will be either Seam entity or JavaBean components, or some other non-component class. Use
        the appropriate method (either <tt class="literal">Seam.Component.newInstance()</tt> for Seam components or
          <tt class="literal">Seam.Remoting.createType()</tt> for everything else) to create a new instance of the object. </p><p> It is important to note that only objects that are created by either of these two methods should be used as
        parameter values, where the parameter is not one of the other valid types mentioned anywhere else in this
        section. In some situations you may have a component method where the exact parameter type cannot be determined,
        such as: </p><pre class="programlisting">@Name("myAction")
public class MyAction implements MyActionLocal {
  public void doSomethingWithObject(Object obj) {
    // code
  }
}</pre><p> In this case you might want to pass in an instance of your <tt class="literal">myWidget</tt> component, however
        the interface for <tt class="literal">myAction</tt> won't include <tt class="literal">myWidget</tt> as it is not directly
        referenced by any of its methods. To get around this, <tt class="literal">MyWidget</tt> needs to be explicitly
        imported: </p><pre class="programlisting">&lt;s:remote include="myAction,myWidget"/&gt;</pre><p> This will then allow a <tt class="literal">myWidget</tt> object to be created with
          <tt class="literal">Seam.Component.newInstance("myWidget")</tt>, which can then be passed to
          <tt class="literal">myAction.doSomethingWithObject()</tt>. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12333"></a>21.7.3.&nbsp;Dates and Times</h3></div></div><div></div></div><p> Date values are serialized into a String representation that is accurate to the millisecond. On the client
        side, use a Javascript Date object to work with date values. On the server side, use any
        <tt class="literal">java.util.Date</tt> (or descendent, such as <tt class="literal">java.sql.Date</tt> or
          <tt class="literal">java.sql.Timestamp</tt> class. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12347"></a>21.7.4.&nbsp;Enums</h3></div></div><div></div></div><p> On the client side, enums are treated the same as Strings. When setting the value for an enum parameter,
        simply use the String representation of the enum. Take the following component as an example: </p><pre class="programlisting">@Name("paintAction")
public class paintAction implements paintLocal {
  public enum Color {red, green, blue, yellow, orange, purple};

  public void paint(Color color) {
    // code
  }    
} </pre><p> To call the <tt class="literal">paint()</tt> method with the color <tt class="literal">red</tt>, pass the parameter
        value as a String literal: </p><pre class="programlisting">Seam.Component.getInstance("paintAction").paint("red");</pre><p> The inverse is also true - that is, if a component method returns an enum parameter (or contains an enum
        field anywhere in the returned object graph) then on the client-side it will be represented as a String. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12366"></a>21.7.5.&nbsp;Collections</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12369"></a>21.7.5.1.&nbsp;Bags</h4></div></div><div></div></div><p> Bags cover all collection types including arrays, collections, lists, sets, (but excluding Maps - see the
          next section for those), and are implemented client-side as a Javascript array. When calling a component
          method that accepts one of these types as a parameter, your parameter should be a Javascript array. If a
          component method returns one of these types, then the return value will also be a Javascript array. The
          remoting framework is clever enough on the server side to convert the bag to an appropriate type for the
          component method call. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12374"></a>21.7.5.2.&nbsp;Maps</h4></div></div><div></div></div><p> As there is no native support for Maps within Javascript, a simple Map implementation is provided with
          the Seam Remoting framework. To create a Map which can be used as a parameter to a remote call, create a new
            <tt class="literal">Seam.Remoting.Map</tt> object: </p><pre class="programlisting">var map = new Seam.Remoting.Map();</pre><p> This Javascript implementation provides basic methods for working with Maps: <tt class="literal">size()</tt>,
            <tt class="literal">isEmpty()</tt>, <tt class="literal">keySet()</tt>, <tt class="literal">values()</tt>,
          <tt class="literal">get(key)</tt>, <tt class="literal">put(key, value)</tt>, <tt class="literal">remove(key)</tt> and
            <tt class="literal">contains(key)</tt>. Each of these methods are equivalent to their Java counterpart. Where the
          method returns a collection, such as <tt class="literal">keySet()</tt> and <tt class="literal">values()</tt>, a Javascript
          Array object will be returned that contains the key or value objects (respectively). </p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12416"></a>21.8.&nbsp;Debugging</h2></div></div><div></div></div><p> To aid in tracking down bugs, it is possible to enable a debug mode which will display the contents of all
      the packets send back and forth between the client and server in a popup window. To enable debug mode, either
      execute the <tt class="literal">setDebug()</tt> method in Javascript: </p><pre class="programlisting">Seam.Remoting.setDebug(true);</pre><p> Or configure it via components.xml: </p><pre class="programlisting">&lt;remoting:remoting debug="true"/&gt;</pre><p> To turn off debugging, call <tt class="literal">setDebug(false)</tt>. If you want to write your own messages to the
      debug log, call <tt class="literal">Seam.Remoting.log(message)</tt>. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12438"></a>21.9.&nbsp;The Loading Message</h2></div></div><div></div></div><p> The default loading message that appears in the top right corner of the screen can be modified, its rendering
      customised or even turned off completely. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12443"></a>21.9.1.&nbsp;Changing the message</h3></div></div><div></div></div><p> To change the message from the default "Please Wait..." to something different, set the value of
          <tt class="literal">Seam.Remoting.loadingMessage</tt>: </p><pre class="programlisting">Seam.Remoting.loadingMessage = "Loading..."; </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12453"></a>21.9.2.&nbsp;Hiding the loading message</h3></div></div><div></div></div><p> To completely suppress the display of the loading message, override the implementation of
          <tt class="literal">displayLoadingMessage()</tt> and <tt class="literal">hideLoadingMessage()</tt> with functions that
        instead do nothing: </p><pre class="programlisting">// don't display the loading indicator
Seam.Remoting.displayLoadingMessage = function() {};
Seam.Remoting.hideLoadingMessage = function() {};</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12466"></a>21.9.3.&nbsp;A Custom Loading Indicator</h3></div></div><div></div></div><p> It is also possible to override the loading indicator to display an animated icon, or anything else that
        you want. To do this override the <tt class="literal">displayLoadingMessage()</tt> and
        <tt class="literal">hideLoadingMessage()</tt> messages with your own implementation: </p><pre class="programlisting">  Seam.Remoting.displayLoadingMessage = function() {
    // Write code here to display the indicator
  };
  
  Seam.Remoting.hideLoadingMessage = function() {
    // Write code here to hide the indicator
  };</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12479"></a>21.10.&nbsp;Controlling what data is returned</h2></div></div><div></div></div><p> When a remote method is executed, the result is serialized into an XML response that is returned to the
      client. This response is then unmarshaled by the client into a Javascript object. For complex types (i.e.
      Javabeans) that include references to other objects, all of these referenced objects are also serialized as part
      of the response. These objects may reference other objects, which may reference other objects, and so forth. If
      left unchecked, this object "graph" could potentially be enormous, depending on what relationships exist between
      your objects. And as a side issue (besides the potential verbosity of the response), you might also wish to
      prevent sensitive information from being exposed to the client. </p><p> Seam Remoting provides a simple means to "constrain" the object graph, by specifying the
      <tt class="literal">exclude</tt> field of the remote method's <tt class="literal">@WebRemote</tt> annotation. This field
      accepts a String array containing one or more paths specified using dot notation. When invoking a remote method,
      the objects in the result's object graph that match these paths are excluded from the serialized result packet. </p><p> For all our examples, we'll use the following <tt class="literal">Widget</tt> class: </p><pre class="programlisting">@Name("widget")
public class Widget
{
  private String value;
  private String secret;
  private Widget child;
  private Map&lt;String,Widget&gt; widgetMap;
  private List&lt;Widget&gt; widgetList;
  
  // getters and setters for all fields
}</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12499"></a>21.10.1.&nbsp;Constraining normal fields</h3></div></div><div></div></div><p> If your remote method returns an instance of <tt class="literal">Widget</tt>, but you don't want to expose the
          <tt class="literal">secret</tt> field because it contains sensitive information, you would constrain it like this: </p><pre class="programlisting">@WebRemote(exclude = {"secret"})
public Widget getWidget(); </pre><p> The value "secret" refers to the <tt class="literal">secret</tt> field of the returned object. Now, suppose that
        we don't care about exposing this particular field to the client. Instead, notice that the
        <tt class="literal">Widget</tt> value that is returned has a field <tt class="literal">child</tt> that is also a
          <tt class="literal">Widget</tt>. What if we want to hide the <tt class="literal">child</tt>'s <tt class="literal">secret</tt>
        value instead? We can do this by using dot notation to specify this field's path within the result's object
        graph: </p><pre class="programlisting">@WebRemote(exclude = {"child.secret"})
public Widget getWidget();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12534"></a>21.10.2.&nbsp;Constraining Maps and Collections</h3></div></div><div></div></div><p> The other place that objects can exist within an object graph are within a <tt class="literal">Map</tt> or some
        kind of collection (<tt class="literal">List</tt>, <tt class="literal">Set</tt>, <tt class="literal">Array</tt>, etc). Collections
        are easy, and are treated like any other field. For example, if our <tt class="literal">Widget</tt> contained a list
        of other <tt class="literal">Widget</tt>s in its <tt class="literal">widgetList</tt> field, to constrain the
        <tt class="literal">secret</tt> field of the <tt class="literal">Widget</tt>s in this list the annotation would look like
        this: </p><pre class="programlisting">@WebRemote(exclude = {"widgetList.secret"})
  public Widget getWidget();</pre><p> To constrain a <tt class="literal">Map</tt>'s key or value, the notation is slightly different. Appending
          <tt class="literal">[key]</tt> after the <tt class="literal">Map</tt>'s field name will constrain the
        <tt class="literal">Map</tt>'s key object values, while <tt class="literal">[value]</tt> will constrain the value object
        values. The following example demonstrates how the values of the <tt class="literal">widgetMap</tt> field have their
          <tt class="literal">secret</tt> field constrained: </p><pre class="programlisting">@WebRemote(exclude = {"widgetMap[value].secret"})
public Widget getWidget(); </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12593"></a>21.10.3.&nbsp;Constraining objects of a specific type</h3></div></div><div></div></div><p> There is one last notation that can be used to constrain the fields of a type of object no matter where in
        the result's object graph it appears. This notation uses either the name of the component (if the object is a
        Seam component) or the fully qualified class name (only if the object is not a Seam component) and is expressed
        using square brackets: </p><pre class="programlisting">@WebRemote(exclude = {"[widget].secret"})
public Widget getWidget(); </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12600"></a>21.10.4.&nbsp;Combining Constraints</h3></div></div><div></div></div><p> Constraints can also be combined, to filter objects from multiple paths within the object graph: </p><pre class="programlisting">@WebRemote(exclude = {"widgetList.secret", "widgetMap[value].secret"})
public Widget getWidget();</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12607"></a>21.11.&nbsp;JMS Messaging</h2></div></div><div></div></div><p> Seam Remoting provides experimental support for JMS Messaging. This section describes the JMS support that is
      currently implemented, but please note that this may change in the future. It is currently not recommended that
      this feature is used within a production environment. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12612"></a>21.11.1.&nbsp;Configuration</h3></div></div><div></div></div><p> Before you can subscribe to a JMS topic, you must first configure a list of the topics that can be
        subscribed to by Seam Remoting. List the topics under
          <tt class="literal">org.jboss.seam.remoting.messaging.subscriptionRegistry.allowedTopics</tt> in
          <tt class="literal">seam.properties</tt>, <tt class="literal">web.xml</tt> or <tt class="literal">components.xml</tt>. </p><pre class="programlisting">&lt;remoting:remoting poll-timeout="5" poll-interval="1"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12631"></a>21.11.2.&nbsp;Subscribing to a JMS Topic</h3></div></div><div></div></div><p> The following example demonstrates how to subscribe to a JMS Topic: </p><pre class="programlisting">function subscriptionCallback(message)
{
  if (message instanceof Seam.Remoting.TextMessage)
    alert("Received message: " + message.getText());
}           

Seam.Remoting.subscribe("topicName", subscriptionCallback);</pre><p> The <tt class="literal">Seam.Remoting.subscribe()</tt> method accepts two parameters, the first being the name of
        the JMS Topic to subscribe to, the second being the callback function to invoke when a message is received. </p><p> There are two types of messages supported, Text messages and Object messages. If you need to test for the
        type of message that is passed to your callback function you can use the <tt class="literal">instanceof</tt> operator
        to test whether the message is a <tt class="literal">Seam.Remoting.TextMessage</tt> or
          <tt class="literal">Seam.Remoting.ObjectMessage</tt>. A <tt class="literal">TextMessage</tt> contains the text value in
        its <tt class="literal">text</tt> field (or alternatively call <tt class="literal">getText()</tt> on it), while an
          <tt class="literal">ObjectMessage</tt> contains its object value in its <tt class="literal">value</tt> field (or call its
          <tt class="literal">getValue()</tt> method). </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12672"></a>21.11.3.&nbsp;Unsubscribing from a Topic</h3></div></div><div></div></div><p> To unsubscribe from a topic, call <tt class="literal">Seam.Remoting.unsubscribe()</tt> and pass in the topic
        name: </p><pre class="programlisting">Seam.Remoting.unsubscribe("topicName");</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12682"></a>21.11.4.&nbsp;Tuning the Polling Process</h3></div></div><div></div></div><p> There are two parameters which you can modify to control how polling occurs. The first one is
          <tt class="literal">Seam.Remoting.pollInterval</tt>, which controls how long to wait between subsequent polls for
        new messages. This parameter is expressed in seconds, and its default setting is 10. </p><p> The second parameter is <tt class="literal">Seam.Remoting.pollTimeout</tt>, and is also expressed as seconds. It
        controls how long a request to the server should wait for a new message before timing out and sending an empty
        response. Its default is 0 seconds, which means that when the server is polled, if there are no messages ready
        for delivery then an empty response will be immediately returned. </p><p> Caution should be used when setting a high <tt class="literal">pollTimeout</tt> value; each request that has to
        wait for a message means that a server thread is tied up until a message is received, or until the request times
        out. If many such requests are being served simultaneously, it could mean a large number of threads become tied
        up because of this reason. </p><p> It is recommended that you set these options via components.xml, however they can be overridden via
        Javascript if desired. The following example demonstrates how to configure the polling to occur much more
        aggressively. You should set these parameters to suitable values for your application: </p><p> Via components.xml: </p><pre class="programlisting">&lt;remoting:remoting poll-timeout="5" poll-interval="1"/&gt;</pre><p> Via JavaScript: </p><pre class="programlisting">// Only wait 1 second between receiving a poll response and sending the next poll request.
Seam.Remoting.pollInterval = 1;
  
// Wait up to 5 seconds on the server for new messages
Seam.Remoting.pollTimeout = 5;   </pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="gwt"></a>Chapter&nbsp;22.&nbsp;Seam and the Google Web Toolkit</h2></div></div><div></div></div><p>
    For those that prefer to use the Google Web Toolkit (GWT) to develop dynamic AJAX applications, Seam provides
    an integration layer that allows GWT widgets to interact directly with Seam components.
  </p><p>
    To use GWT, we assume that you are already familiar with the GWT tools - more information can be found at
    <a href="http://code.google.com/webtoolkit/" target="_top">http://code.google.com/webtoolkit/</a>.  This chapter 
    does not attempt to explain how GWT works or how to use it.
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12720"></a>22.1.&nbsp;Configuration</h2></div></div><div></div></div><p>
      There is no special configuration required to use GWT in a Seam application, however the Seam resource servlet 
      must be installed.  See <a href="#configuration" title="Chapter&nbsp;25.&nbsp;Configuring Seam and packaging Seam applications">Chapter&nbsp;25, <i>Configuring Seam and packaging Seam applications</i></a> for details.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12727"></a>22.2.&nbsp;Preparing your component</h2></div></div><div></div></div><p>
      The first step in preparing a Seam component to be called via GWT, is to create both synchronous and
      asynchronous service interfaces for the methods you wish to call.  Both of these interfaces should extend the
      GWT interface <tt class="literal">com.google.gwt.user.client.rpc.RemoteService</tt>:
    </p><pre class="programlisting">  public interface MyService extends RemoteService
  {
    public String askIt(String question);      
  }</pre><p>
      The asynchronous interface should be identical, except that it also contains an additional 
      <tt class="literal">AsyncCallback</tt> parameter for each of the methods it declares:    
    </p><pre class="programlisting">  public interface MyServiceAsync extends RemoteService 
  {
    public void askIt(String question, AsyncCallback callback);
  }</pre><p>
      The asynchronous interface, in this example <tt class="literal">MyServiceAsync</tt>, will be implemented by GWT and
      should never be implemented directly.
    </p><p>
      The next step, is to create a Seam component that implements the synchronous interface:
    </p><pre class="programlisting">  @Name("org.jboss.seam.example.remoting.gwt.client.MyService")
  public class ServiceImpl implements MyService
  {
    @WebRemote
    public String askIt(String question)
    {
      if (!validate(question)) 
      {
        throw new IllegalStateException("Hey, this shouldn't happen, I checked on the client, " +
               "but its always good to double check.");
      }
      return "42. Its the real question that you seek now.";
    }
   
    public boolean validate(String q) 
    {
      ValidationUtility util = new ValidationUtility();
      return util.isValid(q);
    }
  }</pre><p>
      The methods that should be made accessible via GWT need to be annotated with the 
      <tt class="literal">@WebRemote</tt> annotation, which is required for all web-remoteable methods.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12758"></a>22.3.&nbsp;Hooking up a GWT widget to the Seam component</h2></div></div><div></div></div><p>
      The next step, is to write a method that returns the asynchronous interface to the component.  This method
      can be located inside the widget class, and will be used by the widget to obtain a reference to the
      asynchronous client stub:
    </p><pre class="programlisting">   private MyServiceAsync getService() 
   {       
      String endpointURL = GWT.getModuleBaseURL() + "seam/resource/gwt";      
      
      MyServiceAsync svc = (MyServiceAsync) GWT.create(MyService.class);
      ((ServiceDefTarget) svc).setServiceEntryPoint(endpointURL);
      return svc;     
   }</pre><p>
       The final step is to write the widget code that invokes the method on the client stub.  The following example
       creates a simple user interface with a label, text input and a button:
    </p><pre class="programlisting">
public class AskQuestionWidget extends Composite
{
   private AbsolutePanel panel = new AbsolutePanel();
   
   public AskQuestionWidget() 
   {      
      Label lbl = new Label("OK, what do you want to know?");
      panel.add(lbl);
      final TextBox box = new TextBox();
      box.setText("What is the meaning of life?");
      panel.add(box);
      Button ok = new Button("Ask");
      ok.addClickListener(new ClickListener() 
      {
         public void onClick(Widget w)
         {
            ValidationUtility valid = new ValidationUtility();
            if (!valid.isValid(box.getText())) 
            {
               Window.alert("A question has to end with a '?'");
            } 
            else 
            {
               askServer(box.getText());
            } 
         }
      });
      panel.add(ok);
      
      initWidget(panel);
   }

   private void askServer(String text)
   {
      getService().askIt(text, new AsyncCallback() 
      {
         public void onFailure(Throwable t)
         {
            Window.alert(t.getMessage());
         }

         public void onSuccess(Object data)
         {
            Window.alert((String) data);
         }         
      });      
   }
   
   ...    
    </pre><p>
      When clicked, the button invokes the <tt class="literal">askServer()</tt> method passing the contents of the input text (in this
      example, validation is also performed to ensure that the input is a valid question).  The <tt class="literal">askServer()</tt>
      method acquires a reference to the asynchronous client stub (returned by the <tt class="literal">getService()</tt> method)
      and invokes the <tt class="literal">askIt()</tt> method.  The result (or error message if the call fails) is shown in an alert window.      
    </p><div class="mediaobject" align="center"><img src="../shared/images/gwt-helloworld.png" align="middle"></div><p>
      The complete code for this example can be found in the Seam distribution in the <tt class="literal">examples/remoting/gwt</tt>
      directory.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12793"></a>22.4.&nbsp;GWT Ant Targets</h2></div></div><div></div></div><p>
      For deployment of GWT apps, there is a compile-to-Javascript step (which compacts and obfuscates the code).  There is an
      ant utility which can be used instead of the command line or GUI utility that GWT provides.  To use this, you will need
      to have the ant task jar in your ant classpath, as well as GWT downloaded (which you will need for hosted mode anyway).
    </p><p>
      Then, in your ant file, place (near the top of your ant file):
    </p><pre class="programlisting">  &lt;taskdef uri="antlib:de.samaflost.gwttasks"
                resource="de/samaflost/gwttasks/antlib.xml"
                classpath="./lib/gwttasks.jar"/&gt;
   
  &lt;property file="build.properties"/&gt;</pre><p>
      Create a <tt class="literal">build.properties</tt> file, which has the contents:
    </p><pre class="programlisting">gwt.home=/gwt_home_dir</pre><p>
      This of course should point to the directory where GWT is installed.  Then to use it, create a target:
    </p><pre class="programlisting">  &lt;!-- the following are are handy utilities for doing GWT development.
      To use GWT, you will of course need to download GWT seperately --&gt;
  &lt;target name="gwt-compile"&gt;
      &lt;!-- in this case, we are "re homing" the gwt generated stuff, so in this case
      we can only have one GWT module - we are doing this deliberately to keep the URL short --&gt;
      &lt;delete&gt;
          &lt;fileset dir="view"/&gt;
      &lt;/delete&gt;
      &lt;gwt:compile outDir="build/gwt"
          gwtHome="${gwt.home}"
          classBase="${gwt.module.name}"
          sourceclasspath="src"/&gt;
      &lt;copy todir="view"&gt;
          &lt;fileset dir="build/gwt/${gwt.module.name}"/&gt;
      &lt;/copy&gt;
  &lt;/target&gt;</pre><p>
      This target when called will compile the GWT application, and copy it to the specified directory (which would be
      in the <tt class="literal">webapp</tt> part of your war - remember GWT generates HTML and Javascript artifacts).  You
      never edit the resulting code that <tt class="literal">gwt-compile</tt> generates - you always edit in the GWT source
      directory.
    </p><p>
      Remember that GWT comes with a hosted mode browser - you should be using that if you are developing with GWT.  If you
      aren't using that, and are just compiling it each time, you aren't getting the most out of the toolkit (in fact, if
      you can't or won't use the hosted mode browser, I would go far as to say you should NOT be using GWT at all - it's
      that valuable!).
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="spring"></a>Chapter&nbsp;23.&nbsp;Spring Framework integration</h2></div></div><div></div></div><p>The Spring integration module allows easy migration of Spring-based projects to Seam and allows Spring
        applications to take advantage of key Seam features like conversations and Seam's more sophisticated persistence
        context management.</p><p>Note! The Spring integration code is included in the jboss-seam-ioc library.  This dependency is required for
    all seam-spring integration techniques covered in this chapter.</p><p>Seam's support for Spring provides the ability to: </p><div class="itemizedlist"><ul type="disc"><li><p>inject Seam component instances into Spring beans</p></li><li><p>inject Spring beans into Seam components</p></li><li><p>turn Spring beans into Seam components</p></li><li><p>allow Spring beans to live in any Seam context</p></li><li><p>start a spring WebApplicationContext with a Seam component</p></li><li><p>Support for Spring PlatformTransactionManagement</p></li><li><p>provides a Seam managed replacement for Spring's <tt class="literal">OpenEntityManagerInViewFilter</tt> and <tt class="literal">OpenSessionInViewFilter</tt></p></li><li><p>Support for Spring <tt class="literal">TaskExecutors</tt> to back <tt class="literal">@Asynchronous</tt> calls</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12868"></a>23.1.&nbsp;Injecting Seam components into Spring beans</h2></div></div><div></div></div><p> Injecting Seam component instances into Spring beans is accomplished using the
                <tt class="literal">&lt;seam:instance/&gt;</tt> namespace handler. To enable the Seam namespace
            handler, the Seam namespace must be added to the Spring beans definition file:</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:seam="http://jboss.com/products/seam/spring-seam"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
                        http://jboss.com/products/seam/spring-seam 
                        http://jboss.com/products/seam/spring-seam-2.0.xsd"&gt;</pre><p> Now any Seam component may be injected into any Spring bean: </p><pre class="programlisting">&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="prototype"&gt;
    &lt;property name="someProperty"&gt;
        &lt;seam:instance name="someComponent"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> An EL expression may be used instead of a component name: </p><pre class="programlisting">&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="prototype"&gt;
    &lt;property name="someProperty"&gt;
        &lt;seam:instance name="#{someExpression}"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> Seam component instances may even be made available for injection into Spring beans by a Spring bean id. </p><pre class="programlisting">&lt;seam:instance name="someComponent" id="someSeamComponentInstance"/&gt;

&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="prototype"&gt;
    &lt;property name="someProperty" ref="someSeamComponentInstance"&gt;
&lt;/bean&gt;
</pre><p>Now for the caveat!</p><p> Seam was designed from the ground up to support a stateful component model with multiple contexts. Spring
            was not. Unlike Seam bijection, Spring injection does not occur at method invocation time. Instead,
            injection happens only when the Spring bean is instantiated. So the instance available when the bean is
            instantiated will be the same instance that the bean uses for the entire life of the bean. For example, if a
            Seam <tt class="literal">CONVERSATION</tt>-scoped component instance is directly injected into a singleton Spring
            bean, that singleton will hold a reference to the same instance long after the conversation is over! We call
            this problem <span class="emphasis"><em>scope impedance</em></span>. Seam bijection ensures that scope impedance is maintained
            naturally as an invocation flows through the system. In Spring, we need to inject a proxy of the Seam
            component, and resolve the reference when the proxy is invoked.</p><p>The <tt class="literal">&lt;seam:instance/&gt;</tt> tag lets us automatically proxy the Seam component.</p><pre class="programlisting">&lt;seam:instance id="seamManagedEM" name="someManagedEMComponent" proxy="true"/&gt;
        
&lt;bean id="someSpringBean" class="SomeSpringBeanClass"&gt;
    &lt;property name="entityManager" ref="seamManagedEM"&gt;
&lt;/bean&gt;</pre><p> This example shows one way to use a Seam-managed persistence context from a Spring bean. (For a more robust
            way to use Seam-managed persistence contexts as a replacement for the Spring
                <tt class="literal">OpenEntityManagerInView</tt> filter see section on 
                <a href="#spring-persistence" title="23.6.&nbsp;Using a Seam Managed Persistence Context in Spring">Using a Seam Managed Persistence Context in Spring</a>)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12915"></a>23.2.&nbsp;Injecting Spring beans into Seam components</h2></div></div><div></div></div><p> It is even easier to inject Spring beans into Seam component instances. Actually, there are two possible
            approaches: </p><div class="itemizedlist"><ul type="disc"><li><p> inject a Spring bean using an EL expression </p></li><li><p> make the Spring bean a Seam component </p></li></ul></div><p> We'll discuss the second option in the next section. The easiest approach is to access the Spring beans
            via EL. </p><p> The Spring <tt class="literal">DelegatingVariableResolver</tt> is an integration point Spring provides for
            integrating Spring with JSF. This <tt class="literal">VariableResolver</tt> makes all Spring beans available in EL
            by their bean id. You'll need to add the <tt class="literal">DelegatingVariableResolver</tt> to
                <tt class="literal">faces-config.xml</tt>: </p><pre class="programlisting">&lt;application&gt;
    &lt;variable-resolver&gt;
        org.springframework.web.jsf.DelegatingVariableResolver
    &lt;/variable-resolver&gt;
&lt;/application&gt;</pre><p> Then you can inject Spring beans using <tt class="literal">@In</tt>: </p><pre class="programlisting">@In("#{bookingService}")
private BookingService bookingService;</pre><p>The use of Spring beans in EL is not limited to injection. Spring beans may be used anywhere that EL
            expressions are used in Seam: process and pageflow definitions, working memory assertions, etc... </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12954"></a>23.3.&nbsp;Making a Spring bean into a Seam component</h2></div></div><div></div></div><p> The <tt class="literal">&lt;seam:component/&gt;</tt> namespace handler can be used to make any Spring
            bean a Seam component. Just place the <tt class="literal">&lt;seam:component/&gt;</tt> tag within the
            declaration of the bean that you wish to be a Seam component: </p><pre class="programlisting">&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="prototype"&gt;
    &lt;seam:component/&gt;
&lt;/bean&gt;</pre><p> By default, <tt class="literal">&lt;seam:component/&gt;</tt> will create a <tt class="literal">STATELESS</tt>
            Seam component with class and name provided in the bean definition. Occasionally, such as when a
                <tt class="literal">FactoryBean</tt> is used, the class of the Spring bean may not be the class appearing in
            the bean definition. In such cases the <tt class="literal">class</tt> should be explicitly specified. A Seam
            component name may be explicitly specified in cases where there is potential for a naming conflict. </p><p> The <tt class="literal">scope</tt> attribute of <tt class="literal">&lt;seam:component/&gt;</tt> may be used
            if you wish the Spring bean to be managed in a particular Seam scope. The Spring bean must be scoped to
                <tt class="literal">prototype</tt> if the Seam scope specified is anything other than
            <tt class="literal">STATELESS</tt>. Pre-existing Spring beans usually have a fundamentally stateless character, so
            this attribute is not usually needed. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12995"></a>23.4.&nbsp;Seam-scoped Spring beans</h2></div></div><div></div></div><p> The Seam integration package also lets you use Seam's contexts as Spring 2.0 style custom scopes. This
            lets you declare any Spring bean in any of Seam's contexts. However, note once again that Spring's component
            model was never architected to support statefulness, so please use this feature with great care. In
            particular, clustering of session or conversation scoped Spring beans is deeply problematic, and care must
            be taken when injecting a bean or component from a wider scope into a bean of a narrower scope.</p><p> By specifying <tt class="literal">&lt;seam:configure-scopes/&gt;</tt> once in a Spring bean factory
            configuration, all of the Seam scopes will be available to Spring beans as custom scopes. To associate a
            Spring bean with a particular Seam scope, specify the Seam scope in the <tt class="literal">scope</tt> attribute
            of the bean definition. </p><pre class="programlisting">&lt;!-- Only needs to be specified once per bean factory--&gt;
&lt;seam:configure-scopes/&gt;

...

&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="seam.CONVERSATION"/&gt;</pre><p> The prefix of the scope name may be changed by specifying the <tt class="literal">prefix</tt> attribute in the
                <tt class="literal">configure-scopes</tt> definition. (The default prefix is <tt class="literal">seam.</tt>) </p><p> Seam-scoped Spring beans defined this way can be injected into other Spring beans without the use of
                <tt class="literal">&lt;seam:instance/&gt;</tt>. However, care must be taken to ensure scope impedance
            is maintained. The normal approach used in Spring is to specify
            <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> in the bean definition. However, Seam-scoped Spring
            beans are <span class="emphasis"><em>not</em></span> compatible with <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt>. So
            if you need to inject a Seam-scoped Spring bean into a singleton,
            <tt class="literal">&lt;seam:instance/&gt;</tt> must be used: </p><pre class="programlisting">&lt;bean id="someSpringBean" class="SomeSpringBeanClass" scope="seam.CONVERSATION"/&gt;

...

&lt;bean id="someSingleton"&gt;
    &lt;property name="someSeamScopedSpringBean"&gt;
        &lt;seam:instance name="someSpringBean" proxy="true"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-transactions"></a>23.5.&nbsp;Using Spring PlatformTransactionManagement</h2></div></div><div></div></div><p>Spring provides an extensible transaction management abstraction with support for many
        transaction APIs (JPA, Hibernate, JDO, and JTA)  Spring also provides tight integrations with many application
        server TransactionManagers such as Websphere and Weblogic.  Spring
        transaction management exposes support for many advanced features such as nested
        transactions and supports full Java EE transaction propagation rules like REQUIRES_NEW and NOT_SUPPORTED.  For more
        information see the spring documentation
        <a href="http://static.springframework.org/spring/docs/2.0.x/reference/transaction.html" target="_top">here</a>.</p><p>To configure Seam to use Spring transactions enable the SpringTransaction component like so:</p><pre class="programlisting">
			&lt;spring:spring-transaction platform-transaction-manager="#{transactionManager}"/&gt;
		</pre><p>
			The <tt class="literal">spring:spring-transaction</tt> component will utilize Springs transaction synchronization
			capabilities for synchronization callbacks.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-persistence"></a>23.6.&nbsp;Using a Seam Managed Persistence Context in Spring</h2></div></div><div></div></div><p>One of the most powerful features of Seam is its conversation scope and the ability to
        have an EntityManager open for the life of a conversation.  This eliminates many
        of the problems associated with the detachment and re-attachment of entities as well as mitigates occurrences
        of the dreaded <tt class="literal">LazyInitializationException</tt>.  Spring does not provide a way to manage
        an persistence context beyond the scope of a single web request
        (<tt class="literal">OpenEntityManagerInViewFilter</tt>).  So, it would be nice if Spring developers
        could have access to a Seam managed persistence context using all of the same tools Spring provides
        for integration with JPA(e.g. <tt class="literal">PersistenceAnnotationBeanPostProcessor</tt>,
        <tt class="literal">JpaTemplate</tt>, etc.)</p><p>Seam provides a way for Spring to access a Seam managed persistence context with
        Spring's provided JPA tools bringing conversation scoped persistence context capabilities to
        Spring applications.</p><p>This integration work provides the following functionality:</p><div class="itemizedlist"><ul type="disc"><li><p>transparent access to a Seam managed persistence context using Spring provided tools</p></li><li><p>access to Seam conversation scoped persistence contexts in a non web request
                (e.g. asynchronous quartz job)</p></li><li><p>allows for using Seam managed persistence contexts with Spring managed transactions (will need to
                flush the persistence context manually)</p></li></ul></div><p>Spring's persistence context propagation model allows only one open EntityManager per EntityManagerFactory
        so the Seam integration works by wrapping an EntityManagerFactory around a Seam managed persistence
        context.</p><pre class="programlisting">&lt;bean id="seamEntityManagerFactory" class="org.jboss.seam.ioc.spring.SeamManagedEntityManagerFactoryBean"&gt;
   	&lt;property name="persistenceContextName" value="entityManager"/&gt;
&lt;/bean&gt;</pre><p>Where 'persistenceContextName' is the name of the Seam managed persistence context component.  By default
		this EntityManagerFactory has a unitName equal to  the Seam component name or in this case 'entityManager'.  
		If you wish to provide a different unitName you can do so by providing a persistenceUnitName like so:
		</p><pre class="programlisting">&lt;bean id="seamEntityManagerFactory" class="org.jboss.seam.ioc.spring.SeamManagedEntityManagerFactoryBean"&gt;
   	&lt;property name="persistenceContextName" value="entityManager"/&gt;
	&lt;property name="persistenceUnitName" value="bookingDatabase:extended"/&gt;
&lt;/bean&gt;</pre><p>This EntityManagerFactory can then be used in any Spring provided tools.  For example, 
		 using Spring's <tt class="literal">PersistenceAnnotationBeanPostProcessor</tt> is the exact same as before.</p><pre class="programlisting">&lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;</pre><p>If you define your real EntityManagerFactory in Spring but wish to use a Seam managed persistence context
		you can tell the <tt class="literal">PersistenceAnnotationBeanPostProcessor</tt> which persistenctUnitName you wish
		to use by default by specifying the <tt class="literal">defaultPersistenceUnitName</tt> property.
		</p><p>The <tt class="literal">applicationContext.xml</tt> might look like:</p><pre class="programlisting">&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
	&lt;property name="persistenceUnitName" value="bookingDatabase"/&gt;
&lt;/bean&gt;
&lt;bean id="seamEntityManagerFactory" class="org.jboss.seam.ioc.spring.SeamManagedEntityManagerFactoryBean"&gt;
   	&lt;property name="persistenceContextName" value="entityManager"/&gt;
	&lt;property name="persistenceUnitName" value="bookingDatabase:extended"/&gt;
&lt;/bean&gt;
&lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"&gt;
	&lt;property name="defaultPersistenceUnitName" value="bookingDatabase:extended"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">component.xml</tt> might look like:</p><pre class="programlisting">&lt;persistence:managed-persistence-context name="entityManager"
	auto-create="true" entity-manager-factory="#{entityManagerFactory}"/&gt;</pre><p><tt class="literal">JpaTemplate</tt> and <tt class="literal">JpaDaoSupport</tt> are configured the same way for a
		Seam managed persistence context as they would be fore a Seam managed persistence context.</p><pre class="programlisting">&lt;bean id="bookingService" class="org.jboss.seam.example.spring.BookingService"&gt;
	&lt;property name="entityManagerFactory" ref="seamEntityManagerFactory"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-hibernate"></a>23.7.&nbsp;Using a Seam Managed Hibernate Session in Spring</h2></div></div><div></div></div><p>The Seam Spring integration also provides support for complete access to a Seam managed Hibernate session 
        using spring's tools.  This integration is very similar to the <a href="#spring-persistence" title="23.6.&nbsp;Using a Seam Managed Persistence Context in Spring">JPA integration</a>.</p><p>Like Spring's JPA integration spring's propagation model allows only one open EntityManager per
        EntityManagerFactory per transaction??? to be available to spring tools.  So, the Seam Session integration works
        by wrapping a proxy SessionFactory around a Seam managed Hibernate session
        context.</p><pre class="programlisting">&lt;bean id="seamSessionFactory" class="org.jboss.seam.ioc.spring.SeamManagedSessionFactoryBean"&gt;
	&lt;property name="sessionName" value="hibernateSession"/&gt;
&lt;/bean&gt;</pre><p>Where 'sessionName' is the name of the <tt class="literal">persistence:managed-hibernate-session</tt> component.
		 This SessionFactory can then be used in any Spring provided tools.  The integration
		 also provides support for calls to <tt class="literal">SessionFactory.getCurrentInstance()</tt> as long as you call
		 getCurrentInstance() on the <tt class="literal">SeamManagedSessionFactory</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13157"></a>23.8.&nbsp;Spring Application Context as a Seam Component</h2></div></div><div></div></div><p> Although it is possible to use the Spring <tt class="literal">ContextLoaderListener</tt> to start your 
        	application's Spring ApplicationContext there are a couple of limitations.</p><div class="itemizedlist"><ul type="disc"><li><p> the Spring ApplicationContext must be started <span class="emphasis"><em>after</em></span> the 
                	<tt class="literal">SeamListener</tt> </p></li><li><p> it can be tricky starting a Spring ApplicationContext for use in Seam unit and integration
                	tests </p></li></ul></div><p> To overcome these two limitations the Spring integration includes a Seam component that will start a
        	Spring ApplicationContext.  To use this Seam component place the
        	<tt class="literal">&lt;spring:context-loader/&gt;</tt> definition in the <tt class="literal">components.xml</tt>.
        	Specify your Spring context file location in the <tt class="literal">config-locations</tt> attribute.  If more
        	than one config file is needed you can place them in the nested
        	<tt class="literal">&lt;spring:config-locations/&gt;</tt> element following standard
        	<tt class="literal">components.xml</tt> multi value practices. </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components" 
            xmlns:spring="http://jboss.com/products/seam/spring"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://jboss.com/products/seam/components 
                                http://jboss.com/products/seam/components-2.0.xsd
                                http://jboss.com/products/seam/spring 
                                http://jboss.com/products/seam/spring-2.0.xsd"&gt;

	&lt;spring:context-loader context-locations="/WEB-INF/applicationContext.xml"/&gt;

&lt;/components&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13197"></a>23.9.&nbsp;Using a Spring TaskExecutor for @Asynchronous</h2></div></div><div></div></div><p>Spring provides an abstraction for executing code asynchronously called a <tt class="literal">TaskExecutor</tt>.
        The Spring Seam integration allows for the use of a Spring <tt class="literal">TaskExecutor</tt> for executing
        immediate <tt class="literal">@Asynchronous</tt> method calls.  To enable this functionality install the
        <tt class="literal">SpringTaskExecutorDispatchor</tt> and provide a spring bean defined taskExecutor like so:</p><pre class="programlisting">
			&lt;spring:task-executor-dispatcher task-executor="#{springThreadPoolTaskExecutor}"/&gt;
		</pre><p>Because a Spring <tt class="literal">TaskExecutor</tt> does not support scheduling of an asynchronous event
        a fallback Seam <tt class="literal">Dispatcher</tt> can be provided to handle scheduled asynchronous event like so:</p><pre class="programlisting">
			&lt;!-- Install a ThreadPoolDispatcher to handle scheduled asynchronous event --&gt;
&lt;core:thread-pool-dispatcher name="threadPoolDispatcher"/&gt;
    
&lt;!-- Install the SpringDispatcher as default --&gt;
&lt;spring:task-executor-dispatcher task-executor="#{springThreadPoolTaskExecutor}" schedule-dispatcher="#{threadPoolDispatcher}"/&gt;
		</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="search"></a>Chapter&nbsp;24.&nbsp;Hibernate Search</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13229"></a>24.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Full text search engines like Apache Lucene&#8482; are a very powerful
    technology to bring free text/efficient queries to applications. If
    suffers several mismatches when dealing with an object domain model
    (keeping the index up to date, mismatch between the index structure and
    the domain model, querying mismatch...) Hibernate Search indexes your
    domain model thanks to a few annotations, takes care of the database /
    index synchronization and brings you back regular managed objects from
    free text queries. Hibernate Search is using Apache Lucene under the
    cover.</p><p>Hibernate Search has been designed to integrates nicely and as
    naturally as possible with JPA and Hibernate. As a natural extension,
    JBoss Seam provides an Hibernate Search integration.</p><p>Please refer to the <a href="???" target="_top">Hibernate Search
    documentation</a> for information specific to the Hibernate Search
    project.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13241"></a>24.2.&nbsp;Configuration</h2></div></div><div></div></div><p>Hibernate Search is configured either in the
    <tt class="filename">META-INF/persistence.xml</tt> or
    <tt class="filename">hibernate.cfg.xml</tt> file.</p><p>Hibernate Search configuration has sensible defaults for most
    configuration parameters, Here is a description of the minimal
    configuration to get started.</p><pre class="programlisting">   &lt;persistence-unit name="sample"&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         [...]
         <span class="bold"><b>&lt;!-- use a file system based index --&gt;
         &lt;property name="hibernate.search.default.directory_provider" 
                   value="org.hibernate.search.store.FSDirectoryProvider"/&gt;
         &lt;!-- directory where the indexes will be stored --&gt;
         &lt;property name="hibernate.search.default.indexBase" 
                   value="/Users/prod/apps/dvdstore/dvdindexes"/&gt;</b></span>
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;</pre><p>If you plan to target Hibernate Annotations or EntityManager 3.2.x
    (embedded into JBoss AS 4.2.GA), you also need to configure the
    appropriate event listeners.</p><pre class="programlisting">   &lt;persistence-unit name="sample"&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         [...]
         &lt;!-- use a file system based index --&gt;
         &lt;property name="hibernate.search.default.directory_provider" 
                   value="org.hibernate.search.store.FSDirectoryProvider"/&gt;
         &lt;!-- directory where the indexes will be stored --&gt;
         &lt;property name="hibernate.search.default.indexBase" 
                   value="/Users/prod/apps/dvdstore/dvdindexes"/&gt;

         <span class="bold"><b>&lt;property name="hibernate.ejb.event.post-insert" 
                   value="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
         &lt;property name="hibernate.ejb.event.post-update" 
                   value="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
         &lt;property name="hibernate.ejb.event.post-delete" 
                   value="org.hibernate.search.event.FullTextIndexEventListener"/&gt;</b></span>

      &lt;/properties&gt;
   &lt;/persistence-unit&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This step is no longer useful if Hibernate Annotation or
      EntityManager 3.3.x are used.</p></div><p>In addition to the configuration file, the following jars have to be
    deployed:</p><div class="itemizedlist"><ul type="disc"><li><p>hibernate-search.jar</p></li><li><p>hibernate-commons-annotations.jar</p></li><li><p>lucene-core.jar</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you deploy those in a EAR, don't forget to update
      <tt class="filename">application.xml</tt></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13286"></a>24.3.&nbsp;Usage</h2></div></div><div></div></div><p>Hibernate Search uses annotations to map entities to a Lucene index,
    check the <a href="http://www.hibernate.org/hib_docs/search/reference/en/html_single/" target="_top">reference
    documentation</a> for more informations.</p><p>Hibernate Search is fully integrated with the API and semantic of
    JPA / Hibernate. Switching from a HQL or Criteria based query requires
    just a few lines of code. The main API the application interacts with is
    the <tt class="classname">FullTextSession</tt> API (subclass of Hibernate's
    <tt class="classname">Session</tt>).</p><p>When Hibernate Search is present, JBoss Seam injects a
    <tt class="classname">FullTextSession</tt>.</p><pre class="programlisting">@Stateful
@Name("search")
public class FullTextSearchAction implements FullTextSearch, Serializable
{   
   @In
   <span class="bold"><b>FullTextSession session;</b></span>

   public void search(String searchString) {
      org.apache.lucene.query.Query luceneQuery = getLuceneQuery();
      org.hibernate.Query query session.createFullTextQuery(luceneQuery, Product.class);
      searchResults = query
            .setMaxResults(pageSize + 1)
            .setFirstResult(pageSize * currentPage)
            .list();
   }
   [...]
}  

</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">FullTextSession</tt> extends
      <tt class="classname">org.hibernate.Session</tt> so that it can be used as a
      regular Hibernate Session</p></div><p>If the Java Persistence API is used, a smoother integration is
    proposed.</p><pre class="programlisting">@Name("search")
public class FullTextSearchAction implements FullTextSearch, Serializable
{   
   @In
   <span class="bold"><b>FullTextEntityManager em;</b></span>

   public void search(String searchString) {
      org.apache.lucene.query.Query luceneQuery = getLuceneQuery();
      javax.persistence.Query query = em.createFullTextQuery(luceneQuery, Product.class);
      searchResults = query
            .setMaxResults(pageSize + 1)
            .setFirstResult(pageSize * currentPage)
            .getResultList();
   }
   [...]
}  </pre><p>When Hibernate Search is present, a
    <tt class="classname">FulltextEntityManager</tt> is injected.
    <tt class="classname">FullTextEntityManager</tt> extends
    <tt class="classname">EntityManager</tt> with search specific methods, the
    same way <tt class="classname">FullTextSession</tt> extends
    <tt class="classname">Session</tt>.</p><p>When an EJB 3.0 Session or Message Driven Bean injection is used (ie
    Bean using @PersistenceContext), it is not possible to replace the
    <tt class="classname">EntityManager</tt> interface by the
    <tt class="classname">FullTextEntityManager</tt> interface in the declaration
    statement. However, the implementation injected will be a
    <tt class="classname">FullTextEntityManager</tt> implementation: downcasting
    is then possible.</p><pre class="programlisting">@Stateful
@Name("search")
public class FullTextSearchAction implements FullTextSearch, Serializable
{   
   @PersistenceContext
   EntityManager em;

   public void search(String searchString) {
      org.apache.lucene.query.Query luceneQuery = getLuceneQuery();
      <span class="bold"><b>FullTextEntityManager ftEm = (FullTextEntityManager) em;</b></span>
      javax.persistence.Query query = ftEm.createFullTextQuery(luceneQuery, Product.class);
      searchResults = query
            .setMaxResults(pageSize + 1)
            .setFirstResult(pageSize * currentPage)
            .getResultList();
   }
   [...]
}  </pre><p></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>For people accustomed to Hibernate Search out of Seam, note that
      using <tt class="methodname">Search.createFullTextSession</tt> is not
      necessary.</p></div><p>Check the DVDStore or the blog examples of the JBoss Seam
    distribution for a concrete use of Hibernate Search.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;25.&nbsp;Configuring Seam and packaging Seam applications</h2></div></div><div></div></div><p> Configuration is a very boring topic and an extremely tedious pastime. Unfortunately, several lines of XML
        are required to integrate Seam into your JSF implementation and servlet container. There's no need to be too put
        off by the following sections; you'll never need to type any of this stuff yourself, since you can just copy and
        paste from the example applications! </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13374"></a>25.1.&nbsp;Basic Seam configuration</h2></div></div><div></div></div><p> First, let's look at the basic configuration that is needed whenever we use Seam with JSF. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13379"></a>25.1.1.&nbsp;Integrating Seam with JSF and your servlet container</h3></div></div><div></div></div><p> Of course, you need a faces servlet! </p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre><p> (You can adjust the URL pattern to suit your taste.) </p><p> In addition, Seam requires the following entry in your <tt class="literal">web.xml</tt> file: </p><pre class="programlisting">&lt;listener&gt;
    &lt;listener-class&gt;org.jboss.seam.servlet.SeamListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><p> This listener is responsible for bootstrapping Seam, and for destroying session and application
                contexts. </p><p> Some JSF implementations have a broken implementation of server-side state saving that interferes
                with Seam's conversation propagation. If you have problems with conversation propagation during form
                submissions, try switching to client-side state saving. You'll need this in <tt class="literal">web.xml</tt>: </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;javax.faces.STATE_SAVING_METHOD&lt;/param-name&gt;
    &lt;param-value&gt;client&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13404"></a>25.1.2.&nbsp;Using facelets</h3></div></div><div></div></div><p> If you want follow our advice and use facelets instead of JSP, add the following lines to
                    <tt class="literal">faces-config.xml</tt>: </p><pre class="programlisting">&lt;application&gt;
    &lt;view-handler&gt;com.sun.facelets.FaceletViewHandler&lt;/view-handler&gt;
&lt;/application&gt;</pre><p> And the following lines to <tt class="literal">web.xml</tt>: </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;javax.faces.DEFAULT_SUFFIX&lt;/param-name&gt;
    &lt;param-value&gt;.xhtml&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13421"></a>25.1.3.&nbsp;Seam Resource Servlet</h3></div></div><div></div></div><p> The Seam Resource Servlet provides resources used by Seam Remoting, captchas (see the security
                chapter) and some JSF UI controls. Configuring the Seam Resource Servlet requires the following entry in
                    <tt class="literal">web.xml</tt>: </p><pre class="programlisting">&lt;servlet&gt;
  &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.seam.servlet.SeamResourceServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Seam Resource Servlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/seam/resource/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13431"></a>25.1.4.&nbsp;Seam servlet filters</h3></div></div><div></div></div><p> Seam doesn't need any servlet filters for basic operation. However, there are several features which
                depend upon the use of filters. To make things easier, Seam lets you add and configure
                servlet filters just like you would configure other built-in Seam components. To take advantage of this
                feature, we must first install a master filter in <tt class="literal">web.xml</tt>: </p><pre class="programlisting">&lt;filter&gt;
    &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.jboss.seam.servlet.SeamFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre><p>The Seam master filter <span class="emphasis"><em>must</em></span> be the first filter specified in
                <tt class="literal">web.xml</tt>. This ensures it is run first. </p><p>To disable a built in filter, you can set <tt class="literal">disabled="true"</tt> on
            a particular filter.</p><p> Adding the master filter enables the following built-in filters. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13456"></a>25.1.4.1.&nbsp;Exception handling</h4></div></div><div></div></div><p> This filter provides the exception mapping functionality in <tt class="literal">pages.xml</tt> (almost
                    all applications will need this). It also takes care of rolling back uncommitted transactions when
                    uncaught exceptions occur. (According to the Java EE specification, the web container should do this
                    automatically, but we've found that this behavior cannot be relied upon in all application servers.
                    And it is certainly not required of plain servlet engines like Tomcat.) </p><p> By default, the exception handling filter will process all requests, however this behavior may be
                    adjusted by adding a <tt class="literal">&lt;web:exception-filter&gt;</tt> entry to
                        <tt class="literal">components.xml</tt>, as shown in this example: </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:web="http://jboss.com/products/seam/web"&gt;

    &lt;web:exception-filter url-pattern="*.seam"/&gt;

&lt;/components&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13481"></a>25.1.4.2.&nbsp;Conversation propagation with redirects</h4></div></div><div></div></div><p> This filter allows Seam to propagate the conversation context across browser redirects. It
                    intercepts any browser redirects and adds a request parameter that specifies the Seam conversation
                    identifier. </p><p> The redirect filter will process all requests by default, but this behavior can also be adjusted
                    in <tt class="literal">components.xml</tt>: </p><pre class="programlisting">&lt;web:redirect-filter url-pattern="*.seam"/&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13500"></a>25.1.4.3.&nbsp;Multipart form submissions</h4></div></div><div></div></div><p> This feature is necessary when using the Seam file upload JSF control. It detects multipart form
                    requests and processes them according to the multipart/form-data specification (RFC-2388). To
                    override the default settings, add the following entry to <tt class="literal">components.xml</tt>: </p><pre class="programlisting">&lt;web:multipart-filter create-temp-files="true" 
                      max-request-size="1000000" 
                      url-pattern="*.seam"/&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">create-temp-files</tt> &#8212; If set to <tt class="literal">true</tt>, uploaded
                            files are written to a temporary file (instead of held in memory). This may be an important
                            consideration if large file uploads are expected. The default setting is
                            <tt class="literal">false</tt>. </p></li><li><p>
                            <tt class="literal">max-request-size</tt> &#8212; If the size of a file upload request
                            (determined by reading the <tt class="literal">Content-Length</tt> header in the request) exceeds
                            this value, the request will be aborted. The default setting is 0 (no size limit). </p></li><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13538"></a>25.1.4.4.&nbsp;Character encoding</h4></div></div><div></div></div><p> Sets the character encoding of submitted form data. </p><p> This filter is not installed by default and requires an entry in
                    <tt class="literal">components.xml</tt> to enable it: </p><pre class="programlisting">&lt;web:character-encoding-filter encoding="UTF-16" 
                               override-client="true" 
                               url-pattern="*.seam"/&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">encoding</tt> &#8212; The encoding to use. </p></li><li><p>
                            <tt class="literal">override-client</tt> &#8212; If this is set to <tt class="literal">true</tt>,
                            the request encoding will be set to whatever is specified by <tt class="literal">encoding</tt> no
                            matter whether the request already specifies an encoding or not. If set to
                            <tt class="literal">false</tt>, the request encoding will only be set if the request doesn't
                            already specify an encoding. The default setting is <tt class="literal">false</tt>. </p></li><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13581"></a>25.1.4.5.&nbsp;RichFaces</h4></div></div><div></div></div><p> 
                  If RichFaces is used in your project, Seam will install the
                  RichFaces Ajax filter for you, making sure to install it
                  before all other built-in filters. You don't need to install
                  the RichFaces Ajax filter in <tt class="literal">web.xml</tt>
                  yourself.
                </p><p>
                  The RichFaces Ajax filter is only installed if the RichFaces
                  jars are present in your project.
                </p><p> To override the default settings, add the following entry to <tt class="literal">components.xml</tt>.
                    The options are the same as those specified in the RichFaces Developer Guide: </p><pre class="programlisting">&lt;web:ajax4jsf-filter force-parser="true" 
                     enable-cache="true" 
                     log4j-init-file="custom-log4j.xml"
                     url-pattern="*.seam"/&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">force-parser</tt> &#8212; forces all JSF pages to be validated by
                            Richfaces's XML syntax checker. If <tt class="literal">false</tt>, only AJAX responses are
                            validated and converted to well-formed XML. Setting <tt class="literal">force-parser</tt> to
                                <tt class="literal">false</tt> improves performance, but can provide visual artifacts on AJAX
                            updates. </p></li><li><p>
                            <tt class="literal">enable-cache</tt> &#8212; enables caching of framework-generated resources
                            (e.g. javascript, CSS, images, etc). When developing custom javascript or CSS, setting to
                            true prevents the browser from caching the resource. </p></li><li><p>
                            <tt class="literal">log4j-init-file</tt> &#8212; is used to setup per-application logging. A
                            path, relative to web application context, to the log4j.xml configuration file should be
                            provided. </p></li><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13632"></a>25.1.4.6.&nbsp;Identity Logging</h4></div></div><div></div></div><p> 
                    This filter adds the authenticated user name to the log4j mapped diagnostic context so that it 
                    can be included in formatted log output if desired, by adding %X{username} to the pattern.                       
                </p><p> By default, the logging filter will process all requests, however this behavior may be
                     adjusted by adding a <tt class="literal">&lt;web:logging-filter&gt;</tt> entry to
                     <tt class="literal">components.xml</tt>, as shown in this example: </p><pre class="programlisting">&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:web="http://jboss.com/products/seam/web"&gt;
    &lt;web:logging-filter url-pattern="*.seam"/&gt;
&lt;/components&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests the filter is active for. The
                            default is all requests. </p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13654"></a>25.1.4.7.&nbsp;Context management for custom servlets</h4></div></div><div></div></div><p> Requests sent direct to some servlet other than the JSF servlet are not processed through the JSF
                    lifecycle, so Seam provides a servlet filter that can be applied to any other servlet that needs
                    access to Seam components. </p><p> This filter allows custom servlets to interact with the Seam contexts. It sets up the Seam
                    contexts at the beginning of each request, and tears them down at the end of the request. You should
                    make sure that this filter is <span class="emphasis"><em>never</em></span> applied to the JSF
                    <tt class="literal">FacesServlet</tt>. Seam uses the phase listener for context management in a JSF
                    request. </p><p> This filter is not installed by default and requires an entry in
                    <tt class="literal">components.xml</tt> to enable it: </p><pre class="programlisting">&lt;web:context-filter url-pattern="/media/*"/&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">url-pattern</tt> &#8212; Used to specify which requests are filtered, the
                            default is all requests. If the url-pattern is specified for the context filter, then the
                            filter will be enabled (unless explicitly disabled). </p></li></ul></div><p> The context filter expects to find the conversation id of any conversation context in a request
                    parameter named <tt class="literal">conversationId</tt>. You are responsible for ensuring that it gets
                    sent in the request. </p><p> You are also responsible for ensuring propagation of any new conversation id back to the client.
                    Seam exposes the conversation id as a property of the built in component
                    <tt class="literal">conversation</tt>. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13691"></a>25.1.4.8.&nbsp;Adding custom filters</h4></div></div><div></div></div><p> Seam can install your filters for you, allowing you to specify <span class="emphasis"><em>where</em></span> in the
                    chain your filter is placed (the servlet specification doesn't provide a well defined order if you
                    specify your filters in a <tt class="literal">web.xml</tt>). Just add the <tt class="literal">@Filter</tt>
                    annotation to your Seam component (which must implement <tt class="literal">javax.servlet.Filter</tt>): </p><pre class="programlisting">@Startup
@Scope(APPLICATION)
@Name("org.jboss.seam.web.multipartFilter")
@BypassInterceptors
@Filter(within="org.jboss.seam.web.ajax4jsfFilter")
public class MultipartFilter extends AbstractFilter {</pre><p> Adding the <tt class="literal">@Startup</tt> annotation means thar the component is available during
                    Seam startup; bijection isn't available here (<tt class="literal">@BypassInterceptors</tt>); and the filter
                    should be further down the chain than the RichFaces filter
                        (<tt class="literal">@Filter(within="org.jboss.seam.web.ajax4jsfFilter")</tt>). </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13721"></a>25.1.5.&nbsp;Integrating Seam with your EJB container</h3></div></div><div></div></div><p> We need to apply the <tt class="literal">SeamInterceptor</tt> to our Seam components. The simplest way to
                do this across an entire application is to add the following interceptor configuration in
                    <tt class="literal">ejb-jar.xml</tt>: </p><pre class="programlisting">&lt;interceptors&gt;
    &lt;interceptor&gt;
        &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
    &lt;/interceptor&gt;
&lt;/interceptors&gt;
   
&lt;assembly-descriptor&gt;
    &lt;interceptor-binding&gt;
        &lt;ejb-name&gt;*&lt;/ejb-name&gt;
        &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
    &lt;/interceptor-binding&gt;
&lt;/assembly-descriptor&gt;
</pre><p> Seam needs to know where to go to find session beans in JNDI. One way to do this is specify the
                    <tt class="literal">@JndiName</tt> annotation on every session bean Seam component. However, this is quite
                tedious. A better approach is to specify a pattern that Seam can use to calculate the JNDI name from the
                EJB name. Unfortunately, there is no standard mapping to global JNDI defined in the EJB3 specification,
                so this mapping is vendor-specific. We usually specify this option in <tt class="literal">components.xml</tt>. </p><p> For JBoss AS, the following pattern is correct: </p><pre class="programlisting">&lt;core:init jndi-name="myEarName/#{ejbName}/local" /&gt;</pre><p> Where <tt class="literal">myEarName</tt> is the name of the EAR in which the bean is deployed. </p><p> Outside the context of an EAR (when using the JBoss Embeddable EJB3 container), the following pattern
                is the one to use: </p><pre class="programlisting">&lt;core:init jndi-name="#{ejbName}/local" /&gt;</pre><p> You'll have to experiment to find the right setting for other application servers. Note that some
                servers (such as GlassFish) require you to specify JNDI names for all EJB components explicitly (and
                tediously). In this case, you can pick your own pattern ;-) </p><p>
                In an EJB3 environment, we recommend the use of a special built-in component for transaction management,
                that is fully aware of container transactions, and can correctly process transaction success events
                registered with the <tt class="literal">Events</tt> component. If you don't add this line to your 
                <tt class="literal">components.xml</tt> file, Seam won't know when container-managed transactions end:
            </p><pre class="programlisting">&lt;transaction:ejb-transaction/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13767"></a>25.1.6.&nbsp;Don't forget!</h3></div></div><div></div></div><p> There is one final item you need to know about. You must place a <tt class="literal">seam.properties</tt>,
                    <tt class="literal">META-INF/seam.properties</tt> or <tt class="literal">META-INF/components.xml</tt> file in
                any archive in which your Seam components are deployed (even an empty properties file will do). At
                startup, Seam will scan any archives with <tt class="literal">seam.properties</tt> files for seam components. </p><p> In a web archive (WAR) file, you must place a <tt class="literal">seam.properties</tt> file in the
                    <tt class="literal">WEB-INF/classes</tt> directory if you have any Seam components included here. </p><p> That's why all the Seam examples have an empty <tt class="literal">seam.properties</tt> file. You can't
                just delete this file and expect everything to still work! </p><p> You might think this is silly and what kind of idiot framework designers would make an empty file
                affect the behavior of their software?? Well, this is a workaround for a limitation of the
                JVM&#8212;if we didn't use this mechanism, our next best option would be to force you to list every
                component explicitly in <tt class="literal">components.xml</tt>, just like some other competing frameworks do!
                I think you'll like our way better. </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13802"></a>25.2.&nbsp;Configuring Seam in Java EE 5</h2></div></div><div></div></div><div class="mediaobject" align="center"><img src="../shared/images/ee5.png" align="middle"></div><p> If you're running in a Java EE 5 environment, this is all the configuration required to start using Seam! </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13812"></a>25.2.1.&nbsp;Packaging</h3></div></div><div></div></div><p> Once you've packaged all this stuff together into an EAR, the archive structure will look something
                like this: </p><pre class="programlisting">my-application.ear/
    jboss-seam.jar
    lib/
        jboss-el.jar
    META-INF/
        MANIFEST.MF
        application.xml
    my-application.war/
        META-INF/
            MANIFEST.MF
        WEB-INF/
            web.xml
            components.xml
            faces-config.xml
            lib/
                jsf-facelets.jar
                jboss-seam-ui.jar
        login.jsp
        register.jsp
        ...
    my-application.jar/
        META-INF/
            MANIFEST.MF
            persistence.xml
        seam.properties
        org/
            jboss/
                myapplication/
                    User.class
                    Login.class
                    LoginBean.class
                    Register.class
                    RegisterBean.class
                    ...</pre><p>
                You should declare <tt class="literal">jboss-seam.jar</tt> as an ejb module in <tt class="literal">META-INF/application.xml</tt>; 
               <tt class="literal">jboss-el.jar</tt> should be placed in the EAR's lib directory (putting it in the EAR classpath.
            </p><p> If you want to use jBPM or Drools, you must include the needed jars in the EAR's lib directory.</p><p> If you want to use facelets (our recommendation), you must include
                <tt class="literal">jsf-facelets.jar</tt> in the <tt class="literal">WEB-INF/lib</tt> directory of the WAR. </p><p> If you want to use the Seam tag library (most Seam applications do), you must include
                    <tt class="literal">jboss-seam-ui.jar</tt> in the <tt class="literal">WEB-INF/lib</tt> directory of the WAR. If
                you want to use the PDF or email tag libraries, you need to put <tt class="literal">jboss-seam-pdf.jar</tt> or
                    <tt class="literal">jboss-seam-mail.jar</tt> in <tt class="literal">WEB-INF/lib</tt>. </p><p> If you want to use the Seam debug page (only works for applications using facelets), you must include
                    <tt class="literal">jboss-seam-debug.jar</tt> in the <tt class="literal">WEB-INF/lib</tt> directory of the WAR. </p><p> Seam ships with several example applications that are deployable in any Java EE container that
                supports EJB 3.0. </p><p> I really wish that was all there was to say on the topic of configuration but unfortunately we're
                only about a third of the way there. If you're too overwhelmed by all this tedious configuration stuff,
                feel free to skip over the rest of this section and come back to it later. </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13869"></a>25.3.&nbsp;Configuring Seam in J2EE</h2></div></div><div></div></div><p> Seam is useful even if you're not yet ready to take the plunge into EJB 3.0. In this case you would use
            Hibernate3 or JPA instead of EJB 3.0 persistence, and plain JavaBeans instead of session beans. You'll miss
            out on some of the nice features of session beans but it will be very easy to migrate to EJB 3.0 when you're
            ready and, in the meantime, you'll be able to take advantage of Seam's unique declarative state management
            architecture. </p><div class="mediaobject" align="center"><img src="../shared/images/hibernate-ee.png" align="middle"></div><p> Seam JavaBean components do not provide declarative transaction demarcation like session beans do. You
                <span class="emphasis"><em>could</em></span> manage your transactions manually using the JTA
            <tt class="literal">UserTransaction</tt> or declaratively using Seam's <tt class="literal">@Transactional</tt>
            annotation. But most applications will just use Seam managed transactions when using Hibernate with
            JavaBeans. </p><p> The Seam distribution includes a version of the booking example application that uses Hibernate3 and
            JavaBeans instead of EJB3, and another version that uses JPA and JavaBeans. These example applications are
            ready to deploy into any J2EE application server. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13892"></a>25.3.1.&nbsp;Boostrapping Hibernate in Seam</h3></div></div><div></div></div><p> Seam will bootstrap a Hibernate <tt class="literal">SessionFactory</tt> from your
                    <tt class="literal">hibernate.cfg.xml</tt> file if you install a built-in component: </p><pre class="programlisting">&lt;persistence:hibernate-session-factory name="hibernateSessionFactory"/&gt;</pre><p> You will also need to configure a <span class="emphasis"><em>managed session</em></span> if you want a Seam managed
                Hibernate <tt class="literal">Session</tt> to be available via injection. </p><pre class="programlisting">&lt;persistence:managed-hibernate-session name="hibernateSessionFactory"
                            session-factory="#{hibernateSessionFactory}"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13915"></a>25.3.2.&nbsp;Boostrapping JPA in Seam</h3></div></div><div></div></div><p> Seam will bootstrap a JPA <tt class="literal">EntityManagerFactory</tt> from your
                <tt class="literal">persistence.xml</tt> file if you install this built-in component: </p><pre class="programlisting">&lt;persistence:entity-manager-factory name="entityManagerFactory"/&gt;</pre><p> You will also need to configure a <span class="emphasis"><em>managed persistence context</em></span> if you want a
                Seam managed JPA <tt class="literal">EntityManager</tt> to be available via injection. </p><pre class="programlisting">&lt;persistence:managed-persistence-context name="entityManager"
                            entity-manager-factory="#{entityManagerFactory}"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13938"></a>25.3.3.&nbsp;Packaging</h3></div></div><div></div></div><p> We can package our application as a WAR, in the following structure: </p><pre class="programlisting">my-application.war/
    META-INF/
        MANIFEST.MF
    WEB-INF/
        web.xml
        components.xml
        faces-config.xml
        lib/
            jboss-seam.jar
            jboss-seam-ui.jar
            jboss-el.jar
            jsf-facelets.jar
            hibernate3.jar
            hibernate-annotations.jar
            hibernate-validator.jar
            ...
            my-application.jar/
                META-INF/
                   MANIFEST.MF
                seam.properties
                hibernate.cfg.xml
                org/
                    jboss/
                        myapplication/
                            User.class
                            Login.class
                            Register.class
                            ...
    login.jsp
    register.jsp
    ...</pre><p> If we want to deploy Hibernate in a non-EE environment like Tomcat or TestNG, we need to do a little
                bit more work. </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13947"></a>25.4.&nbsp;Configuring Seam in Java SE, without JBoss Embedded</h2></div></div><div></div></div><p> It is possible to use Seam completely outside of an EE environment. In this case, you need to tell Seam
            how to manage transactions, since there will be no JTA available. If you're using JPA, you can tell
            Seam to use JPA resource-local transactions, ie. <tt class="literal">EntityTransaction</tt>, like so: </p><pre class="programlisting">&lt;transaction:entity-transaction entity-manager="#{entityManager}"/&gt;</pre><p> If you're using Hibernate, you can tell Seam to use the Hibernate transaction API like this: </p><pre class="programlisting">&lt;transaction:hibernate-transaction session="#{session}"/&gt;</pre><p> Of course, you'll also need to define a datasource.</p><p> A better alternative is to use JBoss Embedded to get access to the EE APIs. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13965"></a>25.5.&nbsp;Configuring Seam in Java SE, with JBoss Embedded</h2></div></div><div></div></div><p> JBoss Embedded lets you run EJB3 components outside the context of the Java EE 5 application server. This
            is especially, but not only, useful for testing. </p><p> The Seam booking example application includes a TestNG integration test suite that runs on JBoss Embedded
            via <tt class="literal">SeamTest</tt>. </p><div class="mediaobject" align="center"><img src="../shared/images/testng.png" align="middle"></div><p> The booking example application may even be deployed to Tomcat. </p><div class="mediaobject" align="center"><img src="../shared/images/e-ejb3.png" align="middle"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config.install.embedded"></a>25.5.1.&nbsp;Installing Embedded JBoss</h3></div></div><div></div></div><p>
              Embedded JBoss must by installed into Tomcat for Seam applications
              to run correctly on it. Embedded JBoss only runs on JDK 1.5 (not JDK 1.6). 
              Embedded JBoss can be downloaded 
              <a href="http://sourceforge.net/project/showfiles.php?group_id=22866&amp;package_id=228977" target="_top">here</a>.
              The process for installing Embedded JBoss into Tomcat 6 is quite 
              simple. First, you should copy the Embedded JBoss JARs and 
              configuration files into Tomcat. 
            </p><div class="itemizedlist"><ul type="disc"><li><p> Copy all files and directories under the Embedded JBoss <tt class="literal">bootstrap</tt> and
                            <tt class="literal">lib</tt> directories, except for the <tt class="literal">jndi.properties</tt> file,
                        into the Tomcat <tt class="literal">lib</tt> directory. </p></li><li><p>Remove the <tt class="literal">annotations-api.jar</tt> file from the Tomcat <tt class="literal">lib</tt>
                        directory. </p></li></ul></div><p>Next, two configuration files need to be updated to add Embedded JBoss-specific functionality.</p><div class="itemizedlist"><ul type="disc"><li><p> Add the Embedded JBoss listener to <tt class="literal">conf/server.xml</tt>. It should appear after
                        all other listeners in the file.</p><pre class="programlisting">&lt;Listener className="org.jboss.embedded.tomcat.EmbeddedJBossBootstrapListener" /&gt;</pre></li><li><p>WAR file scanning should be enabled by adding a listener to
                            <tt class="literal">conf/context.xml</tt>. </p><pre class="programlisting">&lt;Listener className="org.jboss.embedded.tomcat.WebinfScanner" /&gt;</pre></li></ul></div><p>For more configuration options, please see the Embedded JBoss Tomcat integration 
                <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=EmbeddedAndTomcat" target="_top">wiki entry</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14044"></a>25.5.2.&nbsp;Packaging</h3></div></div><div></div></div><p> The archive structure of a WAR-based deployment on an servlet engine like Tomcat will look something
                like this: </p><pre class="programlisting">my-application.war/
    META-INF/
        MANIFEST.MF
    WEB-INF/
        web.xml
        components.xml
        faces-config.xml
        lib/
            jboss-seam.jar
            jboss-seam-ui.jar
            jboss-el.jar
            jsf-facelets.jar
            jsf-api.jar
            jsf-impl.jar
            ...
            my-application.jar/
                META-INF/
                    MANIFEST.MF
                    persistence.xml
                seam.properties
                org/
                    jboss/
                        myapplication/
                            User.class
                            Login.class
                            LoginBean.class
                            Register.class
                            RegisterBean.class
                            ...
    login.jsp
    register.jsp
    ...</pre><p> Most of the Seam example applications may be deployed to Tomcat by running <tt class="literal">ant
                deploy.tomcat</tt>. </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14056"></a>25.6.&nbsp;Configuring jBPM in Seam</h2></div></div><div></div></div><p> Seam's jBPM integration is not installed by default, so you'll need to enable jBPM by installing a
            built-in component. You'll also need to explicitly list your process and pageflow definitions. In
                <tt class="literal">components.xml</tt>: </p><pre class="programlisting">&lt;bpm:jbpm&gt;
    &lt;bpm:pageflow-definitions&gt;
        &lt;value&gt;createDocument.jpdl.xml&lt;/value&gt;
        &lt;value&gt;editDocument.jpdl.xml&lt;/value&gt;
        &lt;value&gt;approveDocument.jpdl.xml&lt;/value&gt;
    &lt;/bpm:pageflow-definitions&gt;
    &lt;bpm:process-definitions&gt;
        &lt;value&gt;documentLifecycle.jpdl.xml&lt;/value&gt;
    &lt;/bpm:process-definitions&gt;
&lt;/bpm:jbpm&gt;</pre><p> No further special configuration is needed if you only have pageflows. If you do have business process
            definitions, you need to provide a jBPM configuration, and a Hibernate configuration for jBPM. The Seam DVD
            Store demo includes example <tt class="literal">jbpm.cfg.xml</tt> and <tt class="literal">hibernate.cfg.xml</tt> files
            that will work with Seam: </p><pre class="programlisting">&lt;jbpm-configuration&gt;

  &lt;jbpm-context&gt;
    &lt;service name="persistence"&gt;
       &lt;factory&gt;
          &lt;bean class="org.jbpm.persistence.db.DbPersistenceServiceFactory"&gt;
             &lt;field name="isTransactionEnabled"&gt;&lt;false/&gt;&lt;/field&gt;
          &lt;/bean&gt;
       &lt;/factory&gt;
    &lt;/service&gt;
    &lt;service name="tx" factory="org.jbpm.tx.TxServiceFactory" /&gt;
    &lt;service name="message" factory="org.jbpm.msg.db.DbMessageServiceFactory" /&gt;
    &lt;service name="scheduler" factory="org.jbpm.scheduler.db.DbSchedulerServiceFactory" /&gt;
    &lt;service name="logging" factory="org.jbpm.logging.db.DbLoggingServiceFactory" /&gt;
    &lt;service name="authentication" 
             factory="org.jbpm.security.authentication.DefaultAuthenticationServiceFactory" /&gt;
  &lt;/jbpm-context&gt;

&lt;/jbpm-configuration&gt;</pre><p> The most important thing to notice here is that jBPM transaction control is disabled. Seam or EJB3 should
            control the JTA transactions. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14078"></a>25.6.1.&nbsp;Packaging</h3></div></div><div></div></div><p> There is not yet any well-defined packaging format for jBPM configuration and process/pageflow
                definition files. In the Seam examples we've decided to simply package all these files into the root of
                the EAR. In future, we will probably design some other standard packaging format. So the EAR looks
                something like this: </p><pre class="programlisting">my-application.ear/
    jboss-seam.jar
    lib/
       jboss-el.jar
       jbpm-3.1.jar
    META-INF/
        MANIFEST.MF
        application.xml
    my-application.war/
        META-INF/
            MANIFEST.MF
        WEB-INF/
            web.xml
            components.xml
            faces-config.xml
            lib/
                jsf-facelets.jar
                jboss-seam-ui.jar
        login.jsp
        register.jsp
        ...
    my-application.jar/
        META-INF/
            MANIFEST.MF
            persistence.xml
        seam.properties
        org/
            jboss/
                myapplication/
                    User.class
                    Login.class
                    LoginBean.class
                    Register.class
                    RegisterBean.class
                    ...
    jbpm.cfg.xml
    hibernate.cfg.xml
    createDocument.jpdl.xml
    editDocument.jpdl.xml
    approveDocument.jpdl.xml
    documentLifecycle.jpdl.xml</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14085"></a>25.7.&nbsp;Configuring Seam in a Portal</h2></div></div><div></div></div><p> To run a Seam application as a portlet, you'll need to provide certain portlet metadata
                (<tt class="literal">portlet.xml</tt>, etc) in addition to the usual Java EE metadata. See the
                <tt class="literal">examples/portal</tt> directory for an example of the booking demo preconfigured to run on
            JBoss Portal. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14096"></a>25.8.&nbsp;Configuring SFSB and Session Timeouts in JBoss AS</h2></div></div><div></div></div><p> It is very important that the timeout for Stateful Session Beans is set higher than the timeout for HTTP
            Sessions, otherwise SFSB's may time out before the user's HTTP session has ended. JBoss Application Server
            has a default session bean timeout of 30 minutes, which is configured in
                <tt class="literal">server/default/conf/standardjboss.xml</tt> (replace <span class="emphasis"><em>default</em></span> with your
            own configuration). </p><p> The default SFSB timeout can be adjusted by modifying the value of <tt class="literal">max-bean-life</tt> in
            the <tt class="literal">LRUStatefulContextCachePolicy</tt> cache configuration: </p><pre class="programlisting">&lt;container-cache-conf&gt;
    &lt;cache-policy&gt;org.jboss.ejb.plugins.LRUStatefulContextCachePolicy&lt;/cache-policy&gt;
    &lt;cache-policy-conf&gt;
        &lt;min-capacity&gt;50&lt;/min-capacity&gt;
        &lt;max-capacity&gt;1000000&lt;/max-capacity&gt;
        &lt;remover-period&gt;1800&lt;/remover-period&gt;

        &lt;!-- SFSB timeout in seconds; 1800 seconds == 30 minutes --&gt;
        &lt;max-bean-life&gt;1800&lt;/max-bean-life&gt;  

        &lt;overager-period&gt;300&lt;/overager-period&gt;
        &lt;max-bean-age&gt;600&lt;/max-bean-age&gt;
        &lt;resizer-period&gt;400&lt;/resizer-period&gt;
        &lt;max-cache-miss-period&gt;60&lt;/max-cache-miss-period&gt;
        &lt;min-cache-miss-period&gt;1&lt;/min-cache-miss-period&gt;
        &lt;cache-load-factor&gt;0.75&lt;/cache-load-factor&gt;
    &lt;/cache-policy-conf&gt;
&lt;/container-cache-conf&gt;</pre><p> The default HTTP session timeout can be modified in
                <tt class="literal">server/default/deploy/jbossweb-tomcat55.sar/conf/web.xml</tt> for JBoss 4.0.x, or in
                <tt class="literal">server/default/deploy/jboss-web.deployer/conf/web.xml</tt> for JBoss 4.2.x. The following
            entry in this file controls the default session timeout for all web applications: </p><pre class="programlisting">&lt;session-config&gt;
    &lt;!-- HTTP Session timeout, in minutes --&gt;
    &lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;</pre><p> To override this value for your own application, simply include this entry in your application's own
                <tt class="literal">web.xml</tt>. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="oc4j"></a>Chapter&nbsp;26.&nbsp;Seam on OC4J</h2></div></div><div></div></div><p>
      OC4J (Oracle Containers for Java) 11g (currently a "Technology Preview" 
      release) is Oracle's JEE 5 application server. We will will start by 
      looking at the building and deploying the Hotel Booking example 
      application which comes with Seam, and then at deploying a project 
      generated by seam-gen. This project will integrate Seam, RichFaces Ajax 
      and components, Seam Security (with Drools), Facelets and JPA provided 
      by Hibernate.
    </p><p>
      This section requires you to use OC4J 11g Technology Preview (not OC4J 
      10g). You can download OC4J 11g from 
      <a href="http://www.oracle.com/technology/tech/java/oc4j/11/" target="_top">http://www.oracle.com/technology/tech/java/oc4j/11/</a>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14142"></a>26.1.&nbsp;The <tt class="literal">jee5/booking</tt> example</h2></div></div><div></div></div><p>
        The <tt class="literal">jee5/booking</tt> example is based on the Hotel 
        Booking example (which runs on JBoss AS). Out of the box it is designed 
        to run on Glassfish, but it's easy to build it for OC4J.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14153"></a>26.1.1.&nbsp;Booking Example Dependencies</h3></div></div><div></div></div><p>
          First, lets look at the dependencies of the booking example. Armed 
          with this knowledge we can look at the extra dependencies requirements 
          that OC4J adds.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <tt class="literal">jboss-seam.jar</tt> &#8212; We declare this as an 
              EJB3 module (why? well Seam needs to be able to interact with 
              container managed transactions; this is implemented as an EJB3 
              Stateful Session Bean)
            </p></li><li><p>
              <tt class="literal">jboss-el.jar</tt>
            </p></li><li><p>
              <tt class="literal">jboss-seam-ui.jar</tt> &#8212; Seam's JSF controls 
              depend on Apache's commons-beanutils
            </p></li><li><p>
              <tt class="literal">jboss-seam-debug.jar</tt>
            </p></li><li><p>
              <tt class="literal">jsf-facelets.jar</tt>
            </p></li><li><p>
              <tt class="literal">richfaces-api.jar</tt> &#8212; which requires Apache 
              commons-digester and commons-beanutils
            </p></li><li><p>
              <tt class="literal">richfaces-impl.jar</tt> and <tt class="literal">richfaces-ui.jar</tt> &#8212;
              which requires Apache commons-digester and commons-beanutils
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14204"></a>26.1.2.&nbsp;Extra dependencies required by OC4J</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
              Hibernate &#8212; of course, we decided to use Hibernate as the 
              JPA provider (rather than TopLink Essentials which ships with 
              OC4J).
            </p><p>
              To use Hibernate as your JPA provider you need three jars 
              (<tt class="literal">hibernate3.jar</tt>, <tt class="literal">hibernate-annotations.jar</tt>,
              <tt class="literal">hibernate-entitymanager.jar</tt>) and their 
              dependencies (<tt class="literal">jboss-common.jar</tt>, 
              <tt class="literal">jboss-archive-browsing.jar</tt> and
              <tt class="literal">ejb3-persistence.jar</tt>). You can find these 
              in the <tt class="literal">hibernate/lib</tt> directory in the Seam 
              distribution. 
            </p></li><li><p>
              <tt class="literal">thirdparty-all.jar</tt> &#8212; a selection of 
              third party libraries on which Seam depends (like javassist).
            </p></li></ul></div><p>
          Running Seam on most application servers (such as JBoss AS or 
          Glassfish) you only need to include the dependencies for those bits 
          of Seam you actually use (e.g. if you use Seam Text you need to 
          include ANTLR); but, on OC4J, due to its "interesting" classloading 
          you must always include them:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <tt class="literal">antlr-2.7.6.jar</tt> &#8212; needed for Seam Text 
              (not used in the example).
            </p></li><li><p>
              <tt class="literal">jbpm-jpdl.jar</tt> &#8212; needed for Seam's JBPM 
              integration (not used in the example).
            </p></li><li><p>
              Drools &#8212; needed for Seam Security. We aren't using Seam 
              security with Drools, but have to include it. Drools consists 
              of 5 jars - <tt class="literal">drools-core-4.0.0.jar</tt>,
              <tt class="literal">drools-compiler-4.0.0.jar</tt>,
              <tt class="literal">janino-2.5.7.jar</tt>,
              <tt class="literal">mvel14-1.2rc1.jar</tt> and
              <tt class="literal">antlr-runtime-3.0.jar</tt>. Drools integration 
              is not used in the example.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14273"></a>26.1.3.&nbsp;Configuration file changes</h3></div></div><div></div></div><p>There are just a few changes to be made:</p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">web.xml</tt>
            </span></dt><dd><p>
                you need to declare all your ejb's in the 
                <tt class="literal">web.xml</tt>. This is a silly requirement of a 
                number of JEE 5 application servers - for example OC4J and 
                Glassfish.
              </p><pre class="programlisting">&lt;ejb-local-ref&gt;
   &lt;ejb-ref-name&gt;
      jboss-seam-jee5/AuthenticatorAction/local
   &lt;/ejb-ref-name&gt;
   &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
   &lt;local-home/&gt;
   &lt;local&gt;
      org.jboss.seam.example.booking.Authenticator
   &lt;/local&gt;
   &lt;ejb-link&gt;AuthenticatorAction&lt;/ejb-link&gt;
&lt;/ejb-local-ref&gt;</pre></dd><dt><span class="term">
              <tt class="literal">persistence.xml</tt>
            </span></dt><dd><p>
                you need to provide the correct configuration for your JPA 
                implementation. We are using Hibernate and due to OC4J 
                bundling an old ANTLR, we need to use an alternative query 
                factory, we also want to use the OC4J transaction manager:
              </p><pre class="programlisting">&lt;property 
   name="hibernate.query.factory_class"
   value="org.hibernate.hql.classic.ClassicQueryTranslatorFactory" /&gt;
&lt;property
   name="hibernate.transaction.manager_lookup_class"
   value="org.hibernate.transaction.OrionTransactionManagerLookup" /&gt;</pre></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14304"></a>26.1.4.&nbsp;Building the <tt class="literal">jee5/booking</tt> example</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify the following files in the project:</p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">build.xml</tt> &#8212; Un-comment the 
                  OC4J-related libraries
               </p></li><li><p>
                  <tt class="literal">resources/META-INF/persistence.xml</tt> &#8212;
                  Comment out the Glassfish properties and un-comment the OC4J 
                  properties.
                </p></li></ul></div></li><li><p>
              Build the demo app by running <tt class="literal">ant</tt>. The build 
              target is <tt class="literal">dist/jboss-seam-jee5.ear</tt>
            </p></li><li><p>
                Copy <tt class="literal">hsqldb.jar</tt> to OC4J:
                <tt class="literal">cp ../../seam-gen/lib/hsqldb.jar $ORACLE_HOME/j2ee/home/applib/</tt>
                (OC4J doesn't come with an embedded database so we decided to 
                use HSQLDB)
              </p></li></ol></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14345"></a>26.2.&nbsp;Deploying a Seam application to OC4J</h2></div></div><div></div></div><p>
        This mini-tutorial describes the (fairly tedious) steps required to 
        deploy a JEE 5 application to OC4J. It assumes you are deploying the 
        <tt class="literal">jee5/booking</tt> example, using the embedded hsqldb 
        database. To deploy another application you would need to alter the 
        datasource and application name.
      </p><div class="orderedlist"><ol type="1"><li><p>
            Download and unzip OC4J
          </p></li><li><p>
            Make sure you have <tt class="literal">$JAVA_HOME</tt> and
            <tt class="literal">$ORACLE_HOME</tt> set as environment variables 
            (<tt class="literal">$ORACLE_HOME</tt> is the directory to which you 
            unzip OC4J). For further information on installing OC4J, consult 
            the <tt class="literal">Readme.txt</tt> distributed with OC4J
          </p></li><li><p>
            Edit the OC4J datasource
            <tt class="literal">$ORACLE_HOME/j2ee/home/config/data-sources.xml</tt>
            and, inside <tt class="literal">&lt;data-sources&gt;</tt>, add
          </p><pre class="programlisting">&lt;managed-data-source
   connection-pool-name="jee5-connection-pool"
   jndi-name="jdbc/__default"
   name="jee5-managed-data-source" /&gt;
&lt;connection-pool name="jee5-connection-pool"&gt;
   &lt;connection-factory
      factory-class="org.hsqldb.jdbcDriver" 
      user="sa"
      password="" 
      url="jdbc:hsqldb:." /&gt;
&lt;/connection-pool&gt;</pre><p>
            The <tt class="literal">jndi-name</tt> is used as the
            <tt class="literal">jta-data-source</tt> in 
            <tt class="literal">persistence.xml</tt>.
          </p></li><li><p>
            Edit <tt class="literal">$ORACLE_HOME/j2ee/home/config/server.xml</tt>
           and, inside <tt class="literal">&lt;application-server&gt;</tt>, add
          </p><pre class="programlisting">&lt;application name="jboss-seam-jee5"
 path="../../home/applications/jboss-seam-jee5.ear"
 parent="default" 
 start="true" /&gt;</pre><p>
            To keep things simple use the same names as you used for project.
          </p></li><li><p>
            Edit <tt class="literal">$ORACLE_HOME/j2ee/home/config/default-web-site.xml</tt>,
            and, inside <tt class="literal">&lt;web-site&gt;</tt>, add
          </p><pre class="programlisting">&lt;web-app application="jboss-seam-jee5"
 name="jboss-seam-jee5" 
 load-on-startup="true"
 root="/seam-jee5" /&gt;</pre><p>
            The <tt class="literal">root</tt> is the context path you will put into 
            your web browser to access the application.
          </p></li><li><p>
            Copy the application to OC4J: 
            <tt class="literal">cp dist/jboss-seam-jee5.ear $ORACLE_HOME/j2ee/home/applications/</tt>
           </p></li><li><p>
            Start OC4J:
            <tt class="literal">$ORACLE_HOME/bin/oc4j -start</tt>
          </p><p>
            You will be asked to set the admin password if this is
            the first time you've started OC4J
          </p></li><li><p>
            Checkout the app at:
            <tt class="literal">http://localhost:8888/seam-jee5</tt>
          </p></li><li><p>
            You can stop the server by pressing <tt class="literal">CTRL-C</tt> in 
            the console on which the server is running.
          </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14449"></a>26.3.&nbsp;
        Deploying an application created using <tt class="literal">seam-gen</tt>
        to OC4J
      </h2></div></div><div></div></div><p>
        The following explanation assumes you are using the command line and 
        a simple text editor, but of course you can use your favourite IDE - 
        <tt class="literal">seam-gen</tt> projects come with support for Eclipse 
        and Netbeans.
      </p><p>
        We start by creating a pretty simple application using
        <tt class="literal">seam-gen</tt>.  <tt class="literal">seam-gen</tt> uses 
        Hibernate Tools to reverse engineer a database schema to JPA entity 
        beans; it also genereates Seam Application Framework components and 
        JSF views for CRUD. This tutorial uses MySQL (but of course you 
        could use any database, altering the SQL as appropriate); install, 
        configure and run MySQL, then create a database with some sample 
        data.
      </p><p>
        Next, run <tt class="literal">./seam setup</tt> in the seam directory. 
      </p><pre class="programlisting">&gt; ./seam setup
Buildfile: build.xml

setup:
    [echo] Welcome to seam-gen :-)
    [input] Enter your Java project workspace (the directory that contains your Seam projects) [/home/pmuir/workspace] [/home/pmuir/workspace]

    [input] Enter your JBoss home directory [/home/pmuir/java/jboss-4.2.1.GA] [/home/pmuir/java/jboss-4.2.1.GA]

    [input] Enter the project name [oc4j-example] [oc4j-example]

    [input] Is this project deployed as an EAR (with EJB components) or a WAR (with no EJB support) [ear]  ([ear], war, )

    [input] Enter the Java package name for your session beans [org.jboss.seam.tutorial.oc4j.action] [org.jboss.seam.tutorial.oc4j.action]

    [input] Enter the Java package name for your entity beans [org.jboss.seam.tutorial.oc4j.model] [org.jboss.seam.tutorial.oc4j.model]

    [input] Enter the Java package name for your test cases [org.jboss.seam.tutorial.oc4j.test] [org.jboss.seam.tutorial.oc4j.test]

    [input] What kind of database are you using? [mysql]  (hsql, [mysql], oracle, postgres, mssql, db2, sybase, enterprisedb, )

    [input] Enter the Hibernate dialect for your database [org.hibernate.dialect.MySQLDialect] [org.hibernate.dialect.MySQLDialect]

    [input] Enter the filesystem path to the JDBC driver jar [lib/mysql.jar] [lib/mysql.jar]

    [input] Enter JDBC driver class for your database [com.mysql.jdbc.Driver] [com.mysql.jdbc.Driver]

    [input] Enter the JDBC URL for your database [jdbc:mysql:///oc4j] [jdbc:mysql:///oc4j]

    [input] Enter database username [user] [user]

    [input] Enter database password [password] [password]

    [input] skipping input as property hibernate.default_schema.new has already been set.
    [input] Enter the database catalog name (it is OK to leave this blank) [] []

    [input] Are you working with tables that already exist in the database? [y]  ([y], n, )

    [input] Do you want to drop and recreate the database tables and data in import.sql each time you deploy? [n]  (y, [n], )

    [propertyfile] Updating property file: /home/pmuir/workspace/jboss-seam/seam-gen/build.properties
    [echo] Installing JDBC driver jar to JBoss server
    [echo] Type 'seam new-project' to create the new project

BUILD SUCCESSFUL</pre><p>
        Type <tt class="literal">./seam new-project</tt> to create your project and
        <tt class="literal">cd</tt> to the newly created project.
      </p><p>
        Type <tt class="literal">./seam generate-entities</tt> to run create the 
        entities, the Seam Application Framework classes and the relevant 
        views.
      </p><p>
        We now need to make some changes to the generated project. Let's 
        start with the configuration files:
      </p><div class="variablelist"><dl><dt><span class="term">
            <tt class="literal">resources/META-INF/persistence-dev.xml</tt>
          </span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
                  Alter the <tt class="literal">jta-data-source</tt> to be 
                  <tt class="literal">jdbc/__oc4jExample</tt> (and use this as the
                  <tt class="literal">jndi-name</tt> when creating the data source 
                  in <tt class="literal">data-sources.xml</tt>).
                </p></li><li><p>Add the properties (described above):</p><pre class="programlisting">&lt;property name="hibernate.query.factory_class"
   value="org.hibernate.hql.classic.ClassicQueryTranslatorFactory" /&gt;
&lt;property name="hibernate.transaction.manager_lookup_class"
   value="org.hibernate.transaction.OrionTransactionManagerLookup" /&gt;
&lt;property name="hibernate.transaction.flush_before_completion" 
   value="true"/&gt;
&lt;property name="hibernate.cache.provider_class" 
   value="org.hibernate.cache.HashtableCacheProvider"/&gt;</pre></li><li><p>
                  Remove the JBoss AS specific method of exposing the
                  EntityManagerFactory:
                </p><pre class="programlisting">&lt;property 
 name="jboss.entity.manager.factory.jndi.name" 
 value="java:/oc4j-exampleEntityManagerFactory"&gt;</pre></li><li><p>
                  You'll need to alter <tt class="literal">persistence-prod.xml</tt>
                  as well if you want to deploy to OC4J using the prod profile.
                </p></li></ul></div></dd><dt><span class="term">
            <tt class="literal">resources/META-INF/jboss-app.xml</tt>
          </span></dt><dd><p>
              You can delete this file as we aren't deploying to JBoss AS 
              (<tt class="literal">jboss-app.xml</tt> is used to enable 
              classloading isolation in JBoss AS)
            </p></dd><dt><span class="term">
            <tt class="literal">resources/*-ds.xml</tt>
          </span></dt><dd><p>
              You can delete these file as we aren't deploying to JBoss AS 
              (these files define datasources in JBoss AS, in OC4J you have 
              to edit the master <tt class="literal">data-sources.xml</tt> file)
            </p></dd><dt><span class="term">
            <tt class="literal">resources/WEB-INF/components.xml</tt>
          </span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
                  Enable container managed transaction integration - add the 
                  <tt class="literal">&lt;transaction:ejb-transaction /&gt;</tt>
                  component, and it's namespace declaration
                  <tt class="literal">xmlns:transaction="http://jboss.com/products/seam/transaction"</tt>
                </p></li><li><p>
                  Alter the <tt class="literal">jndi-pattern</tt> to 
                  <tt class="literal">java:comp/env/oc4j-example/#{ejbName}/local</tt>
                </p></li><li><p>
                  We want to use a Seam Managed Persistence Context in our 
                  application. Unfortunately OC4J doesn't expose the 
                  EntityManagerFactory in JNDI, but Seam provides a built-in
                  manager component:
                </p><pre class="programlisting">&lt;persistence:entity-manager-factory
 auto-create="true" 
 name="oc4jEntityManagerFactory"
 persistence-unit-name="oc4j-example" /&gt;</pre><p>
                  We then need to tell Seam to use it, so we alter the 
                  <tt class="literal">managed-persistence-context</tt> injecting 
                  the Entity Manager Factory:
                </p><pre class="programlisting">&lt;persistence:managed-persistence-context
 name="entityManager"
 auto-create="true"
 entity-manager-factory="#{oc4jEntityManagerFactory}" /&gt;
                </pre></li></ul></div></dd><dt><span class="term">
            <tt class="literal">resources/WEB-INF/web.xml</tt>
          </span></dt><dd><p>
              You need to declare all your EJBs here. Remember to include 
              the Seam container managed transaction integration:
            </p><pre class="programlisting">&lt;ejb-local-ref&gt;
   &lt;ejb-ref-name&gt;
      oc4j-example/EjbSynchronizations/local
   &lt;/ejb-ref-name&gt;
   &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
   &lt;local&gt;
      org.jboss.seam.transaction.LocalEjbSynchronizations
   &lt;/local&gt;
   &lt;ejb-link&gt;EjbSynchronizations&lt;/ejb-link&gt;
&lt;/ejb-local-ref&gt;</pre></dd><dt><span class="term">
            <tt class="literal">build.xml</tt>
          </span></dt><dd>
            Change the default target to archive (we aren't going to cover 
            automatic deployment to OC4J).
          </dd></dl></div><p>Now, lets add in the extra dependencies:</p><div class="itemizedlist"><ul type="disc"><li><p>
            Hibernate &#8212;
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                Copy the jars from <tt class="literal">hibernate/lib</tt> directory 
                in the Seam distribution <tt class="literal">oc4j-example/lib</tt>:
                <tt class="literal">cp ../jboss-seam/hibernate/lib/*.jar lib/</tt>
              </p></li><li><p>
                Alter the build.xml to include them in the ear - add these 
                includes underneath the other libraries being copies:
              </p><pre class="programlisting">&lt;include name="lib/hibernate-annotations.jar" /&gt;
&lt;include name="lib/hibernate-entitymanager.jar" /&gt;
&lt;include name="lib/hibernate3.jar" /&gt;
&lt;include name="ejb3-peristence.jar" /&gt;
&lt;include name="lib/jboss-archive-browsing.jar" /&gt;
&lt;include name="lib/jboss-common.jar" /&gt;</pre></li></ul></div></li><li><p>
            <tt class="literal">thirdparty-all.jar</tt> &#8212; alter the 
            <tt class="literal">build.xml</tt> to include it - add this include:
          </p><pre class="programlisting">&lt;include name="lib/thirdparty-all.jar" /&gt;</pre></li><li><p>
            <tt class="literal">antlr-2.7.6.jar</tt> &#8212; alter the build.xml to 
            include it - add this include:
          </p><pre class="programlisting">&lt;include name="lib/antlr-*.jar" /&gt;</pre></li><li><p>
            As we are using Drools to provide Seam Security rules, we need 
            to add in Eclipse JDT compiler (you don't need this on JBoss AS; 
            again this is due to OC4J's classloading):
          </p><div class="itemizedlist"><ul type="circle"><li><pre class="programlisting">cp ../jboss-seam/seam-gen/lib/org.eclipse.jdt.core*.jar lib/</pre></li><li><p>
                Alter the build.xml to include them in the ear:
              </p><pre class="programlisting">&lt;include name="lib/org.eclipse.jdt.core*.jar" /&gt;</pre></li></ul></div></li></ul></div><p>You should end up with something like:</p><pre class="programlisting">&lt;fileset dir="${basedir}"&gt;
   &lt;!-- other libraries added by seam-gen --&gt;
   &lt;include name="lib/hibernate-annotations.jar" /&gt;
   &lt;include name="lib/hibernate-entitymanager.jar" /&gt;
   &lt;include name="lib/hibernate3.jar" /&gt;
   &lt;include name="lib/jboss-archive-browsing.jar" /&gt;
   &lt;include name="lib/jboss-common.jar" /&gt;
   &lt;include name="lib/thirdparty-all.jar" /&gt;
   &lt;include name="lib/antlr-*.jar" /&gt;
   &lt;include name="lib/org.eclipse.jdt.core*.jar" /&gt;
&lt;/fileset&gt;</pre><p>
        Finally, lets link our <tt class="literal">User</tt> entity into Seam 
        Security (we have a <tt class="literal">User</tt> table with a 
        <tt class="literal">username</tt> column and a <tt class="literal">password</tt> 
        column). We're going to make our authentictor a Stateless Session 
        Bean (OC4J is a EJB3 container after all!):
      </p><div class="orderedlist"><ol type="1"><li><div class="itemizedlist"><ul type="disc"><li><p>
                Add the <tt class="literal">@Stateless</tt> annotation.
              </p></li><li><p>
                Rename the class to <tt class="literal">AuthenticatorAction</tt>
              </p></li><li><p>
                Create an interface called <tt class="literal">Authenticator</tt>
                which <tt class="literal">AuthenticatorAction</tt> implements (EJB3 
                requires session beans to have a local interface). Annotate 
                the interface with <tt class="literal">@Local</tt>, and add a 
                single method with same signature as the <tt class="literal">authenticate</tt>
                in <tt class="literal">AuthenticatorAction</tt>.
              </p></li></ul></div><pre class="programlisting">@Name("authenticator") @Stateless public class
            AuthenticatorAction implements Authenticator {</pre><pre class="programlisting">@Local public interface Authenticator { 
  public boolean authenticate(); 
}</pre></li><li><p>
            Use <tt class="literal">@PersistenceContext</tt> to inject an 
            EntityManager:
          </p><pre class="programlisting">@PersistenceContext private EntityManager entityManager;</pre></li><li><p>
            Implement authenticate:
          </p><pre class="programlisting">public boolean authenticate() {
   List &amp;lt;User&amp;gt; users = entityManager .createQuery("select u from User u where 
   u.username = #{identity.username} and 
   u.password = #{identity.password}") .getResultList();
   if (users.size() == 1) {
      identity.addRole("admin"); 
      return true; 
   } else {
      return false; 
   } 
}</pre></li><li><p>
             And then add the EJB3 reference to <tt class="literal">web.xml</tt>:
          </p><pre class="programlisting">&lt;ejb-local-ref&gt;
   &lt;ejb-ref-name&gt;
      oc4j-example/AuthenticatorAction/local
   &lt;/ejb-ref-name&gt;
   &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
   &lt;local&gt;
      org.jboss.seam.tutorial.oc4j.action.Authenticator
   &lt;/local&gt;
   &lt;ejb-link&gt;AuthenticatorAction&lt;/ejb-link&gt;
&lt;/ejb-local-ref&gt;</pre></li></ol></div><p>
      Now you can go on and customize your application.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14744"></a>26.3.1.&nbsp;OC4J Deployment Descriptors for the seam-gen'd application</h3></div></div><div></div></div><p>
          To deploy your application use the deployment instructions above in 
          conjunction with these deployment descriptors:
        </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">$ORACLE_HOME/j2ee/home/config/data-sources.xml</tt>
            </span></dt><dd><pre class="programlisting">&lt;managed-data-source
   connection-pool-name="oc4j-example-connection-pool"
   jndi-name="jdbc/__oc4jExample"
   name="oc4j-example-managed-data-source" /&gt;
&lt;connection-pool
   name="oc4j-example-connection-pool"&gt;
   &lt;connection-factory
      factory-class="com.mysql.jdbc.Driver"
      user="username" 
      password="password"
      url="jdbc:mysql:///oc4j" /&gt;
&lt;/connection-pool&gt;</pre></dd><dt><span class="term">
              <tt class="literal">$ORACLE_HOME/j2ee/home/config/server.xml</tt>
            </span></dt><dd><pre class="programlisting">&lt;application name="oc4j-example"
 path="../../home/applications/oc4j-example.ear"
 parent="default"
 start="true" /&gt;</pre></dd><dt><span class="term">
              <tt class="literal">$ORACLE_HOME/j2ee/home/config/default-web-site.xml</tt>
            </span></dt><dd><pre class="programlisting">&lt;web-app application="oc4j-example"
 name="oc4j-example" 
 load-on-startup="true"
 root="/oc4j-example" /&gt;</pre></dd></dl></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="annotations"></a>Chapter&nbsp;27.&nbsp;Seam annotations</h2></div></div><div></div></div><p> When you write a Seam application, you'll use a lot of annotations. Seam lets you use annotations to achieve
        a declarative style of programming. Most of the annotations you'll use are defined by the EJB 3.0 specification.
        The annotations for data validation are defined by the Hibernate Validator package. Finally, Seam defines its
        own set of annotations, which we'll describe in this chapter. </p><p> All of these annotations are defined in the package <tt class="literal">org.jboss.seam.annotations</tt>. </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14787"></a>27.1.&nbsp;Annotations for component definition</h2></div></div><div></div></div><p> The first group of annotations lets you define a Seam component. These annotations appear on the
            component class. </p><div class="variablelist"><dl><dt><a name="name-annotation"></a><span class="term">
                    <tt class="literal">@Name</tt>
                </span></dt><dd><pre class="programlisting">@Name("componentName")</pre><p> Defines the Seam component name for a class. This annotation is required for all Seam
                        components. </p></dd><dt><a name="scope-annotation"></a><span class="term">
                    <tt class="literal">@Scope</tt>
                </span></dt><dd><pre class="programlisting">@Scope(ScopeType.CONVERSATION)</pre><p> Defines the default context of the component. The possible values are defined by the
                            <tt class="literal">ScopeType</tt> enumeration: <tt class="literal">EVENT, PAGE, CONVERSATION, SESSION,
                            BUSINESS_PROCESS, APPLICATION, STATELESS</tt>. </p><p> When no scope is explicitly specified, the default depends upon the component type. For
                        stateless session beans, the default is <tt class="literal">STATELESS</tt>. For entity beans and
                        stateful session beans, the default is <tt class="literal">CONVERSATION</tt>. For JavaBeans, the
                        default is <tt class="literal">EVENT</tt>. </p></dd><dt><a name="role-annotation"></a><span class="term">
                    <tt class="literal">@Role</tt>
                </span></dt><dd><pre class="programlisting">@Role(name="roleName", scope=ScopeType.SESSION)</pre><p> Allows a Seam component to be bound to multiple contexts variables. The
                            <tt class="literal">@Name</tt>/<tt class="literal">@Scope</tt> annotations define a "default role". Each
                            <tt class="literal">@Role</tt> annotation defines an additional role. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">name</tt> &#8212; the context variable name. </p></li><li><p>
                                <tt class="literal">scope</tt> &#8212; the context variable scope. When no scope is
                                explicitly specified, the default depends upon the component type, as above. </p></li></ul></div></dd><dt><a name="roles-annotation"></a><span class="term">
                    <tt class="literal">@Roles</tt>
                </span></dt><dd><pre class="programlisting">@Roles({
        @Role(name="user", scope=ScopeType.CONVERSATION),
        @Role(name="currentUser", scope=ScopeType.SESSION)
    })</pre><p> Allows specification of multiple additional roles. </p></dd><dt><a name="intercept-annotation"></a><span class="term">
                    <tt class="literal">@BypassInterceptors</tt>
                </span></dt><dd><pre class="programlisting">@BypassInterceptors</pre><p>Disables Seam all interceptors on a particular component
                    or method of a component.</p></dd><dt><a name="jndiname-annotation"></a><span class="term">
                    <tt class="literal">@JndiName</tt>
                </span></dt><dd><pre class="programlisting">@JndiName("my/jndi/name")</pre><p> Specifies the JNDI name that Seam will use to look up the EJB component. If no JNDI name is
                        explicitly specified, Seam will use the JNDI pattern specified by
                            <tt class="literal">org.jboss.seam.core.init.jndiPattern</tt>. </p></dd><dt><a name="conversational-annotation"></a><span class="term">
                    <tt class="literal">@Conversational</tt>
                </span></dt><dd><pre class="programlisting">@Conversational</pre><p> Specifies that a conversation scope component is conversational, meaning that no method of
                        the component may be called unless a long-running conversation is active. </p></dd><dt><a name="startup-annotation"></a><span class="term">
                    <tt class="literal">@Startup</tt>
                </span></dt><dd><pre class="programlisting">@Scope(APPLICATION) @Startup(depends="org.jboss.seam.bpm.jbpm")</pre><p> Specifies that an application scope component is started immediately at initialization time.
                        This is mainly used for certain built-in components that bootstrap critical infrastructure such
                        as JNDI, datasources, etc. </p><pre class="programlisting">@Scope(SESSION) @Startup</pre><p> Specifies that a session scope component is started immediately at session creation time. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">depends</tt> &#8212; specifies that the named components must be
                                started first, if they are installed. </p></li></ul></div></dd><dt><a name="install-annotation"></a><span class="term">
                    <tt class="literal">@Install</tt>
                </span></dt><dd><pre class="programlisting">@Install(false)</pre><p>
                        Specifies whether or not a component should be installed by default. The lack of an @Install
                        annotation indicates a component should be installed.
                    </p><pre class="programlisting">@Install(dependencies="org.jboss.seam.bpm.jbpm")</pre><p>
                        Specifies that a component should only be stalled if the components listed as dependencies
                        are also installed.
                    </p><pre class="programlisting">@Install(genericDependencies=ManagedQueueSender.class)</pre><p>
                        Specifies that a component should only be installed if a component that is implemented by a
                        certain class is installed. This is useful when the dependency doesn't have a single well-known
                        name.
                    </p><pre class="programlisting">@Install(classDependencies="org.hibernate.Session")</pre><p>
                        Specifies that a component should only be installed if the named class is in the classpath.
                    </p><pre class="programlisting">@Install(precedence=BUILT_IN)</pre><p>
                        Specifies the precedence of the component. If multiple components with the same name exist,
                        the one with the higher precedence will be installed. The defined precendence values are
                        (in ascending order):
                    </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">BUILT_IN</tt> &#8212; Precedence of all built-in Seam
                            components</p></li><li><p><tt class="literal">FRAMEWORK</tt> &#8212; Precedence to use for components of
                                frameworks which extend Seam</p></li><li><p><tt class="literal">APPLICATION</tt> &#8212; Predence of application components (the
                                default precedence)</p></li><li><p><tt class="literal">DEPLOYMENT</tt> &#8212; Precedence to use for components which
                                override application components in a particular deployment</p></li><li><p><tt class="literal">MOCK</tt> &#8212; Precedence for mock objects used in testing</p></li></ul></div></dd><dt><a name="synchronized-annotation"></a><span class="term">
                    <tt class="literal">@Synchronized</tt>
                </span></dt><dd><pre class="programlisting">@Synchronized(timeout=1000)</pre><p> Specifies that a component is accessed concurrently by multiple clients, and that Seam should
                        serialize requests. If a request is not able to obtain its lock on the component in the given
                        timeout period, an exception will be raised. </p></dd><dt><a name="readonly-annotation"></a><span class="term">
                    <tt class="literal">@ReadOnly</tt>
                </span></dt><dd><pre class="programlisting">@ReadOnly</pre><p> Specifies that a JavaBean component or component method does not require state replication at
                        the end of the invocation. </p></dd><dt><a name="autocreate-annotation"></a><span class="term">
                    <tt class="literal">@AutoCreate</tt>
                </span></dt><dd><pre class="programlisting">@AutoCreate</pre><p> Specifies that a component will be automatically created, even if the client does not
                    specify <tt class="literal">create=true</tt>. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15023"></a>27.2.&nbsp;Annotations for bijection</h2></div></div><div></div></div><p> The next two annotations control bijection. These attributes occur on component instance variables or
            property accessor methods. </p><div class="variablelist"><dl><dt><a name="in-annotation"></a><span class="term">
                    <tt class="literal">@In</tt>
                </span></dt><dd><pre class="programlisting">@In</pre><p> Specifies that a component attribute is to be injected from a context variable at the
                        beginning of each component invocation. If the context variable is null, an exception will be
                        thrown. </p><pre class="programlisting">@In(required=false)</pre><p> Specifies that a component attribute is to be injected from a context variable at the
                        beginning of each component invocation. The context variable may be null. </p><pre class="programlisting">@In(create=true)</pre><p> Specifies that a component attribute is to be injected from a context variable at the
                        beginning of each component invocation. If the context variable is null, an instance of the
                        component is instantiated by Seam. </p><pre class="programlisting">@In(value="contextVariableName")</pre><p> Specifies the name of the context variable explicitly, instead of using the annotated
                        instance variable name. </p><pre class="programlisting">@In(value="#{customer.addresses['shipping']}")</pre><p> Specifies that a component attribute is to be injected by evaluating a JSF EL expression at
                        the beginning of each component invocation. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">value</tt> &#8212; specifies the name of the context variable. Default
                                to the name of the component attribute. Alternatively, specifies a JSF EL expression,
                                surrounded by <tt class="literal">#{...}</tt>. </p></li><li><p>
                                <tt class="literal">create</tt> &#8212; specifies that Seam should instantiate the
                                component with the same name as the context variable if the context variable is
                                undefined (null) in all contexts. Default to false. </p></li><li><p>
                                <tt class="literal">required</tt> &#8212; specifies Seam should throw an exception if the
                                context variable is undefined in all contexts. </p></li></ul></div></dd><dt><a name="out-annotation"></a><span class="term">
                    <tt class="literal">@Out</tt>
                </span></dt><dd><pre class="programlisting">@Out</pre><p> Specifies that a component attribute that is a Seam component is to be outjected to its
                        context variable at the end of the invocation. If the attribute is null, an exception is thrown. </p><pre class="programlisting">@Out(required=false)</pre><p> Specifies that a component attribute that is a Seam component is to be outjected to its
                        context variable at the end of the invocation. The attribute may be null. </p><pre class="programlisting">@Out(scope=ScopeType.SESSION)</pre><p> Specifies that a component attribute that is <span class="emphasis"><em>not</em></span> a Seam component type
                        is to be outjected to a specific scope at the end of the invocation. </p><p> Alternatively, if no scope is explicitly specified, the scope of the component with the
                            <tt class="literal">@Out</tt> attribute is used (or the <tt class="literal">EVENT</tt> scope if the
                        component is stateless). </p><pre class="programlisting">@Out(value="contextVariableName")</pre><p> Specifies the name of the context variable explicitly, instead of using the annotated
                        instance variable name. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">value</tt> &#8212; specifies the name of the context variable. Default
                                to the name of the component attribute. </p></li><li><p>
                                <tt class="literal">required</tt> &#8212; specifies Seam should throw an exception if the
                                component attribute is null during outjection. </p></li></ul></div></dd></dl></div><p> Note that it is quite common for these annotations to occur together, for example: </p><pre class="programlisting">@In(create=true) @Out private User currentUser;</pre><p> The next annotation supports the <span class="emphasis"><em>manager component</em></span> pattern, where a Seam component
            that manages the lifecycle of an instance of some other class that is to be injected. It appears on a
            component getter method. </p><div class="variablelist"><dl><dt><a name="unwrap-annotation"></a><span class="term">
                    <tt class="literal">@Unwrap</tt>
                </span></dt><dd><pre class="programlisting">@Unwrap</pre><p> Specifies that the object returned by the annotated getter method is the thing that is
                        injected instead of the component instance itself. </p></dd></dl></div><p> The next annotation supports the <span class="emphasis"><em>factory component</em></span> pattern, where a Seam component
            is responsible for initializing the value of a context variable. This is especially useful for initializing
            any state needed for rendering the response to a non-faces request. It appears on a component method. </p><div class="variablelist"><dl><dt><a name="factory-annotation"></a><span class="term">
                    <tt class="literal">@Factory</tt>
                </span></dt><dd><pre class="programlisting">@Factory("processInstance") public void createProcessInstance() { ... }</pre><p> Specifies that the method of the component is used to initialize the value of the named
                        context variable, when the context variable has no value. This style is used with methods that
                        return <tt class="literal">void</tt>. </p><pre class="programlisting">@Factory("processInstance", scope=CONVERSATION) public ProcessInstance createProcessInstance() { ... }</pre><p> Specifies that the method returns a value that Seam should use to initialize the value of the
                        named context variable, when the context variable has no value. This style is used with methods
                        that return a value. If no scope is explicitly specified, the scope of the component with the
                            <tt class="literal">@Factory</tt> method is used (unless the component is stateless, in which case
                        the <tt class="literal">EVENT</tt> context is used). </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">value</tt> &#8212; specifies the name of the context variable. If the
                                method is a getter method, default to the JavaBeans property name. </p></li><li><p>
                                <tt class="literal">scope</tt> &#8212; specifies the scope that Seam should bind the
                                returned value to. Only meaningful for factory methods which return a value. </p></li><li><p>
                        		<tt class="literal">autoCreate</tt> &#8212; specifies that this factory method should be 
                        		automatically called whenever the variable is asked for, even if @In does not specify 
                        		create=true. 
                        	</p></li></ul></div></dd></dl></div><p> This annotation lets you inject a <tt class="literal">Log</tt>: </p><div class="variablelist"><dl><dt><a name="logger-annotation"></a><span class="term">
                    <tt class="literal">@Logger</tt>
                </span></dt><dd><pre class="programlisting">@Logger("categoryName")</pre><p> Specifies that a component field is to be injected with an instance of
                            <tt class="literal">org.jboss.seam.log.Log</tt>. For entity beans, the 
                            field must be declared as static.</p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">value</tt> &#8212; specifies the name of the log category. Default to
                                the name of the component class. </p></li></ul></div></dd></dl></div><p> The last annotation lets you inject a request parameter value: </p><div class="variablelist"><dl><dt><a name="requestparameter-annotation"></a><span class="term">
                    <tt class="literal">@RequestParameter</tt>
                </span></dt><dd><pre class="programlisting">@RequestParameter("parameterName")</pre><p> Specifies that a component attribute is to be injected with the value of a request parameter.
                        Basic type conversions are performed automatically. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">value</tt> &#8212; specifies the name of the request parameter.
                                Default to the name of the component attribute. </p></li></ul></div></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15243"></a>27.3.&nbsp;Annotations for component lifecycle methods</h2></div></div><div></div></div><p> These annotations allow a component to react to its own lifecycle events. They occur on methods of the
            component. There may be only one of each per component class. </p><div class="variablelist"><dl><dt><a name="create-annotation"></a><span class="term">
                    <tt class="literal">@Create</tt>
                </span></dt><dd><pre class="programlisting">@Create</pre><p> Specifies that the method should be called when an instance of the component is instantiated
                        by Seam. Note that create methods are only supported for JavaBeans and stateful session beans.
                    </p></dd><dt><a name="destroy-annotation"></a><span class="term">
                    <tt class="literal">@Destroy</tt>
                </span></dt><dd><pre class="programlisting">@Destroy</pre><p> Specifies that the method should be called when the context ends and its context variables
                        are destroyed. Note that destroy methods are only supported for JavaBeans and stateful session
                        beans. </p><p> Destroy methods should be used only for cleanup. <span class="emphasis"><em>Seam catches, logs and swallows
                            any exception that propagates out of a destroy method.</em></span>
                    </p></dd><dt><a name="observer-annotation"></a><span class="term">
                    <tt class="literal">@Observer</tt>
                </span></dt><dd><pre class="programlisting">@Observer("somethingChanged")</pre><p> Specifies that the method should be called when a component-driven event of the specified
                        type occurs. </p><pre class="programlisting">@Observer(value="somethingChanged",create=false)</pre><p>Specifies that the method should be called when an event of the specified type occurs but
                        that an instance should not be created if one doesn't exist.  If an instance does not exist
                        and create is false, the event will not be observed.  The default value for create is true.
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15291"></a>27.4.&nbsp;Annotations for context demarcation</h2></div></div><div></div></div><p> These annotations provide declarative conversation demarcation. They appear on methods of Seam
            components, usually action listener methods. </p><p> Every web request has a conversation context associated with it. Most of these conversations end at the
            end of the request. If you want a conversation that span multiple requests, you must "promote" the current
            conversation to a <span class="emphasis"><em>long-running conversation</em></span> by calling a method marked with
                <tt class="literal">@Begin</tt>. </p><div class="variablelist"><dl><dt><a name="begin-annotation"></a><span class="term">
                    <tt class="literal">@Begin</tt>
                </span></dt><dd><pre class="programlisting">@Begin</pre><p> Specifies that a long-running conversation begins when this method returns a non-null outcome
                        without exception. </p><pre class="programlisting">@Begin(join=true)</pre><p> Specifies that if a long-running conversation is already in progress, the conversation
                        context is simply propagated. </p><pre class="programlisting">@Begin(nested=true)</pre><p> Specifies that if a long-running conversation is already in progress, a new
                        <span class="emphasis"><em>nested</em></span> conversation context begins. The nested conversation will end when
                        the next <tt class="literal">@End</tt> is encountered, and the outer conversation will resume. It is
                        perfectly legal for multiple nested conversations to exist concurrently in the same outer
                        conversation. </p><pre class="programlisting">@Begin(pageflow="process definition name")</pre><p> Specifies a jBPM process definition name that defines the pageflow for this conversation.
                    </p><pre class="programlisting">@Begin(flushMode=FlushModeType.MANUAL)</pre><p> Specify the flush mode of any Seam-managed persistence contexts.
                            <tt class="literal">flushMode=FlushModeType.MANUAL</tt> supports the use of <span class="emphasis"><em>atomic
                            conversations</em></span> where all write operations are queued in the conversation context
                        until an explicit call to <tt class="literal">flush()</tt> (which usually occurs at the end of the
                        conversation). </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">join</tt> &#8212; determines the behavior when a long-running
                                conversation is already in progress. If <tt class="literal">true</tt>, the context is
                                propagated. If <tt class="literal">false</tt>, an exception is thrown. Default to
                                    <tt class="literal">false</tt>. This setting is ignored when
                                <tt class="literal">nested=true</tt> is specified </p></li><li><p>
                                <tt class="literal">nested</tt> &#8212; specifies that a nested conversation should be
                                started if a long-running conversation is already in progress. </p></li><li><p>
                                <tt class="literal">flushMode</tt> &#8212; set the flush mode of any Seam-managed
                                Hibernate sessions or JPA persistence contexts that are created during this
                                conversation. </p></li><li><p>
                                <tt class="literal">pageflow</tt> &#8212; a process definition name of a jBPM process
                                definition deployed via <tt class="literal">org.jboss.seam.bpm.jbpm.pageflowDefinitions.</tt>
                            </p></li></ul></div></dd><dt><a name="end-annotation"></a><span class="term">
                    <tt class="literal">@End</tt>
                </span></dt><dd><pre class="programlisting">@End</pre><p> Specifies that a long-running conversation ends when this method returns a non-null outcome
                        without exception. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">beforeRedirect</tt> &#8212; by default, the conversation will not
                                actually be destroyed until after any redirect has occurred. Setting
                                    <tt class="literal">beforeRedirect=true</tt> specifies that the conversation should be
                                destroyed at the end of the current request, and that the redirect will be processed in
                                a new temporary conversation context. </p></li></ul></div></dd><dt><a name="starttask-annotation"></a><span class="term">
                    <tt class="literal">@StartTask</tt>
                </span></dt><dd><pre class="programlisting">@StartTask</pre><p> "Starts" a jBPM task. Specifies that a long-running conversation begins when this method
                        returns a non-null outcome without exception. This conversation is associated with the jBPM task
                        specified in the named request parameter. Within the context of this conversation, a business
                        process context is also defined, for the business process instance of the task instance. </p><p> The jBPM <tt class="literal">TaskInstance</tt> will be available in a request context variable
                        named <tt class="literal">taskInstance</tt>. The jPBM <tt class="literal">ProcessInstance</tt> will be
                        available in a request context variable named <tt class="literal">processInstance</tt>. (Of course,
                        these objects are available for injection via <tt class="literal">@In</tt>.) </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">taskIdParameter</tt> &#8212; the name of a request parameter which
                                holds the id of the task. Default to <tt class="literal">"taskId"</tt>, which is also the
                                default used by the Seam <tt class="literal">taskList</tt> JSF component. </p></li><li><p>
                                <tt class="literal">flushMode</tt> &#8212; set the flush mode of any Seam-managed
                                Hibernate sessions or JPA persistence contexts that are created during this
                                conversation. </p></li></ul></div></dd><dt><a name="begintask-annotation"></a><span class="term">
                    <tt class="literal">@BeginTask</tt>
                </span></dt><dd><pre class="programlisting">@BeginTask</pre><p> Resumes work on an incomplete jBPM task. Specifies that a long-running conversation begins
                        when this method returns a non-null outcome without exception. This conversation is associated
                        with the jBPM task specified in the named request parameter. Within the context of this
                        conversation, a business process context is also defined, for the business process instance of
                        the task instance. </p><p> The jBPM <tt class="literal">org.jbpm.taskmgmt.exe.TaskInstance</tt> will be available in a request 
                        context variable named <tt class="literal">taskInstance</tt>. The jPBM 
                        <tt class="literal">org.jbpm.graph.exe.ProcessInstance</tt> will be available in a request context 
                        variable named <tt class="literal">processInstance</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">taskIdParameter</tt> &#8212; the name of a request parameter which
                                holds the id of the task. Default to <tt class="literal">"taskId"</tt>, which is also the
                                default used by the Seam <tt class="literal">taskList</tt> JSF component. </p></li><li><p>
                                <tt class="literal">flushMode</tt> &#8212; set the flush mode of any Seam-managed
                                Hibernate sessions or JPA persistence contexts that are created during this
                                conversation. </p></li></ul></div></dd><dt><a name="endtask-annotation"></a><span class="term">
                    <tt class="literal">@EndTask</tt>
                </span></dt><dd><pre class="programlisting">@EndTask</pre><p> "Ends" a jBPM task. Specifies that a long-running conversation ends when this method returns
                        a non-null outcome, and that the current task is complete. Triggers a jBPM transition. The
                        actual transition triggered will be the default transition unless the application has called
                            <tt class="literal">Transition.setName()</tt> on the built-in component named
                        <tt class="literal">transition</tt>. </p><pre class="programlisting">@EndTask(transition="transitionName")</pre><p> Triggers the given jBPM transition. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">transition</tt> &#8212; the name of the jBPM transition to be
                                triggered when ending the task. Defaults to the default transition. </p></li><li><p>
                                <tt class="literal">beforeRedirect</tt> &#8212; by default, the conversation will not
                                actually be destroyed until after any redirect has occurred. Setting
                                    <tt class="literal">beforeRedirect=true</tt> specifies that the conversation should be
                                destroyed at the end of the current request, and that the redirect will be processed in
                                a new temporary conversation context. </p></li></ul></div></dd><dt><a name="createprocess-annotation"></a><span class="term">
                    <tt class="literal">@CreateProcess</tt>
                </span></dt><dd><pre class="programlisting">@CreateProcess(definition="process definition name")</pre><p> Creates a new jBPM process instance when the method returns a non-null outcome without
                        exception. The <tt class="literal">ProcessInstance</tt> object will be available in a context variable
                        named <tt class="literal">processInstance</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">definition</tt> &#8212; the name of the jBPM process definition
                                deployed via <tt class="literal">org.jboss.seam.bpm.jbpm.processDefinitions</tt>. </p></li></ul></div></dd><dt><a name="resumeprocess-annotation"></a><span class="term">
                    <tt class="literal">@ResumeProcess</tt>
                </span></dt><dd><pre class="programlisting">@ResumeProcess(processIdParameter="processId")</pre><p> Re-enters the scope of an existing jBPM process instance when the method returns a non-null
                        outcome without exception. The <tt class="literal">ProcessInstance</tt> object will be available in a
                        context variable named <tt class="literal">processInstance</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">processIdParameter</tt> &#8212; the name a request parameter holding
                                the process id. Default to <tt class="literal">"processId"</tt>. </p></li></ul></div></dd><dt><a name="transition-annotation"></a><span class="term"><tt class="literal">@Transition</tt></span></dt><dd><pre class="programlisting">@Transition("cancel")</pre><p>
                        Marks a method as signalling a transition in the current jBPM process instance
                        whenever the method returns a non-null result.
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15607"></a>27.5.&nbsp;Annotations for use with Seam JavaBean components in a J2EE environment</h2></div></div><div></div></div><p> Seam provides an annotation that lets you force a rollback of the JTA transaction for certain action
            listener outcomes. </p><div class="variablelist"><dl><dt><a name="transactional-annotation"></a><span class="term">
                    <tt class="literal">@Transactional</tt>
                </span></dt><dd><pre class="programlisting">@Transactional</pre><p> Specifies that a JavaBean component should have a similar transactional behavior to the
                        default behavior of a session bean component. ie. method invocations should take place in a
                        transaction, and if no transaction exists when the method is called, a transaction will be
                        started just for that method. This annotation may be applied at either class or method level.
                       <span class="emphasis"><em>Do not use this annotations on EJB 3.0 components, use <tt class="literal">@TransactionAttribute</tt>!</em></span>
                    </p></dd><dt><span class="term">
                    <tt class="literal">@ApplicationException</tt>
                </span></dt><dd><pre class="programlisting">@Transactional</pre><p> 
                    TDB
                    </p></dd><dt><span class="term">
                    <tt class="literal">@Interceptors</tt>
                </span></dt><dd><pre class="programlisting">@Transactional</pre><p> 
                    TDB
                    </p></dd></dl></div><p>
           These annotations are mostly useful for JavaBean Seam components. If you use EJB 3.0 components, you
           should use the standard <tt class="literal">@TransactionAttribute</tt> annotation.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15657"></a>27.6.&nbsp;Annotations for exceptions</h2></div></div><div></div></div><p> These annotations let you specify how Seam should handle an exception that propagates out of a Seam
            component. </p><div class="variablelist"><dl><dt><a name="redirect-annotation"></a><span class="term">
                    <tt class="literal">@Redirect</tt>
                </span></dt><dd><pre class="programlisting">@Redirect(viewId="error.jsp")</pre><p> Specifies that the annotated exception causes a browser redirect to a specified view id. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">viewId</tt> &#8212; specifies the JSF view id to redirect to.  You can use
                                EL here. </p></li><li><p>
                                <tt class="literal">message</tt> &#8212; a message to be displayed, default to the
                                exception message. </p></li><li><p>
                                <tt class="literal">end</tt> &#8212; specifies that the long-running conversation should
                                end, default to <tt class="literal">false</tt>. </p></li></ul></div></dd><dt><a name="httperror-annotation"></a><span class="term">
                    <tt class="literal">@HttpError</tt>
                </span></dt><dd><pre class="programlisting">@HttpError(errorCode=404)</pre><p> Specifies that the annotated exception causes a HTTP error to be sent. </p><div class="itemizedlist"><ul type="disc"><li><p>
                                <tt class="literal">errorCode</tt> &#8212; the HTTP error code, default to
                                <tt class="literal">500</tt>. </p></li><li><p>
                                <tt class="literal">message</tt> &#8212; a message to be sent with the HTTP error, default
                                to the exception message. </p></li><li><p>
                                <tt class="literal">end</tt> &#8212; specifies that the long-running conversation should
                                end, default to <tt class="literal">false</tt>. </p></li></ul></div></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15732"></a>27.7.&nbsp;Annotations for Seam Remoting</h2></div></div><div></div></div><p> Seam Remoting requires that the local interface of a session bean be annotated with the following
            annotation: </p><div class="variablelist"><dl><dt><a name="webremote-annotation"></a><span class="term">
                    <tt class="literal">@WebRemote</tt>
                </span></dt><dd><pre class="programlisting">@WebRemote(exclude="path.to.exclude")</pre><p> Indicates that the annotated method may be called from client-side JavaScript. The
                            <tt class="literal">exclude</tt> property is optional and allows objects to be excluded from the
                        result's object graph (see the Remoting chapter for more details). </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15752"></a>27.8.&nbsp;Annotations for Seam interceptors</h2></div></div><div></div></div><p> The following annotations appear on Seam interceptor classes. </p><p> Please refer to the documentation for the EJB 3.0 specification for information about the annotations
            required for EJB interceptor definition. </p><div class="variablelist"><dl><dt><a name="interceptor-annotation"></a><span class="term">
                    <tt class="literal">@Interceptor</tt>
                </span></dt><dd><pre class="programlisting">@Interceptor(stateless=true)</pre><p> Specifies that this interceptor is stateless and Seam may optimize replication. </p><pre class="programlisting">@Interceptor(type=CLIENT)</pre><p> Specifies that this interceptor is a "client-side" interceptor that is called before the EJB
                        container. </p><pre class="programlisting">@Interceptor(around={SomeInterceptor.class, OtherInterceptor.class})</pre><p> Specifies that this interceptor is positioned higher in the stack than the given
                        interceptors. </p><pre class="programlisting">@Interceptor(within={SomeInterceptor.class, OtherInterceptor.class})</pre><p> Specifies that this interceptor is positioned deeper in the stack than the given
                        interceptors. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15786"></a>27.9.&nbsp;Annotations for asynchronicity</h2></div></div><div></div></div><p> The following annotations are used to declare an asynchronous method, for example: </p><pre class="programlisting">@Asynchronous public void scheduleAlert(Alert alert, @Expiration Date date) { ... }</pre><pre class="programlisting">@Asynchronous public Timer scheduleAlerts(Alert alert, 
                                          @Expiration Date date, 
                                          @IntervalDuration long interval) { ... }</pre><div class="variablelist"><dl><dt><a name="asynchronous-annotation"></a><span class="term">
                    <tt class="literal">@Asynchronous</tt>
                </span></dt><dd><pre class="programlisting">@Asynchronous</pre><p> Specifies that the method call is processed asynchronously. </p></dd><dt><a name="duration-annotation"></a><span class="term">
                    <tt class="literal">@Duration</tt>
                </span></dt><dd><pre class="programlisting">@Duration</pre><p> Specifies that a parameter of the asynchronous call is the duration before the call is
                        processed (or first processed for recurring calls). </p></dd><dt><a name="expiration-annotation"></a><span class="term">
                    <tt class="literal">@Expiration</tt>
                </span></dt><dd><pre class="programlisting">@Expiration</pre><p> Specifies that a parameter of the asynchronous call is the datetime at which the call is
                        processed (or first processed for recurring calls). </p></dd><dt><a name="intervalduration-annotation"></a><span class="term">
                    <tt class="literal">@IntervalDuration</tt>
                </span></dt><dd><pre class="programlisting">@IntervalDuration</pre><p> Specifies that an asynchronous method call recurs, and that the annotationed parameter is
                        duration between recurrences. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15840"></a>27.10.&nbsp;Annotations for use with JSF</h2></div></div><div></div></div><p> 
    			The following annotations make working with JSF easier.
	        </p><div class="variablelist"><dl><dt><span class="term">
	                    <tt class="literal">@Converter</tt>
	                </span></dt><dd><p>
	                    	Allows a Seam component to act as a JSF converter. The annotated class must be a Seam
	                    	component, and must implement <tt class="literal">javax.faces.convert.Converter</tt>.
	                    </p><div class="itemizedlist"><ul type="disc"><li><p>
	                                <tt class="literal">id</tt> &#8212; the JSF converter id. Defaults to the component name.
	                            </p></li><li><p>
	                                <tt class="literal">forClass</tt> &#8212; if specified, register this component as the default converter for a type.
	                            </p></li></ul></div></dd><dt><span class="term">
	                    <tt class="literal">@Validator</tt>
	                </span></dt><dd><p>
	                    	Allows a Seam component to act as a JSF validator. The annotated class must be a Seam 
	                    	component, and must implement <tt class="literal">javax.faces.validator.Validator</tt>.
	                    </p><div class="itemizedlist"><ul type="disc"><li><p>
	                                <tt class="literal">id</tt> &#8212; the JSF validator id. Defaults to the component name.
	                            </p></li></ul></div></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15890"></a>27.10.1.&nbsp;Annotations for use with <tt class="literal">dataTable</tt></h3></div></div><div></div></div><p> The following annotations make it easy to implement clickable lists backed by a stateful session bean.
	            They appear on attributes. </p><div class="variablelist"><dl><dt><a name="datamodel-annotation"></a><span class="term">
	                    <tt class="literal">@DataModel</tt>
	                </span></dt><dd><pre class="programlisting">@DataModel("variableName")</pre><p> Outjects a property of type <tt class="literal">List</tt>, <tt class="literal">Map</tt>,
	                        <tt class="literal">Set</tt> or <tt class="literal">Object[]</tt> as a JSF <tt class="literal">DataModel</tt> into
	                        the scope of the owning component (or the <tt class="literal">EVENT</tt> scope if the owning component
	                        is <tt class="literal">STATELESS</tt>). In the case of <tt class="literal">Map</tt>, each row of the
	                            <tt class="literal">DataModel</tt> is a <tt class="literal">Map.Entry</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p>
	                                <tt class="literal">value</tt> &#8212; name of the conversation context variable. Default
	                                to the attribute name. </p></li><li><p>
	                                <tt class="literal">scope</tt> &#8212; if <tt class="literal">scope=ScopeType.PAGE</tt> is
	                                explicitly specified, the <tt class="literal">DataModel</tt> will be kept in the
	                                <tt class="literal">PAGE</tt> context. </p></li></ul></div></dd><dt><a name="datamodelselection-annotation"></a><span class="term">
	                    <tt class="literal">@DataModelSelection</tt>
	                </span></dt><dd><pre class="programlisting">@DataModelSelection</pre><p> 
                          Injects the selected value from the JSF <tt class="literal">DataModel</tt> (this is the element of
	                      the underlying collection, or the map value). If only one <tt class="literal">@DataModel</tt> attribute
                          is defined for a component, the selected value from that <tt class="literal">DataModel</tt> will be 
                          injected. Otherwise, the component name of each <tt class="literal">@DataModel</tt> must be specified 
                          in the value attribute for each <tt class="literal">@DataModelSelection</tt>.
                        </p><p> If <tt class="literal">PAGE</tt> scope is specified on the associated <tt class="literal">@DataModel</tt>,
                            then, in addition to the DataModel Selection being injected, the associated DataModel will
                            also be injected.  In this case, if the property annotated with <tt class="literal">@DataModel</tt> is
                            a getter method, then a setter method for the property must also be part of the Business API of 
                            the containing Seam Component.</p><div class="itemizedlist"><ul type="disc"><li><p>
	                                <tt class="literal">value</tt> &#8212; name of the conversation context variable. Not
	                                needed if there is exactly one <tt class="literal">@DataModel</tt> in the component. </p></li></ul></div></dd><dt><a name="datamodelselectionindex-annotation"></a><span class="term">
	                    <tt class="literal">@DataModelSelectionIndex</tt>
	                </span></dt><dd><pre class="programlisting">@DataModelSelectionIndex</pre><p>
                          Exposes the selection index of the JSF <tt class="literal">DataModel</tt> as an attribute of the
	                      component (this is the row number of the underlying collection, or the map key). If only one 
                          <tt class="literal">@DataModel</tt> attribute is defined for a component, the selected value from 
                          that <tt class="literal">DataModel</tt> will be injected. Otherwise, the component name of each 
                          <tt class="literal">@DataModel</tt> must be specified in the value attribute for each 
                          <tt class="literal">@DataModelSelectionIndex</tt>.
                        </p><div class="itemizedlist"><ul type="disc"><li><p>
	                                <tt class="literal">value</tt> &#8212; name of the conversation context variable. Not
	                                needed if there is exactly one <tt class="literal">@DataModel</tt> in the component. </p></li></ul></div></dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16044"></a>27.11.&nbsp;Meta-annotations for databinding</h2></div></div><div></div></div><p> These meta-annotations make it possible to implement similar functionality to
            <tt class="literal">@DataModel</tt> and <tt class="literal">@DataModelSelection</tt> for other datastructures apart from
            lists. </p><div class="variablelist"><dl><dt><a name="databinderclass-annotation"></a><span class="term">
                    <tt class="literal">@DataBinderClass</tt>
                </span></dt><dd><pre class="programlisting">@DataBinderClass(DataModelBinder.class)</pre><p> Specifies that an annotation is a databinding annotation. </p></dd><dt><a name="dataselectorclass-annotation"></a><span class="term">
                    <tt class="literal">@DataSelectorClass</tt>
                </span></dt><dd><pre class="programlisting">@DataSelectorClass(DataModelSelector.class)</pre><p> Specifies that an annotation is a dataselection annotation. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16078"></a>27.12.&nbsp;Annotations for packaging</h2></div></div><div></div></div><p> This annotation provides a mechanism for declaring information about a set of components that are
            packaged together. It can be applied to any Java package.</p><div class="variablelist"><dl><dt><a name="namespace-annotation"></a><span class="term">
                    <tt class="literal">@Namespace</tt>
                </span></dt><dd><pre class="programlisting">@Namespace(value="http://jboss.com/products/seam/example/seampay")</pre><p> Specifies that components in the current package are associated with the given namespace. The
                        declared namespace can be used as an XML namespace in a <tt class="literal">components.xml</tt> file
                        to simplify application configuration.</p><pre class="programlisting">@Namespace(value="http://jboss.com/products/seam/core", prefix="org.jboss.seam.core")</pre><p>Specifies a namespace to associate with a given package. Additionally, it specifies a
                        component name prefix to be applied to component names specified in the XML file. For example,
                        an XML element named <tt class="literal">init</tt> that is associated with this namespace
                        would be understood to actually refere to a component named
                            <tt class="literal">org.jboss.seam.core.init</tt>. </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16108"></a>27.13.&nbsp;Annotations for integrating with the servlet container</h2></div></div><div></div></div><p>These annotations allow you to integrate your Seam components with the servlet container.</p><div class="variablelist"><dl><dt><span class="term">
                    <tt class="literal">@Filter</tt>
                </span></dt><dd><p>
                		Use the Seam component (which implements <tt class="literal">javax.servlet.Filter</tt>) annotated with <tt class="literal">@Filter</tt> as a servlet filter.  It
                		will be executed by Seam's master filter.
                	</p><div class="itemizedlist"><ul type="disc"><li><pre class="programlisting">@Filter(around={"seamComponent", "otherSeamComponent"})</pre><p> Specifies that this filter is positioned higher in the stack than the given
                        filters. </p></li><li><pre class="programlisting">@Filter(within={"seamComponent", "otherSeamComponent"})</pre><p> Specifies that this filter is positioned deeper in the stack than the given
                        filters. </p></li></ul></div></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;28.&nbsp;Built-in Seam components</h2></div></div><div></div></div><p>
        This chapter describes Seam's built-in components, and their
        configuration properties. The built-in components will be created even if they
        are not listed in your <tt class="literal">components.xml</tt> file, but if you need to
        override default properties or specify more than one component of a certain type,
        <tt class="literal">components.xml</tt> is used.
    </p><p>
        Note that you can replace any of the built in components with
        your own implementations simply by specifying the name of one 
        of the built in components on your own class using 
        <tt class="literal">@Name</tt>.
    </p><p>
        Note also that even though all the built in components use a
        qualified name, most of them are aliased to unqualified names by
        default. These aliases specify <tt class="literal">auto-create="true"</tt>,
        so you do not need to use <tt class="literal">create=true</tt> when
        injecting built-in components by their unqualified name.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16164"></a>28.1.&nbsp;Context injection components</h2></div></div><div></div></div><p>
            The first set of built in components exist purely to support
            injection of various contextual objects. For example, the
            following component instance variable would have the Seam
            session context object injected:
        </p><pre class="programlisting">@In private Context sessionContext;</pre><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.contexts</tt></span></dt><dd><p>
                        Component that provides access to Seam Context objects, for
                        example <tt class="literal">org.jboss.seam.core.contexts.sessionContext['user']</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.facesContext</tt></span></dt><dd><p>
                        Manager component for the <tt class="literal">FacesContext</tt> context 
                        object (not a true Seam context)
                    </p></dd></dl></div><p>
            All of these components are always installed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16194"></a>28.2.&nbsp;Utility components</h2></div></div><div></div></div><p>
            These components are merely useful.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.faces.facesMessages</tt></span></dt><dd><p>
                        Allows faces success messages to propagate across a browser redirect.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">add(FacesMessage facesMessage)</tt> &#8212; add 
                            a faces message, which will be displayed during the next render
                            response phase that occurs in the current conversation.
                        </p></li><li><p>
                            <tt class="literal">add(String messageTemplate)</tt> &#8212; add 
                            a faces message, rendered from the given message template
                            which may contain EL expressions.
                        </p></li><li><p>
                            <tt class="literal">add(Severity severity, String messageTemplate)</tt> &#8212; 
                            add a faces message, rendered from the given message template
                            which may contain EL expressions.
                        </p></li><li><p>
                            <tt class="literal">addFromResourceBundle(String key)</tt> &#8212; 
                            add a faces message, rendered from a message template defined
                            in the Seam resource bundle which may contain EL expressions.
                        </p></li><li><p>
                            <tt class="literal">addFromResourceBundle(Severity severity, String key)</tt> &#8212; 
                            add a faces message, rendered from a message template defined
                            in the Seam resource bundle which may contain EL expressions.
                        </p></li><li><p>
                            <tt class="literal">clear()</tt> &#8212; clear all messages.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.redirect</tt></span></dt><dd><p>
                        A convenient API for performing redirects with parameters (this
                        is especially useful for bookmarkable search results screens).
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">redirect.viewId</tt> &#8212; the JSF view id
                            to redirect to.
                        </p></li><li><p>
                            <tt class="literal">redirect.conversationPropagationEnabled</tt> &#8212; 
                            determines whether the conversation will propagate across the 
                            redirect.
                        </p></li><li><p>
                            <tt class="literal">redirect.parameters</tt> &#8212; a map of
                            request parameter name to value, to be passed in the redirect
                            request.
                        </p></li><li><p>
                            <tt class="literal">execute()</tt> &#8212; perform the redirect
                            immediately.
                        </p></li><li><p>
                            <tt class="literal">captureCurrentRequest()</tt> &#8212; stores 
                            the view id and request parameters of the current GET 
                            request (in the conversation context), for later use
                            by calling <tt class="literal">execute()</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.httpError</tt></span></dt><dd><p>
                        A convenient API for sending HTTP errors.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.events</tt></span></dt><dd><p>
                        An API for raising events that can be observed via
                        <tt class="literal">@Observer</tt> methods, or method
                        bindings in <tt class="literal">components.xml</tt>.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">raiseEvent(String type)</tt> &#8212; raise
                            an event of a particular type and distribute to all
                            observers.
                        </p></li><li><p>
                            <tt class="literal">raiseAsynchronousEvent(String type)</tt> &#8212; 
                            raise an event to be processed asynchronously by the EJB3
                            timer service.
                        </p></li><li><p>
                            <tt class="literal">raiseTimedEvent(String type, ....)</tt> &#8212; 
                            schedule an event to be processed asynchronously by the EJB3
                            timer service.
                        </p></li><li><p>
                            <tt class="literal">addListener(String type, String methodBinding)</tt> 
                            &#8212; add an observer for a particular event type.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.interpolator</tt></span></dt><dd><p>
                        An API for interpolating the values of JSF EL expressions in
                        Strings.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">interpolate(String template)</tt> &#8212; scan
                            the template for JSF EL expressions of the form <tt class="literal">#{...}</tt>
                            and replace them with their evaluated values.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.expressions</tt></span></dt><dd><p>
                        An API for creating value and method bindings.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">createValueBinding(String expression)</tt> &#8212; create
                            a value binding object.
                        </p></li><li><p>
                            <tt class="literal">createMethodBinding(String expression)</tt> &#8212; create
                            a method binding object.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.pojoCache</tt></span></dt><dd><p>
                        Manager component for a JBoss Cache <tt class="literal">PojoCache</tt> 
                        instance.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">pojoCache.cfgResourceName</tt> &#8212; the name of 
                            the configuration file. Default to <tt class="literal">treecache.xml</tt>.
                        </p></li></ul></div></dd></dl></div><p>
            All of these components are always installed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16389"></a>28.3.&nbsp;Components for internationalization and themes</h2></div></div><div></div></div><p>
            The next group of components make it easy to build internationalized user interfaces
            using Seam.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.locale</tt></span></dt><dd><p>
                        The Seam locale.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.international.timezone</tt></span></dt><dd><p>
                        The Seam timezone. The timezone is session scoped.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.resourceBundle</tt></span></dt><dd><p>
                        The Seam resource bundle. The resource bundle is stateless. The Seam
                        resource bundle performs a depth-first search for keys in a list of Java
                        resource bundles.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.resourceLoader</tt></span></dt><dd><p>
                        The resource loader provides access to application resources and resource bundles.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">resourceLoader.bundleNames</tt> &#8212; the names of 
                            the Java resource bundles to search when the Seam resource bundle is
                            used. Default to <tt class="literal">messages</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.international.localeSelector</tt></span></dt><dd><p>
                        Supports selection of the locale either at configuration time, 
                        or by the user at runtime.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">select()</tt> &#8212; select the specified locale.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.locale</tt> &#8212; the actual
                            <tt class="literal">java.util.Locale</tt>.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.localeString</tt> &#8212; the 
                            stringified representation of the locale.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.language</tt> &#8212; the language for
                            the specified locale.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.country</tt> &#8212; the country for
                            the specified locale.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.variant</tt> &#8212; the variant for
                            the specified locale.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.supportedLocales</tt> &#8212; a list
                            of <tt class="literal">SelectItem</tt>s representing the supported locales 
                            listed in <tt class="literal">jsf-config.xml</tt>.
                        </p></li><li><p>
                            <tt class="literal">localeSelector.cookieEnabled</tt> &#8212; specifies
                            that the locale selection should be persisted via a cookie.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.international.timezoneSelector</tt></span></dt><dd><p>
                        Supports selection of the timezone either at configuration time, 
                        or by the user at runtime.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">select()</tt> &#8212; select the specified locale.
                        </p></li><li><p>
                            <tt class="literal">timezoneSelector.timezone</tt> &#8212; the actual
                            <tt class="literal">java.util.TimeZone</tt>.
                        </p></li><li><p>
                            <tt class="literal">timezoneSelector.timeZoneId</tt> &#8212; the 
                            stringified representation of the timezone.
                        </p></li><li><p>
                            <tt class="literal">timezoneSelector.cookieEnabled</tt> &#8212; specifies
                            that the timezone selection should be persisted via a cookie.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.international.messages</tt></span></dt><dd><p>
                        A map containing internationalized messages rendered from message
                        templates defined in the Seam resource bundle.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.theme.themeSelector</tt></span></dt><dd><p>
                        Supports selection of the theme either at configuration time, 
                        or by the user at runtime.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">select()</tt> &#8212; select the specified theme.
                        </p></li><li><p>
                            <tt class="literal">theme.availableThemes</tt> &#8212; the list of
                            defined themes.
                        </p></li><li><p>
                            <tt class="literal">themeSelector.theme</tt> &#8212; the selected
                            theme.
                        </p></li><li><p>
                            <tt class="literal">themeSelector.themes</tt> &#8212; a list
                            of <tt class="literal">SelectItem</tt>s representing the defined
                            themes.
                        </p></li><li><p>
                            <tt class="literal">themeSelector.cookieEnabled</tt> &#8212; specifies
                            that the theme selection should be persisted via a cookie.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.theme.theme</tt></span></dt><dd><p>
                        A map containing theme entries.
                    </p></dd></dl></div><p>
            All of these components are always installed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16590"></a>28.4.&nbsp;Components for controlling conversations</h2></div></div><div></div></div><p>
            The next group of components allow control of conversations by the application or 
            user interface.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.conversation</tt></span></dt><dd><p>
                        API for application control of attributes of the current Seam conversation.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">getId()</tt> &#8212; returns the current conversation id
                        </p></li><li><p>
                            <tt class="literal">isNested()</tt> &#8212; is the current conversation a
                            nested conversation?
                        </p></li><li><p>
                            <tt class="literal">isLongRunning()</tt> &#8212; is the current conversation a
                            long-running conversation?
                        </p></li><li><p>
                            <tt class="literal">getId()</tt> &#8212; returns the current conversation id
                        </p></li><li><p>
                            <tt class="literal">getParentId()</tt> &#8212; returns the conversation id
                            of the parent conversation
                        </p></li><li><p>
                            <tt class="literal">getRootId()</tt> &#8212; returns the conversation id
                            of the root conversation
                        </p></li><li><p>
                            <tt class="literal">setTimeout(int timeout)</tt> &#8212; sets the timeout
                            for the current conversation
                        </p></li><li><p>
                            <tt class="literal">setViewId(String outcome)</tt> &#8212; sets the view id
                            to be used when switching back to the current conversation from the 
                            conversation switcher, conversation list, or breadcrumbs.
                        </p></li><li><p>
                            <tt class="literal">setDescription(String description)</tt> &#8212; sets the 
                            description of the current conversation to be displayed in the 
                            conversation switcher, conversation list, or breadcrumbs.
                        </p></li><li><p>
                            <tt class="literal">redirect()</tt> &#8212; redirect to the last well-defined
                            view id for this conversation (useful after login challenges).
                        </p></li><li><p>
                            <tt class="literal">leave()</tt> &#8212; exit the scope of this conversation,
                            without actually ending the conversation.
                        </p></li><li><p>
                            <tt class="literal">begin()</tt> &#8212; begin a long-running conversation
                            (equivalent to <tt class="literal">@Begin</tt>).
                        </p></li><li><p>
                            <tt class="literal">beginPageflow(String pageflowName)</tt> &#8212; begin a 
                            long-running conversation with a pageflow (equivalent to 
                            <tt class="literal">@Begin(pageflow="...")</tt>).
                        </p></li><li><p>
                            <tt class="literal">end()</tt> &#8212; end a long-running conversation
                            (equivalent to <tt class="literal">@End</tt>).
                        </p></li><li><p>
                            <tt class="literal">pop()</tt> &#8212; pop the conversation stack, returning
                            to the parent conversation.
                        </p></li><li><p>
                            <tt class="literal">root()</tt> &#8212; return to the root conversation of 
                            the conversation stack.
                        </p></li><li><p>
                            <tt class="literal">changeFlushMode(FlushModeType flushMode)</tt> &#8212; change 
                            the flush mode of the conversation.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.conversationList</tt></span></dt><dd><p>
                        Manager component for the conversation list.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.conversationStack</tt></span></dt><dd><p>
                        Manager component for the conversation stack (breadcrumbs).
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.switcher</tt></span></dt><dd><p>
                        The conversation switcher.
                    </p></dd></dl></div><p>
            All of these components are always installed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16738"></a>28.5.&nbsp;jBPM-related components</h2></div></div><div></div></div><p>
            These components are for use with jBPM.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.pageflow.pageflow</tt></span></dt><dd><p>
                        API control of Seam pageflows.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">isInProcess()</tt> &#8212; returns <tt class="literal">true</tt>
                            if there is currently a pageflow in process
                        </p></li><li><p>
                            <tt class="literal">getProcessInstance()</tt> &#8212; returns jBPM
                            <tt class="literal">ProcessInstance</tt> for the current pageflow
                        </p></li><li><p>
                            <tt class="literal">begin(String pageflowName)</tt> &#8212; begin a pageflow
                            in the context of the current conversation
                        </p></li><li><p>
                            <tt class="literal">reposition(String nodeName)</tt> &#8212; reposition the
                            current pageflow to a particular node
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.actor</tt></span></dt><dd><p>
                        API for application control of attributes of the jBPM actor associated
                        with the current session.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">setId(String actorId)</tt> &#8212; sets the jBPM
                            actor id of the current user.
                        </p></li><li><p>
                            <tt class="literal">getGroupActorIds()</tt> &#8212; returns a 
                            <tt class="literal">Set</tt> to which jBPM actor ids for the
                            current users groups may be added.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.transition</tt></span></dt><dd><p>
                        API for application control of the jBPM transition for the current
                        task.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">setName(String transitionName)</tt> &#8212; sets the 
                            jBPM transition name to be used when the current task is ended
                            via <tt class="literal">@EndTask</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.businessProcess</tt></span></dt><dd><p>
                        API for programmatic control of the association between the
                        conversation and business process.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">businessProcess.taskId</tt> &#8212; the id of the task 
                            associated with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">businessProcess.processId</tt> &#8212; the id of the process
                            associated with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">businessProcess.hasCurrentTask()</tt> &#8212; is a task
                            instance associated with the current conversation?
                        </p></li><li><p>
                            <tt class="literal">businessProcess.hasCurrentProcess()</tt> &#8212; is a process
                            instance associated with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">createProcess(String name)</tt> &#8212; create an
                            instance of the named process definition and associate it with
                            the current conversation.
                        </p></li><li><p>
                            <tt class="literal">startTask()</tt> &#8212; start the task 
                            associated with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">endTask(String transitionName)</tt> &#8212; end the task 
                            associated with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">resumeTask(Long id)</tt> &#8212; associate the task with
                            the given id with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">resumeProcess(Long id)</tt> &#8212; associate the process 
                            with the given id with the current conversation.
                        </p></li><li><p>
                            <tt class="literal">transition(String transitionName)</tt> &#8212; trigger
                            the transition.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.taskInstance</tt></span></dt><dd><p>
                        Manager component for the jBPM <tt class="literal">TaskInstance</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.processInstance</tt></span></dt><dd><p>
                        Manager component for the jBPM <tt class="literal">ProcessInstance</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.jbpmContext</tt></span></dt><dd><p>
                        Manager component for an event-scoped <tt class="literal">JbpmContext</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.taskInstanceList</tt></span></dt><dd><p>
                        Manager component for the jBPM task list.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.pooledTaskInstanceList</tt></span></dt><dd><p>
                        Manager component for the jBPM pooled task list.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.taskInstanceListForType</tt></span></dt><dd><p>
                        Manager component for the jBPM task lists.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.pooledTask</tt></span></dt><dd><p>
                        Action handler for pooled task assignment.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.processInstanceFinder</tt></span></dt><dd><p>
                        Manager for the process instance task list.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.processInstanceList</tt></span></dt><dd><p>
                         The process instance task list.
                    </p></dd></dl></div><p>
            All of these components are installed whenever the component
            <tt class="literal">org.jboss.seam.bpm.jbpm</tt> is installed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16967"></a>28.6.&nbsp;Security-related components</h2></div></div><div></div></div><p>
            These components relate to web-tier security.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.web.userPrincipal</tt></span></dt><dd><p>
                        Manager component for the current user <tt class="literal">Principal</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.web.isUserInRole</tt></span></dt><dd><p>
                        Allows JSF pages to choose to render a control, depending upon
                        the roles available to the current principal.
                        <tt class="literal">&lt;h:commandButton value="edit" rendered="#{isUserInRole['admin']}"/&gt;</tt>.
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16993"></a>28.7.&nbsp;JMS-related components</h2></div></div><div></div></div><p>
            These components are for use with managed <tt class="literal">TopicPublisher</tt>s
            and <tt class="literal">QueueSender</tt>s (see below).
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.jms.queueSession</tt></span></dt><dd><p>
                        Manager component for a JMS <tt class="literal">QueueSession</tt> .
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.jms.topicSession</tt></span></dt><dd><p>
                        Manager component for a JMS <tt class="literal">TopicSession</tt> .
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components.mail"></a>28.8.&nbsp;Mail-related components</h2></div></div><div></div></div><p>
            These components are for use with Seam's Email support 
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.mail.mailSession</tt></span></dt><dd><p>
                        Manager component for a JavaMail <tt class="literal">Session</tt>. The
                        session can be either looked up in the JNDI context (by setting the
                        <tt class="literal">sessionJndiName</tt> property) or it can created from the
                        configuration options in which case the <tt class="literal">host</tt> is
                        mandatory. 
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.host</tt> &#8212; the hostname of the SMTP server to use
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.port</tt> &#8212; the port of the SMTP server to use
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.username</tt> &#8212;  the username to use to connect to the SMTP server.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.password</tt> &#8212; the password to use to connect to the SMTP server
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.debug</tt> &#8212; enable JavaMail debugging (very verbose)
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.ssl</tt> &#8212; enable SSL connection to SMTP (will default to port 465)
                        </p><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.tls</tt> &#8212; by default true, enable TLS support in the mail session
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.mail.mailSession.sessionJndiName</tt> &#8212; name under which a javax.mail.Session is bound to JNDI.
                            If supplied, all other properties will be ignored.
                        </p></li></ul></div></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17095"></a>28.9.&nbsp;Infrastructural components</h2></div></div><div></div></div><p>
            These components provide critical platform infrastructure. You can install a component
            which isn't installed by default by setting <tt class="literal">install="true"</tt> on the 
            component in <tt class="literal">components.xml</tt>.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.init</tt></span></dt><dd><p>
                        Initialization settings for Seam. Always installed.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.core.init.jndiPattern</tt> &#8212; the JNDI
                            pattern used for looking up session beans
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.init.debug</tt> &#8212; enable Seam
                            debug mode
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.init.clientSideConversations</tt> &#8212; 
                            if set to <tt class="literal">true</tt>, Seam will save conversation context
                            variables in the client instead of in the <tt class="literal">HttpSession</tt>.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.init.userTransactionName</tt> &#8212; the JNDI
                            name to use when looking up the JTA <tt class="literal">UserTransaction</tt> object.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.manager</tt></span></dt><dd><p>
                        Internal component for Seam page and conversation context management. 
                        Always installed.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.core.manager.conversationTimeout</tt> &#8212; 
                            the conversation context timeout in milliseconds.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.manager.concurrentRequestTimeout</tt> &#8212; 
                            maximum wait time for a thread attempting to gain a lock on the long-running 
                            conversation context.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.manager.conversationIdParameter</tt> &#8212; 
                            the request parameter used to propagate the conversation id, default
                            to <tt class="literal">conversationId</tt>.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.core.manager.conversationIsLongRunningParameter</tt> &#8212; 
                            the request parameter used to propagate information about whether the conversation
                            is long-running, default to <tt class="literal">conversationIsLongRunning</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.navigation.pages</tt></span></dt><dd><p>
                        Internal component for Seam workspace management. Always installed.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.navigation.pages.noConversationViewId</tt> 
                            &#8212; global setting for the view id to redirect to when a 
                            conversation entry is not found on the server side.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.navigation.pages.loginViewId</tt> 
                            &#8212; global setting for the view id to redirect to when an 
                            unauthenticated user tries to access a protected view.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.navigation.pages.httpPort</tt> 
                            &#8212; global setting for the port to use when the http scheme 
                            is requested.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.navigation.pages.httpsPort</tt> 
                            &#8212; global setting for the port to use when the https scheme 
                            is requested.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.navigation.pages.resources</tt> 
                            &#8212; a list of resources to search for <tt class="literal">pages.xml</tt>
                            style resources.  Defaults to <tt class="literal">WEB-INF/pages.xml</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.bpm.jbpm</tt></span></dt><dd><p>
                        Bootstraps a <tt class="literal">JbpmConfiguration</tt>. Install as class 
                        <tt class="literal">org.jboss.seam.bpm.Jbpm</tt>. 
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.bpm.jbpm.processDefinitions</tt> &#8212; 
                            a list of resource names of jPDL files to be used for orchestration
                            of business processes.
                        </p></li><li><p>
                            <tt class="literal">org.jboss.seam.bpm.jbpm.pageflowDefinitions</tt> &#8212; 
                            a list of resource names of jPDL files to be used for orchestration
                            of conversation page flows.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.conversationEntries</tt></span></dt><dd><p>
                        Internal session-scoped component recording the active long-running conversations
                        between requests.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.facesPage</tt></span></dt><dd><p>
                        Internal page-scoped component recording the conversation context associated
                        with a page.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.persistence.persistenceContexts</tt></span></dt><dd><p>
                        Internal component recording the persistence contexts which were used in
                        the current conversation.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.jms.queueConnection</tt></span></dt><dd><p>
                        Manages a JMS <tt class="literal">QueueConnection</tt>. Installed whenever
                        managed managed <tt class="literal">QueueSender</tt> is installed.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.jms.queueConnection.queueConnectionFactoryJndiName</tt> 
                            &#8212; the JNDI name of a JMS <tt class="literal">QueueConnectionFactory</tt>. Default
                            to <tt class="literal">UIL2ConnectionFactory</tt>
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.jms.topicConnection</tt></span></dt><dd><p>
                        Manages a JMS <tt class="literal">TopicConnection</tt>. Installed whenever
                        managed managed <tt class="literal">TopicPublisher</tt> is installed.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">org.jboss.seam.jms.topicConnection.topicConnectionFactoryJndiName</tt> 
                            &#8212; the JNDI name of a JMS <tt class="literal">TopicConnectionFactory</tt>. Default
                            to <tt class="literal">UIL2ConnectionFactory</tt>
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal">org.jboss.seam.persistence.persistenceProvider</tt></span></dt><dd><p>
                        Abstraction layer for non-standardized features of JPA provider.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.core.validators</tt></span></dt><dd><p>
                        Caches instances of Hibernate Validator <tt class="literal">ClassValidator</tt>.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.validation</tt></span></dt><dd><p>
                        Allows the application to determine whether validation
                        failed or was successful.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.debug.introspector</tt></span></dt><dd><p>
                        Support for the Seam Debug Page.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.debug.contexts</tt></span></dt><dd><p>
                        Support for the Seam Debug Page.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.exception.exceptions</tt></span></dt><dd><p>
                        Internal component for exception handling.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.transaction.transaction</tt></span></dt><dd><p>
                         API for controlling transactions and abstracting the underlying
                         transaction management implementation behind a JTA-compatible
                         interface.
                    </p></dd><dt><span class="term"><tt class="literal">org.jboss.seam.faces.safeActions</tt></span></dt><dd><p>
                        Decides if an action expression in an incoming URL is safe.  This 
                        is done by checking that the action expression exists in the view.
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17388"></a>28.10.&nbsp;Miscellaneous components</h2></div></div><div></div></div><p>
            These components don't fit into 
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.async.dispatcher</tt></span></dt><dd><p>
                        Dispatcher stateless session bean for asynchronous methods.
                    </p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.image</tt></span></dt><dd><p>
                         Image manipulation and interrogation.
                    </p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.pojoCache</tt></span></dt><dd><p>
                        Manager component for a PojoCache instance.
                    </p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.jboss.seam.core.uiComponent</tt></span></dt><dd><p>
                        Manages a map of UIComponents keyed by component id.
                    </p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17425"></a>28.11.&nbsp;Special components</h2></div></div><div></div></div><p>
            Certain special Seam component classes are installable multiple times under names
            specified in the Seam configuration. For example, the following lines in 
            <tt class="literal">components.xml</tt> install and configure two Seam components:
        </p><pre class="programlisting">&lt;component name="bookingDatabase"
          class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
    &lt;property name="persistenceUnitJndiName"&gt;java:/comp/emf/bookingPersistence&lt;/property&gt;
&lt;/component&gt;

&lt;component name="userDatabase"
          class="org.jboss.seam.persistence.ManagedPersistenceContext"&gt;
    &lt;property name="persistenceUnitJndiName"&gt;java:/comp/emf/userPersistence&lt;/property&gt;
&lt;/component&gt;</pre><p>
            The Seam component names are <tt class="literal">bookingDatabase</tt> and 
            <tt class="literal">userDatabase</tt>.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;entityManager&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.persistence.ManagedPersistenceContext</tt></span></dt><dd><p>
                        Manager component for a conversation scoped managed <tt class="literal">EntityManager</tt>
                        with an extended persistence context.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;entityManager&gt;</em></span>.entityManagerFactory</tt> 
                            &#8212; a value binding expression that evaluates to an instance of 
                            <tt class="literal">EntityManagerFactory</tt>.
                        </p><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;entityManager&gt;</em></span>.persistenceUnitJndiName</tt> 
                            &#8212; the JNDI name of the entity manager factory, default to 
                            <tt class="literal">java:/<span class="emphasis"><em>&lt;managedPersistenceContext&gt;</em></span></tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;entityManagerFactory&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.persistence.EntityManagerFactory</tt></span></dt><dd><p>
                        Manages a JPA <tt class="literal">EntityManagerFactory</tt>. This is most useful
                        when using JPA outside of an EJB 3.0 supporting environment.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">entityManagerFactory.persistenceUnitName</tt> &#8212; 
                            the name of the persistence unit.
                        </p></li></ul></div><p>
                        See the API JavaDoc for further configuration properties.
                    </p></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;session&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.persistence.ManagedSession</tt></span></dt><dd><p>
                        Manager component for a conversation scoped managed Hibernate <tt class="literal">Session</tt>.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;session&gt;</em></span>.sessionFactory</tt> 
                            &#8212; a value binding expression that evaluates to an instance of 
                            <tt class="literal">SessionFactory</tt>.
                        </p><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;session&gt;</em></span>.sessionFactoryJndiName</tt> 
                            &#8212; the JNDI name of the session factory, default to 
                            <tt class="literal">java:/<span class="emphasis"><em>&lt;managedSession&gt;</em></span></tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;sessionFactory&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.persistence.HibernateSessionFactory</tt></span></dt><dd><p>
                        Manages a Hibernate <tt class="literal">SessionFactory</tt>.  
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal">&lt;sessionFactory&gt;.cfgResourceName</tt> &#8212; 
                            the path to the configuration file. Default to <tt class="literal">hibernate.cfg.xml</tt>.
                        </p></li></ul></div><p>
                        See the API JavaDoc for further configuration properties.
                    </p></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;managedQueueSender&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.jms.ManagedQueueSender</tt></span></dt><dd><p>
                        Manager component for an event scoped managed JMS <tt class="literal">QueueSender</tt>.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;managedQueueSender&gt;</em></span>.queueJndiName</tt> 
                            &#8212; the JNDI name of the JMS queue.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;managedTopicPublisher&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.jms.ManagedTopicPublisher</tt></span></dt><dd><p>
                        Manager component for an event scoped managed JMS <tt class="literal">TopicPublisher</tt>.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;managedTopicPublisher&gt;</em></span>.topicJndiName</tt> 
                            &#8212; the JNDI name of the JMS topic.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;managedWorkingMemory&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.drools.ManagedWorkingMemory</tt></span></dt><dd><p>
                        Manager component for a conversation scoped managed Drools <tt class="literal">WorkingMemory</tt>.
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;managedWorkingMemory&gt;</em></span>.ruleBase</tt> 
                            &#8212; a value expression that evaluates to an instance of <tt class="literal">RuleBase</tt>.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;ruleBase&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.drools.RuleBase</tt></span></dt><dd><p>
                        Manager component for an application scoped Drools <tt class="literal">RuleBase</tt>.
                        <span class="emphasis"><em>Note that this is not really intended for production usage, since
                        it does not support dynamic installation of new rules.</em></span>
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;ruleBase&gt;</em></span>.ruleFiles</tt> 
                            &#8212; a list of files containing Drools rules.
                        </p><p>
                            <tt class="literal"><span class="emphasis"><em>&lt;ruleBase&gt;</em></span>.dslFile</tt> 
                            &#8212; a Drools DSL definition.
                        </p></li></ul></div></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;entityHome&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.framework.EntityHome</tt></span></dt><dd></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;hibernateEntityHome&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.framework.HibernateEntityHome</tt></span></dt><dd></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;entityQuery&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.framework.EntityQuery</tt></span></dt><dd></dd><dt><span class="term"><tt class="literal"><span class="emphasis"><em>&lt;hibernateEntityQuery&gt;</em></span></tt>, </span><span class="term"><tt class="literal">org.jboss.seam.framework.HibernateEntityQuery</tt></span></dt><dd></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="controls"></a>Chapter&nbsp;29.&nbsp;Seam JSF controls</h2></div></div><div></div></div><p>
    Seam includes a number of JSF controls that are useful for working with
    Seam. These are intended to complement the built-in JSF controls, and
    controls from other third-party libraries. We recommend
    JBoss RichFaces, and Apache MyFaces Trinidad tag libraries for use with Seam.
    We do not recommend the use of the Tomahawk tag library.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controls.tags"></a>29.1.&nbsp;Tags</h2></div></div><div></div></div><p>
    To use these tags, define the "<tt class="literal">s</tt>" namespace in your page 
    as follows (facelets only):
  </p><pre class="programlisting">&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:s="http://jboss.com/products/seam/taglib"&gt;</pre><p>
    The ui example demonstrates the use of a number of these tags.
  </p><div class="table"><a name="d0e17731"></a><p class="title"><b>Table&nbsp;29.1.&nbsp;Seam JSF Control Reference</b></p><table summary="Seam JSF Control Reference" border="1"><colgroup><col><col></colgroup><tbody><tr><td valign="top"><p>
              <tt class="literal">&lt;s:button&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              A button that supports invocation of an action with control
              over conversation propagation. <span class="emphasis"><em>Does not submit the form.</em></span>
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">value</tt> &#8212; the label.
                </p></li><li><p>
                  <tt class="literal">action</tt> &#8212; a method binding that specified
                  the action listener.
                </p></li><li><p>
                  <tt class="literal">view</tt> &#8212; the JSF view id to link to.
                </p></li><li><p>
                  <tt class="literal">fragment</tt> &#8212; the fragment identifier to link to.
                </p></li><li><p>
                  <tt class="literal">disabled</tt> &#8212; is the link disabled?
                </p></li><li><p>
                  <tt class="literal">propagation</tt> &#8212; determines the conversation
                  propagation style: <tt class="literal">begin</tt>, <tt class="literal">join</tt>,
                  <tt class="literal">nest</tt>, <tt class="literal">none</tt> or <tt class="literal">end</tt>.
                </p></li><li><p>
                  <tt class="literal">pageflow</tt> &#8212; a pageflow definition to begin.
                  (This is only useful when <tt class="literal">propagation="begin"</tt> or
                  <tt class="literal">propagation="join"</tt>.)
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:button id="cancel" value="Cancel" 
          action="#{hotelBooking.cancel}"/&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:cache&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Cache the rendered page fragment using JBoss Cache. Note that
              <tt class="literal">&lt;s:cache&gt;</tt> actually uses the instance
              of JBoss Cache managed by the built-in <tt class="literal">pojoCache</tt>
              component.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">key</tt> &#8212; the key to cache rendered content,
                  often a value expression. For example, if we were caching a page
                  fragment that displays a document, we might use
                  <tt class="literal">key="Document-#{document.id}"</tt>.
                </p></li><li><p>
                  <tt class="literal">enabled</tt> &#8212; a value expression that determines
                  if the cache should be used.
                </p></li><li><p>
                  <tt class="literal">region</tt> &#8212; a JBoss Cache node to use (different
                  nodes can have different expiry policies).
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:cache key="entry-#{blogEntry.id}" region="pageFragments"&gt;
  &lt;div class="blogEntry"&gt;
    &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
    &lt;div&gt;
      &lt;s:formattedText value="#{blogEntry.body}"/&gt;
    &lt;/div&gt;
    &lt;p&gt;
      [Posted on&amp;#160;
      &lt;h:outputText value="#{blogEntry.date}"&gt;
        &lt;f:convertDateTime timezone="#{blog.timeZone}" locale="#{blog.locale}" 
                           type="both"/&gt;
      &lt;/h:outputText&gt;]
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/s:cache&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:conversationId&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Add the conversation id to an output link (or similar JSF control).
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:conversationPropagation&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
                Customize the conversation propagation for a command link or button
                (or similar JSF control). <span class="emphasis"><em>Facelets only.</em></span>
              </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                     <tt class="literal">propagation</tt> &#8212; determines the conversation
                     propagation style: <tt class="literal">begin</tt>, <tt class="literal">join</tt>,
                     <tt class="literal">nest</tt>, <tt class="literal">none</tt> or <tt class="literal">end</tt>.
                  </p></li><li><p>
                    <tt class="literal">pageflow</tt> &#8212; a pageflow definition to begin.
                    (This is only useful when <tt class="literal">propagation="begin"</tt> or
                    <tt class="literal">propagation="join"</tt>.)
                  </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:commandButton value="Apply" action="#{personHome.update}"&gt;
  &lt;s:conversationPropagation type="join" /&gt;
&lt;/h:commandButton&gt;</pre></td></tr><tr><td valign="top"><p><tt class="literal">&lt;s:convertDateTime&gt;</tt></p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Perform date or time conversions in the Seam timezone.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:outputText value="#{item.orderDate}"&gt;
  &lt;s:convertDateTime type="both" dateStyle="full"/&gt;
&lt;/h:outputText&gt;</pre></td></tr><tr><td valign="top"><p><tt class="literal">&lt;s:convertEntity&gt;</tt></p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
               Assigns an entity converter to the current component.  This is primarily
               useful for radio button and dropdown controls.
            </p><p>
              The converter works with any managed entity which has an <tt class="literal">@Id</tt> annotation -
              either simple or composite.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Configuration</em></span></p><p>
              You must use <span class="emphasis"><em>Seam managed transactions</em></span> (see <a href="#persistence.seam-managed-transactions" title="8.2.&nbsp;Seam managed transactions">Section&nbsp;8.2, &#8220;Seam managed transactions&#8221;</a>) with <tt class="literal">&lt;s:convertEntity /&gt;</tt>.
            </p><p>
              If your <span class="emphasis"><em>Managed Persistence Context</em></span> isn't called
              <tt class="literal">entityManager</tt>, then you need to set it in components.xml:
            </p><pre class="programlisting">&lt;component name="org.jboss.seam.ui.EntityConverter"&gt;
  &lt;property name="entityManager"&gt;#{em}&lt;/property&gt;
&lt;/component&gt;</pre><p>
              If you want to use more than one entity manager with the entity 
              converter, you can create a copy of the entity converter for each
              entity manager; in components.xml:
            </p><pre class="programlisting">&lt;component name="myEntityConverter" class="org.jboss.seam.ui.converter.EntityConverter"&gt;
  &lt;property name="entityManager"&gt;#{em}&lt;/property&gt;
&lt;/component&gt;</pre><pre class="programlisting">&lt;h:selectOneMenu value="#{person.continent}"&gt;
  &lt;s:selectItems value="#{continents.resultList}" var="continent" 
                 label="#{continent.name}" /&gt;
    &lt;f:converter converterId="myEntityConverter" /&gt;
&lt;/h:selectOneMenu&gt;</pre><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:selectOneMenu value="#{person.continent}" required="true"&gt;
  &lt;s:selectItems value="#{continents.resultList}" var="continent" 
                 label="#{continent.name}" 
                 noSelectionLabel="Please Select..."/&gt;
    &lt;s:convertEntity /&gt;
&lt;/h:selectOneMenu&gt;</pre></td></tr><tr><td valign="top"><p><tt class="literal">&lt;s:convertEnum&gt;</tt></p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Assigns an enum converter to the current component.  This is primarily
              useful for radio button and dropdown controls.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:selectOneMenu value="#{person.honorific}"&gt;
  &lt;s:selectItems value="#{honorifics}" var="honorific" 
                 label="#{honorific.label}"
                 noSelectionLabel="Please select" /&gt;
  &lt;s:convertEnum /&gt;
&lt;/h:selectOneMenu&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:decorate&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              "Decorate" a JSF input field when validation fails or when
              <tt class="literal">required="true"</tt> is set.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">template</tt> &#8212; the facelets template to use to decorate the component
                </p></li></ul></div><p>
              <tt class="literal">#{invalid}</tt> and <tt class="literal">#{required}</tt> are 
              available inside <tt class="literal">s:decorate</tt>; <tt class="literal">#{required}</tt> 
              evaluates to <tt class="literal">true</tt> if you have set the input component 
              being decorated as required, and <tt class="literal">#{invalid}</tt> evaluates 
              to <tt class="literal">true</tt> if a validation error occurs.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:decorate template="edit.xhtml"&gt;
  &lt;ui:define name="label"&gt;Country:&lt;/ui:define&gt;
    &lt;h:inputText value="#{location.country}" required="true"/&gt;
  &lt;/s:decorate&gt;</pre><pre class="programlisting">&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://java.sun.com/jsf/facelets"
    xmlns:h="http://java.sun.com/jsf/html"
    xmlns:f="http://java.sun.com/jsf/core"
    xmlns:s="http://jboss.com/products/seam/taglib"&gt;
                  
  &lt;div&gt;   
   
    &lt;s:label styleClass="#{invalid?'error':''}"&gt;
      &lt;ui:insert name="label"/&gt;
      &lt;s:span styleClass="required" rendered="#{required}"&gt;*&lt;/s:span&gt;
    &lt;/s:label&gt;
        
    &lt;span class="#{invalid?'error':''}"&gt;
      &lt;s:validateAll&gt;
        &lt;ui:insert/&gt;
      &lt;/s:validateAll&gt;
    &lt;/span&gt;
        
    &lt;s:message styleClass="error"/&gt;     
      
  &lt;/div&gt;   
  
&lt;/ui:composition&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:div&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
               Render a HTML <tt class="literal">&lt;div&gt;</tt>.
             </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:div rendered="#{selectedMember == null}"&gt;
  Sorry, but this member does not exist.
&lt;/s:div&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:enumItem&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
                Creates a <tt class="literal">SelectItem</tt> from an enum value.
              </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                     <tt class="literal">enumValue</tt> &#8212; the string representation of the enum
                     value.
                  </p></li><li><p>
                    <tt class="literal">label</tt> &#8212; the label to be used when rendering the <tt class="literal">SelectItem</tt>.
                  </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:selectOneRadio id="radioList"
                  layout="lineDirection"
                  value="#{newPayment.paymentFrequency}"&gt;
  &lt;s:convertEnum /&gt;
  &lt;s:enumItem enumValue="ONCE" label="Only Once" /&gt;
  &lt;s:enumItem enumValue="EVERY_MINUTE" label="Every Minute" /&gt;
  &lt;s:enumItem enumValue="HOURLY"       label="Every Hour" /&gt;
  &lt;s:enumItem enumValue="DAILY"        label="Every Day" /&gt;
  &lt;s:enumItem enumValue="WEEKLY"       label="Every Week" /&gt;
&lt;/h:selectOneRadio&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:fileUpload&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
               Renders a file upload control.  This control must be used within a form with
               an encoding type of <tt class="literal">multipart/form-data</tt>, i.e:
            </p><pre class="programlisting">&lt;h:form enctype="multipart/form-data"&gt;</pre><p>
              For multipart requests, the Seam Multipart servlet filter must also be configured
              in <tt class="literal">web.xml</tt>:
            </p><pre class="programlisting">&lt;filter&gt;
  &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.jboss.seam.servlet.SeamFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;Seam Filter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre><p><span class="emphasis"><em>Configuration</em></span></p><p>
              The following configuration options for multipart requests may be configured in components.xml:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">createTempFiles</tt> &#8212; if this option is set to true, uploaded files are
                  streamed to a temporary file instead of in memory.
                </p></li><li><p>
                  <tt class="literal">maxRequestSize</tt> &#8212; the maximum size of a file upload request, in bytes.
                </p></li></ul></div><p>
              Here's an example:
            </p><pre class="programlisting">&lt;component class="org.jboss.seam.web.MultipartFilter"&gt;
  &lt;property name="createTempFiles"&gt;true&lt;/property&gt;
  &lt;property name="maxRequestSize"&gt;1000000&lt;/property&gt;
&lt;/component&gt;</pre><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">data</tt> &#8212; this value binding receives the binary file data.
                  The receiving field should be declared as a <tt class="literal">byte[]</tt> or <tt class="literal">InputStream</tt> (required).
                </p></li><li><p>
                  <tt class="literal">contentType</tt> &#8212; this value binding receives the file's
                  content type (optional).
                </p></li><li><p>
                  <tt class="literal">fileName</tt> &#8212; this value binding receives the filename (optional).
                </p></li><li><p>
                  <tt class="literal">fileSize</tt> &#8212; this value binding receives the file size (optional).
                </p></li><li><p>
                  <tt class="literal">accept</tt> &#8212; a comma-separated list of content types to accept,
                  may not be supported by the browser.  E.g. <tt class="literal">"images/png,images/jpg"</tt>,
                  <tt class="literal">"images/*"</tt>.
                </p></li><li><p>
                  <tt class="literal">style</tt> &#8212; The control's style
                </p></li><li><p>
                  <tt class="literal">styleClass</tt> &#8212; The control's style class
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:fileUpload id="picture" data="#{register.picture}" 
              accept="image/png"
              contentType="#{register.pictureContentType}" /&gt;</pre></td></tr><tr><td valign="top"><p><tt class="literal">&lt;s:formattedText&gt;</tt></p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
               Outputs <span class="emphasis"><em>Seam Text</em></span>, a rich text markup useful for blogs, wikis and
               other applications that might use rich text.  See the Seam Text chapter for full usage.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">value</tt> &#8212; an EL expression specifying the rich text markup to render.
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:formattedText value="#{blog.text}"/&gt;</pre><p><span class="emphasis"><em>Example</em></span></p><div class="mediaobject" align="center"><img src="../shared/images/controls-seamtext.png" align="middle"></div></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:validateFormattedText&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Checks that the submitted value is valid Seam Text
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:fragment&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              A non-rendering component useful for enabling/disabling rendering of it's children.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:fragment rendered="#{auction.highBidder ne null}"&gt;
  Current bid:
&lt;/s:fragment&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:graphicImage&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              An extended <tt class="literal">&lt;h:graphicImage&gt;</tt> that allows the image to be created in a Seam Component; further transforms
              can be applied to the image.
            </p><p>
              All attributes for <tt class="literal">&lt;h:graphicImage&gt;</tt> are supported, as well as:
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                 <tt class="literal">value</tt> &#8212; image to display.  Can be a path <tt class="literal">String</tt>
                 (loaded from the classpath), a <tt class="literal">byte[]</tt>, a <tt class="literal">java.io.File</tt>,
                 a <tt class="literal">java.io.InputStream</tt> or a <tt class="literal">java.net.URL</tt>.  Currently supported
                 image formats are <tt class="literal">image/png</tt>, <tt class="literal">image/jpeg</tt> and <tt class="literal">image/gif</tt>.
               </p></li><li><p>
                 <tt class="literal">fileName</tt> &#8212; if not specified the served image will have a generated file name.
                 If you want to name your file, you should specify it here.  This name should be unique
               </p></li></ul></div><p><span class="emphasis"><em>Transformations</em></span></p><p>
               To apply a transform to the image, you would nest a tag specifying the transform to apply.  Seam currently supports these
               transforms:
             </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">&lt;s:transformImageSize&gt;</tt></span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">width</tt> &#8212; new width of the image
                      </p></li><li><p>
                        <tt class="literal">height</tt> &#8212; new height of the image
                      </p></li><li><p>
                        <tt class="literal">maintainRatio</tt> &#8212; if <tt class="literal">true</tt>, and <span class="emphasis"><em>one</em></span> of
                        <tt class="literal">width</tt>/<tt class="literal">height</tt> are specified, the image will be resized with the
                        dimension not specified being calculated to maintain the aspect ratio.
                      </p></li><li><p>
                        <tt class="literal">factor</tt> &#8212; scale the image by the given factor
                      </p></li></ul></div></dd><dt><span class="term"><tt class="literal">&lt;s:transformImageBlur&gt;</tt></span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">radius</tt> &#8212; perform a convolution blur with the given radius
                      </p></li></ul></div></dd><dt><span class="term"><tt class="literal">&lt;s:transformImageType&gt;</tt></span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">contentType</tt> &#8212; alter the type of the image to either <tt class="literal">image/jpeg</tt> or <tt class="literal">image/png</tt>
                      </p></li></ul></div></dd></dl></div><p>
              It's easy to create your own transform - create a <tt class="literal">UIComponent</tt> which <tt class="literal">implements</tt>
              <tt class="literal">org.jboss.seam.ui.graphicImage.ImageTransform</tt>.  Inside the <tt class="literal">applyTransform()</tt>method
              use <tt class="literal">image.getBufferedImage()</tt> to get the original image and <tt class="literal">image.setBufferedImage()</tt>
              to set your transformed image.  Transforms are applied in the order specified in the view.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:graphicImage rendered="#{auction.image ne null}"
                value="#{auction.image.data}"&gt;
  &lt;s:transformImageSize width="200" maintainRatio="true"/&gt;
&lt;/s:graphicImage&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:link&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              A link that supports invocation of an action with control over conversation
              propagation. <span class="emphasis"><em>Does not submit the form.</em></span>
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">value</tt> &#8212; the label.
                </p></li><li><p>
                  <tt class="literal">action</tt> &#8212; a method binding that specified
                  the action listener.
                </p></li><li><p>
                  <tt class="literal">view</tt> &#8212; the JSF view id to link to.
                </p></li><li><p>
                  <tt class="literal">fragment</tt> &#8212; the fragment identifier to link to.
                </p></li><li><p>
                  <tt class="literal">disabled</tt> &#8212; is the link disabled?
                </p></li><li><p>
                  <tt class="literal">propagation</tt> &#8212; determines the conversation
                  propagation style: <tt class="literal">begin</tt>, <tt class="literal">join</tt>,
                  <tt class="literal">nest</tt>, <tt class="literal">none</tt> or <tt class="literal">end</tt>.
                </p></li><li><p>
                  <tt class="literal">pageflow</tt> &#8212; a pageflow definition to begin.
                  (This is only useful when <tt class="literal">propagation="begin"</tt> or
                  <tt class="literal">propagation="join"</tt>.)
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:link id="register" view="/register.xhtml" 
        value="Register New User"/&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:message&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              "Decorate" a JSF input field with the validation error message.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;f:facet name="afterInvalidField"&gt;
  &lt;s:span&gt;
    &amp;#160;Error:&amp;#160;
    &lt;s:message/&gt;
  &lt;/s:span&gt;
&lt;/f:facet&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:label&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              "Decorate" a JSF input field with the label.  The label is placed inside 
              the HTML <tt class="literal">&lt;label&gt;</tt> tag, and is associated with the
              nearest JSF input component.  It is often used with <tt class="literal">&lt;s:decorate&gt;</tt>.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">style</tt> &#8212; The control's style
                </p></li><li><p>
                  <tt class="literal">styleClass</tt> &#8212; The control's style class
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:label styleClass="label"&gt;
  Country:
&lt;/s:label&gt;
&lt;h:inputText value="#{location.country}" required="true"/&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:remote&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Generates the Javascript stubs required to use Seam Remoting.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">include</tt> &#8212; a comma-separated list of the component names (or fully qualified class names)
                  for which to generate Seam Remoting Javascript stubs.  See <a href="#remoting" title="Chapter&nbsp;21.&nbsp;Remoting">Chapter&nbsp;21, <i>Remoting</i></a> for more details.
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:remote include="customerAction,accountAction,com.acme.MyBean"/&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:selectDate&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              <span class="emphasis"><em>Deprecated.  Use <tt class="literal">&lt;rich:calendar /&gt;</tt> instead.</em></span>
            </p><p>
               Displays a dynamic date picker component that selects a date for the specified input field.
               The body of the <tt class="literal">selectDate</tt> element should contain HTML elements, such as
               text or an image, that prompt the user to click to display the date picker.  The date picker
               <span class="emphasis"><em>must</em></span> be styled using CSS.  An example CSS file can be found in the Seam
               booking demo as <tt class="literal">date.css</tt>, or can be generated using seam-gen.  The CSS
               styles used to control the appearance of the date picker are also described below.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">for</tt> &#8212; The id of the input field that the date picker will insert the
                  selected date into.
                </p></li><li><p>
                  <tt class="literal">dateFormat</tt> &#8212; The date format string.  This should match the date format of the
                  input field.
                </p></li><li><p>
                  <tt class="literal">startYear</tt> &#8212; The popup year selector range will start at this year.
                </p></li><li><p>
                  <tt class="literal">endYear</tt> &#8212; The popup year selector range will end at this year.
                </p></li><li><p>
                  <tt class="literal">firstDayOfWeek</tt> &#8212; Controls which day is the first day of the week 
                  (0 = Sunday, 6 = Saturday).  If this attribute is not set, then the first day of the week will
                  default based on the user's locale.
                </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><p>
              </p><pre class="programlisting">&lt;div class="row"&gt;
  &lt;h:outputLabel for="dob"&gt;Date of birth&lt;em&gt;*&lt;/em&gt;&lt;/h:outputLabel&gt;
  &lt;h:inputText id="dob" value="#{user.dob}" required="true"&gt;
    &lt;s:convertDateTime pattern="MM/dd/yyyy"/&gt;
  &lt;/h:inputText&gt;
  &lt;s:selectDate for="dob" startYear="1910" endYear="2007"&gt;
    &lt;img src="img/datepicker.png"/&gt;
  &lt;/s:selectDate&gt;
  &lt;div class="validationError"&gt;&lt;h:message for="dob"/&gt;&lt;/div&gt;
&lt;/div&gt;</pre><p>
            </p><p><span class="emphasis"><em>Example</em></span></p><div class="mediaobject" align="center"><img src="../shared/images/controls-selectdate.png" align="middle"></div><p><span class="emphasis"><em>CSS Styling</em></span></p><p>
              The following list describes the CSS class names that are used to control the style of the selectDate control.
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <tt class="literal">seam-date</tt> &#8212; This class is applied to the outer <tt class="literal">div</tt> containing the
                  popup calendar. (1) It is also applied to the <tt class="literal">table</tt> that controls the inner layout of the
                  calendar. (2)
                </p></li><li><p>
                  <tt class="literal">seam-date-header</tt> &#8212; This class is applied to the calendar header table row (<tt class="literal">tr</tt>)
                  and header table cells (<tt class="literal">td</tt>). (3)
                </p></li><li><p>
                  <tt class="literal">seam-date-header-prevMonth</tt> &#8212; This class is applied to the "previous month" table cell,
                  (<tt class="literal">td</tt>), which when clicked causes the calendar to display the month prior to the one currently
                  displayed.  (4)
                </p></li><li><p>
                  <tt class="literal">seam-date-header-nextMonth</tt> &#8212; This class is applied to the "next month" table cell,
                  (<tt class="literal">td</tt>), which when clicked causes the calendar to display the month following the one currently
                  displayed.  (5)
                </p></li><li><p>
                  <tt class="literal">seam-date-headerDays</tt> &#8212; This class is applied to the calendar days header row
                  (<tt class="literal">tr</tt>), which contains the names of the week days. (6)
                </p></li><li><p>
                  <tt class="literal">seam-date-footer</tt> &#8212; This class is applied to the calendar footer row
                  (<tt class="literal">tr</tt>), which displays the current date. (7)
                </p></li><li><p>
                  <tt class="literal">seam-date-inMonth</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) elements that contain a date within the month currently displayed. (8)
                </p></li><li><p>
                  <tt class="literal">seam-date-outMonth</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) elements that contain a date outside of the month currently displayed. (9)
                </p></li><li><p>
                  <tt class="literal">seam-date-selected</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) element that contains the currently selected date. (10)
                </p></li><li><p>
                  <tt class="literal">seam-date-dayOff-inMonth</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) elements that contain a "day off" date (i.e. weekend days, Saturday and Sunday)
                  within the currently selected month. (11)
                </p></li><li><p>
                  <tt class="literal">seam-date-dayOff-outMonth</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) elements that contain a "day off" date (i.e. weekend days, Saturday and Sunday)
                  outside of the currently selected month. (12)
                </p></li><li><p>
                  <tt class="literal">seam-date-hover</tt> &#8212; This class is applied to the table cell
                  (<tt class="literal">td</tt>) element over which the cursor is hovering. (13)
                </p></li><li><p>
                  <tt class="literal">seam-date-monthNames</tt> &#8212; This class is applied to the <tt class="literal">div</tt>
                  control that contains the popup month selector. (14)
                </p></li><li><p>
                  <tt class="literal">seam-date-monthNameLink</tt> &#8212; This class is applied to the anchor (<tt class="literal">a</tt>)
                  controls that contain the popup month names. (15)
                </p></li><li><p>
                  <tt class="literal">seam-date-years </tt> &#8212; This class is applied to the <tt class="literal">div</tt>
                  control that contains the popup year selector. (16)
                </p></li><li><p>
                  <tt class="literal">seam-date-yearLink</tt> &#8212; This class is applied to the anchor (<tt class="literal">a</tt>)
                  controls that contain the popup years. (15)
                </p></li></ul></div><div class="mediaobject" align="center"><img src="../shared/images/controls-selectdatecss.png" align="middle"></div></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:selectItems&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
                 Creates a <tt class="literal">List&lt;SelectItem&gt;</tt> from a List, Set, DataModel or Array.
               </p><p><span class="emphasis"><em>Attributes</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>
                     <tt class="literal">value</tt> &#8212; an EL expression specifying the data that backs the <tt class="literal">List&lt;SelectItem&gt;</tt>
                 </p></li><li><p>
                     <tt class="literal">var</tt> &#8212; defines the name of the local variable that holds the current object during iteration
                 </p></li><li><p>
                     <tt class="literal">label</tt> &#8212; the label to be used when rendering the <tt class="literal">SelectItem</tt>.  Can reference
                     the <tt class="literal">var</tt> variable
                 </p></li><li><p>
                     <tt class="literal">disabled</tt> &#8212; if true the <tt class="literal">SelectItem</tt> will be rendered disabled.  Can reference
                     the <tt class="literal">var</tt> variable
                 </p></li><li><p>
                     <tt class="literal">noSelectionLabel</tt> &#8212; specifies the (optional) label to place at the top of list (if
                     <tt class="literal">required="true"</tt> is also specified then selecting this value will cause a validation error)
                 </p></li><li><p>
                    <tt class="literal">hideNoSelectionLabel</tt> &#8212; if true, the <tt class="literal">noSelectionLabel</tt> will be hidden
                    when a value is selected
                 </p></li></ul></div><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:selectOneMenu value="#{person.age}" 
                 converter="#{converters.ageConverter}"&gt;
  &lt;s:selectItems value="#{ages}" var="age" label="#{age}" /&gt;
&lt;/h:selectOneMenu&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:span&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              Render a HTML <tt class="literal">&lt;span&gt;</tt>.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:span styleClass="required" rendered="#{required}"&gt;*&lt;/s:span&gt;</pre></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:taskId&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
                Add the task id to an output link (or similar JSF control), when the
                task is available via <tt class="literal">#{task}</tt>.
              </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
                None.
            </p></td></tr><tr><td valign="top"><p>
              <tt class="literal">&lt;s:validate&gt;</tt>
            </p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              A non-visual control, validates a JSF input field against the bound
              property using Hibernate Validator.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;h:inputText id="userName" required="true" 
             value="#{customer.userName}"&gt;
  &lt;s:validate /&gt;
&lt;/h:inputText&gt;
&lt;h:message for="userName" styleClass="error" /&gt;</pre></td></tr><tr><td valign="top"><p><tt class="literal">&lt;s:validateAll&gt;</tt></p></td><td valign="top"><p><span class="emphasis"><em>Description</em></span></p><p>
              A non-visual control, validates all child JSF input fields against their bound
              properties using Hibernate Validator.
            </p><p><span class="emphasis"><em>Attributes</em></span></p><p>
              None.
            </p><p><span class="emphasis"><em>Usage</em></span></p><pre class="programlisting">&lt;s:validateAll&gt;
  &lt;div class="entry"&gt;
    &lt;h:outputLabel for="username"&gt;Username:&lt;/h:outputLabel&gt;
    &lt;h:inputText id="username" value="#{user.username}" 
                 required="true"/&gt;
    &lt;h:message for="username" styleClass="error" /&gt;
  &lt;/div&gt;
  &lt;div class="entry"&gt;
    &lt;h:outputLabel for="password"&gt;Password:&lt;/h:outputLabel&gt;
    &lt;h:inputSecret id="password" value="#{user.password}" 
                   required="true"/&gt;
    &lt;h:message for="password" styleClass="error" /&gt;
  &lt;/div&gt;
  &lt;div class="entry"&gt;
    &lt;h:outputLabel for="verify"&gt;Verify Password:&lt;/h:outputLabel&gt;
    &lt;h:inputSecret id="verify" value="#{register.verify}" 
                   required="true"/&gt;
    &lt;h:message for="verify" styleClass="error" /&gt;
  &lt;/div&gt;
&lt;/s:validateAll&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controls.annotations"></a>29.2.&nbsp;Annotations</h2></div></div><div></div></div><p>
    Seam also provides annotations to allow you to use Seam components as JSF
    converters and validators:
    
  </p><div class="variablelist"><dl><dt><span class="term">
        <tt class="literal">@Converter</tt>
      </span></dt><dd><pre class="programlisting">
@Name("fooConverter") 
@BypassInterceptors 
@Converter
public class FooConverter implements Converter {
   
  @Transactional
  public Object getAsObject(FacesContext context, UIComponent cmp, String value) {
    EntityManager entityManager = (EntityManager) Component.getInstance("entityManager");
    entityManager.joinTransaction();
    // Do the conversion
  }
  
  public String getAsString(FacesContext context, UIComponent cmp, Object value) {
    // Do the conversion
  }
  
}</pre><p>
              Registers the Seam component as a JSF converter.  Shown here is a 
              converter which is able to access the JPA EntityManager inside a 
              JTA transaction, when converting the value back to it's object
              representation.
            </p></dd><dt><span class="term">
        <tt class="literal">@Validator</tt>
      </span></dt><dd><pre class="programlisting">
@Name("barValidator") 
@BypassInterceptors 
@Validator
public class BarValidator implements Validator {
   
  public void validate(FacesContext context, UIComponent cmp, Object value)
    throws ValidatorException {
    FooController fooController = (FooController) Component.getInstance("fooController");
    return fooController.validate(value);
  }
  
}</pre><p>
              Registers the Seam component as a JSF validator.  Shown here is a 
              validator which injects another Seam component; the injected 
              component is used to validate the value.
            </p></dd></dl></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="elenhancements"></a>Chapter&nbsp;30.&nbsp;Expression language enhancements</h2></div></div><div></div></div><p> Seam provides an extension to the standard Unified Expression Language (EL) called JBoss EL. JBoss EL
        provides a number of enhancements that increase the expressiveness and power of EL expressions. </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19150"></a>30.1.&nbsp;Parameterized Method Bindings</h2></div></div><div></div></div><p> Standard EL assumes that any parameters to a method expression will be provided by Java code. This means
            that a method with parameters cannot be used as a JSF method binding. Seam provides an enhancement to the EL
            that allows parameters to be included in a method expression itself. This applies to
            <span class="emphasis"><em>any</em></span> Seam method expression, including any JSF method binding, for example: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel)}" value="Book Hotel"/&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19160"></a>30.1.1.&nbsp;Usage</h3></div></div><div></div></div><p> Parameters are surrounded by parentheses, and separated by commas: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel, user)}" value="Book Hotel"/&gt;</pre><p> The parameters <tt class="literal">hotel</tt> and <tt class="literal">user</tt> will be evaluated as value
                expressions and passed to the <tt class="literal">bookHotel()</tt> method of the component. This gives you an
                alternative to the use of <tt class="literal">@In</tt>. </p><p> Any value expression may be used as a parameter: </p><pre class="programlisting">&lt;h:commandButton action="#{hotelBooking.bookHotel(hotel.id, user.username)}" 
                 value="Book Hotel"/&gt;</pre><p>
                <span class="emphasis"><em>Note:</em></span> You can not pass objects as arguments! All that is passed is names, for
                example, <tt class="literal">hotel.id</tt> and <tt class="literal">user.username</tt>. If you check the rendered
                code of the previous example, you will see that the command button contains these names. These name
                arguments will be submitted to the server when you press the button, and Seam will look up and resolve
                these names (in any available context) before the action method is called. If the arguments can not be
                resolved at that time (because <tt class="literal">hotel</tt> and <tt class="literal">user</tt> variables can not be
                found in any available context) the action method will be called with <tt class="literal">null</tt> arguments! </p><p> You may however pass literal strings using single or double quotes: </p><pre class="programlisting">&lt;h:commandLink action="#{printer.println('Hello world!')}" value="Hello"/&gt;</pre><pre class="programlisting">&lt;h:commandLink action="#{printer.println('Hello again')} value="Hello"/&gt;</pre><p> You might even want to use this notation for all your action methods, even when you don't have
                parameters to pass. This improves readability by making it clear that the expression is a method
                expression and not a value expression: </p><pre class="programlisting">&lt;s:link value="Cancel" action="#{hotelBooking.cancel()}"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19215"></a>30.1.2.&nbsp;Limitations</h3></div></div><div></div></div><p> Please be aware of the following limitations: </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e19220"></a>30.1.2.1.&nbsp;Incompatibility with JSP 2.1</h4></div></div><div></div></div><p> This extension is not currently compatible with JSP 2.1. So if you want to use this extension
                    with JSF 1.2, you will need to use Facelets. The extension works correctly with JSP 2.0. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e19225"></a>30.1.2.2.&nbsp;Calling a <tt class="literal">MethodExpression</tt> from Java code</h4></div></div><div></div></div><p> Normally, when a <tt class="literal">MethodExpression</tt> or <tt class="literal">MethodBinding</tt> is
                    created, the parameter types are passed in by JSF. In the case of a method binding, JSF assumes that
                    there are no parameters to pass. With this extension, we can't know the parameter types until
                    after the expression has been evaluated. This has two minor consequences: </p><div class="itemizedlist"><ul type="disc"><li><p> When you invoke a <tt class="literal">MethodExpression</tt> in Java code, parameters you pass
                            may be ignored. Parameters defined in the expression will take precedence. </p></li><li><p> Ordinarily, it is safe to call
                            <tt class="literal">methodExpression.getMethodInfo().getParamTypes()</tt> at any time. For an
                            expression with parameters, you must first invoke the <tt class="literal">MethodExpression</tt>
                            before calling <tt class="literal">getParamTypes()</tt>. </p></li></ul></div><p> Both of these cases are exceedingly rare and only apply when you want to invoke the
                        <tt class="literal">MethodExpression</tt> by hand in Java code. </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19263"></a>30.2.&nbsp;Parameterized Value Bindings</h2></div></div><div></div></div><p> Standard EL only allows access to properties that follow the JavaBean naming conventions. For example,
            the expression <tt class="literal">#{person.name}</tt> requires a <tt class="literal">getName()</tt> be present. Many
            objects, however, don't have appropriately named property accessors or require parameters. These values can
            be retrieved using the method syntax, which work similarly to parameterized method bindings. For example,
            the following expression returns the size of a string using the <tt class="literal">length()</tt> method. </p><pre class="programlisting">#{person.name.length()}</pre><p>You can access the size of a collection in a similar manner.</p><pre class="programlisting">#{searchResults.size()}</pre><p>In general any expression of the form #{obj.property} would be identical to the expression
            #{obj.getProperty()}.</p><p>Parameters are also allowed, and they follow the same restrictions as with method bindings. The following
            example calls the <tt class="literal">productsByColorMethod</tt> with a literal string argument.</p><pre class="programlisting">#{controller.productsByColor('blue')}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19292"></a>30.3.&nbsp;Projection</h2></div></div><div></div></div><p>JBoss EL supports a limited projection syntax. It is important to note that this syntax cannot be parsed
            by Facelets or by JavaServer Pages and thus cannot be used in xhtml or JSP files. We anticipate that the
            projection syntax will change in future versions of JBoss EL. </p><p> A projection expression maps a sub-expression across a multi-valued (list, set, etc...) expression. For
            instance, the expression </p><pre class="programlisting">#{company.departments}</pre><p>might return a list of departments. If you only need a list of department names, your only option is to
            iterate over the list to retrieve the values. JBoss EL allows this with a projection expression.</p><pre class="programlisting">#{company.departments.{d|d.name}}</pre><p>The subexpression is enclosed in braces. In this example, the expression <tt class="literal">d.name</tt> is
            evaluated for each department, using <tt class="literal">d</tt> as an alias to the department object. The result
            of this expression will be a list of String values.</p><p>Any valid expression can be used in an expression, so it would be perfectly valid to write the following,
            assuming you had a use for the lengths of all the department names in a company.</p><pre class="programlisting">#{company.departments.{d|d.size()}}</pre><p>Projections can be nested. The following expression returns the last names of every employee in every
            department.</p><pre class="programlisting">#{company.departments.{d|d.employees.{emp|emp.lastName}}}</pre><p>Nested projections can be slightly tricky, however. The following expression looks like it returns a list
            of all the employees in all the departments. </p><pre class="programlisting">#{company.departments.{d|d.employees}}</pre><p>However, it actually returns a list containing a list of the employees for each individual department. To
            combine the values, it is necessary to use a slightly longer expression.</p><pre class="programlisting">#{company.departments.{d|d.employees.{e|e}}}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>Chapter&nbsp;31.&nbsp;Testing Seam applications</h2></div></div><div></div></div><p>
	    Most Seam applications will need at least two kinds of automated tests:
	    <span class="emphasis"><em>unit tests</em></span>, which test a particular Seam component
	    in isolation, and scripted <span class="emphasis"><em>integration tests</em></span> which
	    exercise all Java layers of the application (that is, everything except the
	    view pages).
	</p><p>
	   Both kinds of tests are very easy to write.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19342"></a>31.1.&nbsp;Unit testing Seam components</h2></div></div><div></div></div><p>
		    All Seam components are POJOs. This is a great place to start if you
		    want easy unit testing. And since Seam emphasises the use of bijection 
            for inter-component interactions and access to contextual objects, it's 
            very easy to test a Seam component outside of its normal runtime 
            environment.
		</p><p>
		    Consider the following Seam component:
		</p><pre class="programlisting">@Stateless
@Scope(EVENT)
@Name("register")
public class RegisterAction implements Register
{
   private User user;
   private EntityManager em;

   @In
   public void setUser(User user) {
       this.user = user;
   }
   
   @PersistenceContext
   public void setBookingDatabase(EntityManager em) {
       this.em = em;
   }
   
   public String register()
   {
      List existing = em.createQuery("select username from User where username=:username")
         .setParameter("username", user.getUsername())
         .getResultList();
      if (existing.size()==0)
      {
         em.persist(user);
         return "success";
      }
      else
      {
         return null;
      }
   }

}</pre><p>
            We could write a TestNG test for this component as follows:
        </p><pre class="programlisting">public class RegisterActionTest
{

    @Test
    public testRegisterAction()
    {
        EntityManager em = getEntityManagerFactory().createEntityManager();
        em.getTransaction().begin();
        
        User gavin = new User();
        gavin.setName("Gavin King");
        gavin.setUserName("1ovthafew");
        gavin.setPassword("secret");
        
        RegisterAction action = new RegisterAction();
        action.setUser(gavin);
        action.setBookingDatabase(em);
        
        assert "success".equals( action.register() );
        
        em.getTransaction().commit();
        em.close();
    }
    
    
    private EntityManagerFactory emf;
    
    public EntityManagerFactory getEntityManagerFactory()
    {
        return emf;
    }
    
    @BeforeClass
    public void init() 
    {
        emf = Persistence.createEntityManagerFactory("myResourceLocalEntityManager");
    }
    
    @AfterClass
    public void destroy()
    {
        emf.close();
    }
    
}
</pre><p>
            The Java Persistence API can be used with both Java SE and Java EE &#8212; 
            when the above component is used inside an Application Server (Java 
            EE) the container is responsible for transaction management, however 
            in the unit test (Java SE) the transaction must be managed 
            explicitly using a resource local entity manager. This requires
            configuration in <tt class="literal">persistence.xml</tt>.
       </p><p>    
            Seam components don't usually depend directly upon container infrastructure,
            so most unit testing as as easy as that!
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19362"></a>31.2.&nbsp;Integration testing Seam components</h2></div></div><div></div></div><p>
            Integration testing is slightly more difficult. In this case, we can't eliminate
            the container infrastructure; indeed, that is part of what is being tested! At
            the same time, we don't want to be forced to deploy our application to an
            application server to run the automated tests. We need to be able to reproduce
            just enough of the container infrastructure inside our testing environment to be 
            able to exercise the whole application, without hurting performance too much.
        </p><p>
            The approach taken by Seam is to let you write tests that exercise your
            components while running inside a pruned down container environment (Seam,
            together with the JBoss Embedded container; n.b. JBoss Embedded requires
            JDK 1.5 and does not work with JDK 1.6).
        </p><pre class="programlisting">public class RegisterTest extends SeamTest
{
   
   @Test
   public void testRegisterComponent() throws Exception
   {
            
      new ComponentTest() {

         protected void testComponents() throws Exception
         {
            setValue("#{user.username}", "1ovthafew");
            setValue("#{user.name}", "Gavin King");
            setValue("#{user.password}", "secret");
            assert invokeMethod("#{register.register}").equals("success");
            assert getValue("#{user.username}").equals("1ovthafew");
            assert getValue("#{user.name}").equals("Gavin King");
            assert getValue("#{user.password}").equals("secret");
         }
         
      }.run();
      
   }

   ...
   
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19371"></a>31.2.1.&nbsp;Using mocks in integration tests</h3></div></div><div></div></div><p>
                Occasionally, we need to be able to replace the implementation of some
                Seam component that depends upon resources which are not available in 
                the integration test environment. For example, suppose we have some
                Seam component which is a facade to some payment processing system:
            </p><pre class="programlisting">@Name("paymentProcessor")
public class PaymentProcessor {
    public boolean processPayment(Payment payment) { .... }
}</pre><p>
                For integration tests, we can mock out this component as follows:
            </p><pre class="programlisting">@Name("paymentProcessor")
@Install(precedence=MOCK)
public class MockPaymentProcessor extends PaymentProcessor {
    public void processPayment(Payment payment) {
        return true;
    }
}</pre><p>
                Since the <tt class="literal">MOCK</tt> precedence is higher than the default
                precedence of application components, Seam will install the mock 
                implementation whenever it is in the classpath. When deployed into 
                production, the mock implementation is absent, so the real component
                will be installed.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19387"></a>31.3.&nbsp;Integration testing Seam application user interactions</h2></div></div><div></div></div><p>
            An even harder problem is emulating user interactions. A third problem is where 
            to put our assertions. Some test frameworks let us test the whole application
            by reproducing user interactions with the web browser. These frameworks have
            their place, but they are not appropriate for use at development time.
        </p><p>
            <tt class="literal">SeamTest</tt> lets you write <span class="emphasis"><em>scripted</em></span> tests,
            in a simulated JSF environment. The role of a scripted test is to reproduce 
            the interaction between the view and the Seam components. In other words, you 
            get to pretend you are the JSF implementation!
        </p><p>
            This approach tests everything except the view.
        </p><p>
            Let's consider a JSP view for the component we unit tested above:
        </p><pre class="programlisting">&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Register New User&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;f:view&gt;
   &lt;h:form&gt;
     &lt;table border="0"&gt;
       &lt;tr&gt;
         &lt;td&gt;Username&lt;/td&gt;
         &lt;td&gt;&lt;h:inputText value="#{user.username}"/&gt;&lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
         &lt;td&gt;Real Name&lt;/td&gt;
         &lt;td&gt;&lt;h:inputText value="#{user.name}"/&gt;&lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
         &lt;td&gt;Password&lt;/td&gt;
         &lt;td&gt;&lt;h:inputSecret value="#{user.password}"/&gt;&lt;/td&gt;
       &lt;/tr&gt;
     &lt;/table&gt;
     &lt;h:messages/&gt;
     &lt;h:commandButton type="submit" value="Register" action="#{register.register}"/&gt;
   &lt;/h:form&gt;
  &lt;/f:view&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre><p>
            We want to test the registration functionality of our application (the stuff
            that happens when the user clicks the Register button). We'll reproduce the JSF 
            request lifecycle in an automated TestNG test:
        </p><pre class="programlisting">public class RegisterTest extends SeamTest
{
   
   @Test
   public void testRegister() throws Exception
   {
            
      new FacesRequest() {

         @Override
         protected void processValidations() throws Exception
         {
            validateValue("#{user.username}", "1ovthafew");
            validateValue("#{user.name}", "Gavin King");
            validateValue("#{user.password}", "secret");
            assert !isValidationFailure();
         }
         
         @Override
         protected void updateModelValues() throws Exception
         {
            setValue("#{user.username}", "1ovthafew");
            setValue("#{user.name}", "Gavin King");
            setValue("#{user.password}", "secret");
         }

         @Override
         protected void invokeApplication()
         {
            assert invokeMethod("#{register.register}").equals("success");
         }

         @Override
         protected void renderResponse()
         {
            assert getValue("#{user.username}").equals("1ovthafew");
            assert getValue("#{user.name}").equals("Gavin King");
            assert getValue("#{user.password}").equals("secret");
         }
         
      }.run();
      
   }

   ...
   
}</pre><p>
            Notice that we've extended <tt class="literal">SeamTest</tt>, which provides a 
            Seam environment for our components, and written our test script as an 
            anonymous class that extends <tt class="literal">SeamTest.FacesRequest</tt>, 
            which provides an emulated JSF request lifecycle. (There is also a
            <tt class="literal">SeamTest.NonFacesRequest</tt> for testing GET requests.)
            We've written our code in methods which are named for the various JSF 
            phases, to emulate the calls that JSF would make to our components. Then 
            we've thrown in various assertions.
        </p><p>
            You'll find plenty of integration tests for the Seam example applications
            which demonstrate more complex cases. There are instructions for running
            these tests using Ant, or using the TestNG plugin for eclipse:
        </p><div class="mediaobject" align="center"><img src="../shared/images/plugin-testng.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19428"></a>31.3.1.&nbsp;Integration Testing with Mock Data</h3></div></div><div></div></div><p>
            If you need to insert or clean data in your database before each 
            test you can use Seam's integration with DBUnit.  To do this, extend 
            DBUnitSeamTest rather than SeamTest.
         </p><p>
            You need to provide a dataset for DBUnit:
         </p><pre class="programlisting">&lt;dataset&gt;
   
   &lt;ARTIST 
      id="1"
      dtype="Band"
      name="Pink Floyd" /&gt;
      
   &lt;DISC
      id="1"
      name="Dark Side of the Moon"
      artist_id="1" /&gt;
      
&lt;/dataset&gt;</pre><p>
            and tell Seam about it by overriding <tt class="literal">prepareDBUnitOperations()</tt>:
         </p><pre class="programlisting">protected void prepareDBUnitOperations() {
    beforeTestOperations.add(
       new DataSetOperation("my/datasets/BaseData.xml")
    );
 }</pre><p>
           <tt class="literal">DataSetOperation</tt> defaults to <tt class="literal">DatabaseOperation.CLEAN_INSERT</tt>
           if no other operation is specified as a constructor argument. The 
           above example cleans all tables defined <tt class="literal">BaseData.xml</tt>, 
           then inserts all rows declared in <tt class="literal">BaseData.xml</tt> 
           before each <tt class="literal">@Test</tt> method is invoked.
         </p><p>
           If you require extra cleanup after a test method executes, add 
           operations to <tt class="literal">afterTestOperations</tt> list.
         </p><p>
           You need to tell DBUnit about the datasource you are using by 
           setting a TestNG test parameter named <tt class="literal">datasourceJndiName</tt>:
         </p><pre class="programlisting">
   &lt;parameter name="datasourceJndiName" value="java:/seamdiscsDatasource"/&gt;
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing.mail"></a>31.3.2.&nbsp;Integration Testing Seam Mail</h3></div></div><div></div></div><p>
            Warning! This feature is still under development.
          </p><p>
            It's very easy to integration test your Seam Mail:
          </p><pre class="programlisting">public class MailTest extends SeamTest {
    
   @Test
   public void testSimpleMessage() throws Exception {
        
      new FacesRequest() {

         @Override
         protected void updateModelValues() throws Exception {
            setValue("#{person.firstname}", "Pete");
            setValue("#{person.lastname}", "Muir");
            setValue("#{person.address}", "test@example.com");
         }
            
         @Override
         protected void invokeApplication() throws Exception {
            MimeMessage renderedMessage = getRenderedMailMessage("/simple.xhtml");
            assert renderedMessage.getAllRecipients().length == 1;
            InternetAddress to = (InternetAddress) renderedMessage.getAllRecipients()[0];
            assert to.getAddress().equals("test@example.com");
         }
            
      }.run();       
   }
}</pre><p>
            We create a new <tt class="literal">FacesRequest</tt> as normal.  Inside 
            the invokeApplication hook we render the message using 
            <tt class="literal">getRenderedMailMessage(viewId);</tt>, passing the 
            viewId of the message to render.  The method returns the rendered
            message on which you can do your tests. You can of course also use
            any of the standard JSF lifecycle methods.
          </p><p>
            There is no support for rendering standard JSF components so you 
            can't test the content body of the mail message easily.
          </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tools"></a>Chapter&nbsp;32.&nbsp;Seam tools</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19495"></a>32.1.&nbsp;jBPM designer and viewer</h2></div></div><div></div></div><p>
       The jBPM designer and viewer will let you design and view in a nice way your business processes and your pageflows.
       This convenient tool is part of JBoss Eclipse IDE and more details can be found in the jBPM's documentation (http://docs.jboss.com/jbpm/v3/gpd/)         
     </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19500"></a>32.1.1.&nbsp;Business process designer</h3></div></div><div></div></div><p>
         This tool lets you design your own business process in a graphical way.
       </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/bpmd.png" align="middle"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19513"></a>32.1.2.&nbsp;Pageflow viewer</h3></div></div><div></div></div><p>
         This tool let you design to some extend your pageflows and let you build graphical views of them so you can
         easily share and compare ideas on how it should be designed.
       </p><div class="screenshot"><div class="mediaobject" align="center"><img src="../shared/images/bpmpfv.png" align="middle"></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dependencies"></a>Chapter&nbsp;33.&nbsp;Dependencies</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19530"></a>33.1.&nbsp;Project Dependencies</h2></div></div><div></div></div><p>
      This section both lists the compile-time and runtime dependencies for Seam.
      Where the type is listed as <tt class="literal">ear</tt>, the library should be
      included in the /lib directory of your application's ear file. Where the
      type is listed as <tt class="literal">war</tt>, the library should be placed in 
      the <tt class="literal">/WEB-INF/lib</tt> directory of your application's war
      file.  The scope of the dependency is either all, runtime or provided (by
      JBoss AS 4.2).
    </p><p>
      Up to date version information is not included in the docs, but is provided 
      in the <tt class="literal">/build/root.pom.xml</tt> Maven POM.  
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19549"></a>33.1.1.&nbsp;Core</h3></div></div><div></div></div><div class="table"><a name="d0e19552"></a><p class="title"><b>Table&nbsp;33.1.&nbsp;</b></p><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">commons-codec.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Required by Seam Security when using Digest authentication.</p></td></tr><tr><td><p><tt class="literal">jboss-seam.jar</tt></p></td><td align="center"><p>all</p></td><td align="center"><p>ear</p></td><td><p>The core Seam library, always required.</p></td></tr><tr><td><p><tt class="literal">jboss-seam-debug.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Include during development when enabling Seam's debug feature</p></td></tr><tr><td><p><tt class="literal">jboss-seam-ioc.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required when using Seam with Spring</p></td></tr><tr><td><p><tt class="literal">jboss-seam-pdf.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required when using Seam's PDF features</p></td></tr><tr><td><p><tt class="literal">jboss-seam-remoting.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required when using Seam Remoting</p></td></tr><tr><td><p><tt class="literal">jboss-seam-ui.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required to use the Seam JSF controls</p></td></tr><tr><td><p><tt class="literal">jsf-api.jar</tt></p></td><td align="center"><p>provided</p></td><td align="center"><p></p></td><td><p>JSF API</p></td></tr><tr><td><p><tt class="literal">jsf-impl.jar</tt></p></td><td align="center"><p>provided</p></td><td align="center"><p></p></td><td><p>JSF Reference Implementation</p></td></tr><tr><td><p><tt class="literal">jsf-facelets.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Facelets</p></td></tr><tr><td><p><tt class="literal">urlrewrite.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>URL Rewrite library</p></td></tr><tr><td><p><tt class="literal">jcaptcha-all.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Required for Captcha support</p></td></tr><tr><td><p><tt class="literal">quartz.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Required when you wish to use Quartz with Seam's asynchronous features</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19753"></a>33.1.2.&nbsp;RichFaces</h3></div></div><div></div></div><div class="table"><a name="d0e19756"></a><p class="title"><b>Table&nbsp;33.2.&nbsp;RichFaces dependencies</b></p><table summary="RichFaces dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">richfaces-api.jar</tt></p></td><td align="center"><p>all</p></td><td align="center"><p>ear</p></td><td><p>
                  Required to use RichFaces.  Provides API classes that you may
                  wish to use from your application e.g. to create a tree
                </p></td></tr><tr><td><p><tt class="literal">richfaces-impl.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required to use RichFaces.</p></td></tr><tr><td><p><tt class="literal">richfaces-ui.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required to use RichFaces.  Provides all the UI components.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19821"></a>33.1.3.&nbsp;Seam Mail</h3></div></div><div></div></div><div class="table"><a name="d0e19824"></a><p class="title"><b>Table&nbsp;33.3.&nbsp;Seam Mail Dependencies</b></p><table summary="Seam Mail Dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">activation.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Required for attachment support</p></td></tr><tr><td><p><tt class="literal">mail.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Required for outgoing mail support</p></td></tr><tr><td><p><tt class="literal">mail-ra.jar</tt></p></td><td align="center"><p>compile only</p></td><td align="center"><p></p></td><td><p>Required for incoming mail support</p><p>mail-ra.rar should be deployed to the application server
                at runtime</p></td></tr><tr><td><p><tt class="literal">jboss-seam-mail.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Seam Mail</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19904"></a>33.1.4.&nbsp;Seam PDF</h3></div></div><div></div></div><div class="table"><a name="d0e19907"></a><p class="title"><b>Table&nbsp;33.4.&nbsp;Seam PDF Dependencies</b></p><table summary="Seam PDF Dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Type</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">itext.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>PDF Library</p></td></tr><tr><td><p><tt class="literal">jfreechart.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Charting library</p></td></tr><tr><td><p><tt class="literal">jcommon.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Required by JFreeChart</p></td></tr><tr><td><p><tt class="literal">jboss-seam-pdf.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>Seam PDF core library</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e19986"></a>33.1.5.&nbsp;JBoss Rules</h3></div></div><div></div></div><p>
        The JBoss Rules libraries can be found in the <tt class="literal">drools/lib</tt> directory in Seam.
      </p><div class="table"><a name="d0e19994"></a><p class="title"><b>Table&nbsp;33.5.&nbsp;JBoss Rules Dependencies</b></p><table summary="JBoss Rules Dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">antlr-runtime.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>ANTLR Runtime Library</p></td></tr><tr><td><p><tt class="literal">core.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>Eclipse JDT</p></td></tr><tr><td><p><tt class="literal">drools-compiler.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p></p></td></tr><tr><td><p><tt class="literal">drools-core.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p></p></td></tr><tr><td><p><tt class="literal">janino.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p></p></td></tr><tr><td><p><tt class="literal">mvel.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p></p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e20097"></a>33.1.6.&nbsp;JBPM</h3></div></div><div></div></div><div class="table"><a name="d0e20100"></a><p class="title"><b>Table&nbsp;33.6.&nbsp;JBPM dependencies</b></p><table summary="JBPM dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">jbpm-jpdl.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p></p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e20136"></a>33.1.7.&nbsp;GWT</h3></div></div><div></div></div><p>
        These libraries are required if you with to use the Google Web Toolkit (GWT) with your Seam application.
      </p><div class="table"><a name="d0e20141"></a><p class="title"><b>Table&nbsp;33.7.&nbsp;GWT dependencies</b></p><table summary="GWT dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">gwt-servlet.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>war</p></td><td><p>The GWT Servlet libs</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e20178"></a>33.1.8.&nbsp;Spring</h3></div></div><div></div></div><p>
        These libraries are required if you with to use the Spring Framework with your Seam application.
      </p><div class="table"><a name="d0e20183"></a><p class="title"><b>Table&nbsp;33.8.&nbsp;Spring Framework dependencies</b></p><table summary="Spring Framework dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">spring.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>The Spring Framework library</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e20220"></a>33.1.9.&nbsp;Groovy</h3></div></div><div></div></div><p>
        These libraries are required if you with to use Groovy with your Seam application.
      </p><div class="table"><a name="d0e20225"></a><p class="title"><b>Table&nbsp;33.9.&nbsp;Groovy dependencies</b></p><table summary="Groovy dependencies" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center"><p>Name</p></th><th align="center"><p>Scope</p></th><th align="center"><p>Type</p></th><th align="center"><p>Notes</p></th></tr></thead><tbody><tr><td><p><tt class="literal">groovy-all.jar</tt></p></td><td align="center"><p>runtime</p></td><td align="center"><p>ear</p></td><td><p>The Groovy libs</p></td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e20262"></a>33.2.&nbsp;Dependency Management using Maven</h2></div></div><div></div></div></div><p>
    Maven offers support for transitive dependency management and can be used
    to manage the dependencies of your Seam project.  You can use Maven Ant
    Tasks to integrate Maven into your Ant build, or can use Maven to build and
    deploy your project.
  </p><p>
    We aren't actually going to discuss how to use Maven here, but just run
    over some basic POMs you could use.
  </p><p>
     Released versions of Seam are available in http://repository.jboss.org/maven2
     and nightly snapshots are available in http://snapshots.jboss.org/maven2.
   </p><p>
     All the Seam artifacts are available in Maven:
   </p><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam-ui&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam-pdf&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam-remoting&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam-ioc&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
  &lt;artifactId&gt;jboss-seam-ioc&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>
    This sample POM will give you Seam, JPA (provided by Hibernate) and 
    Hibernate Validator:
  </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.jboss.seam.example/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;My Seam Project&lt;/name&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;repository.jboss.org&lt;/id&gt;
      &lt;name&gt;JBoss Repository&lt;/name&gt;
      &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
      &lt;version&gt;3.0.0.GA&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
      &lt;version&gt;3.3.1.ga&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.seam&lt;/groupId&gt;
      &lt;artifactId&gt;jboss-seam&lt;/artifactId&gt;
      &lt;version&gt;2.0.0.GA&lt;/version&gt;
    &lt;/dependency&gt;
    
  &lt;/dependencies&gt;

&lt;/project&gt;</pre></div></div></body></html>